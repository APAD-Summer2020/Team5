       # -*- coding: utf-8 -*-
       # flake8: noqa
    1: import marshal
    1: import sys
       
    1: PY2 = sys.version_info[0] == 2
    1: PYPY = hasattr(sys, "pypy_translation_info")
   11: _identity = lambda x: x
       
    1: if not PY2:
    1:     unichr = chr
    1:     range_type = range
    1:     text_type = str
    1:     string_types = (str,)
    1:     integer_types = (int,)
       
    1:     iterkeys = lambda d: iter(d.keys())
    1:     itervalues = lambda d: iter(d.values())
    2:     iteritems = lambda d: iter(d.items())
       
    1:     import pickle
    1:     from io import BytesIO, StringIO
       
    1:     NativeStringIO = StringIO
       
    1:     def reraise(tp, value, tb=None):
               if value.__traceback__ is not tb:
                   raise value.with_traceback(tb)
               raise value
       
    1:     ifilter = filter
    1:     imap = map
    1:     izip = zip
    1:     intern = sys.intern
       
    1:     implements_iterator = _identity
    1:     implements_to_string = _identity
    1:     encode_filename = _identity
       
    1:     marshal_dump = marshal.dump
    1:     marshal_load = marshal.load
       
       else:
           unichr = unichr
           text_type = unicode
           range_type = xrange
           string_types = (str, unicode)
           integer_types = (int, long)
       
           iterkeys = lambda d: d.iterkeys()
           itervalues = lambda d: d.itervalues()
           iteritems = lambda d: d.iteritems()
       
           import cPickle as pickle
           from cStringIO import StringIO as BytesIO, StringIO
       
           NativeStringIO = BytesIO
       
           exec("def reraise(tp, value, tb=None):\n raise tp, value, tb")
       
           from itertools import imap, izip, ifilter
       
           intern = intern
       
           def implements_iterator(cls):
               cls.next = cls.__next__
               del cls.__next__
               return cls
       
           def implements_to_string(cls):
               cls.__unicode__ = cls.__str__
               cls.__str__ = lambda x: x.__unicode__().encode("utf-8")
               return cls
       
           def encode_filename(filename):
               if isinstance(filename, unicode):
                   return filename.encode("utf-8")
               return filename
       
           def marshal_dump(code, f):
               if isinstance(f, file):
                   marshal.dump(code, f)
               else:
                   f.write(marshal.dumps(code))
       
           def marshal_load(f):
               if isinstance(f, file):
                   return marshal.load(f)
               return marshal.loads(f.read())
       
       
    1: def with_metaclass(meta, *bases):
           """Create a base class with a metaclass."""
           # This requires a bit of explanation: the basic idea is to make a
           # dummy metaclass for one level of class instantiation that replaces
           # itself with the actual metaclass.
    6:     class metaclass(type):
    3:         def __new__(cls, name, this_bases, d):
    3:             return meta(name, bases, d)
       
    3:     return type.__new__(metaclass, "temporary_class", (), {})
       
       
    1: try:
    1:     from urllib.parse import quote_from_bytes as url_quote
       except ImportError:
           from urllib import quote as url_quote
       
       
    1: try:
    1:     from collections import abc
       except ImportError:
           import collections as abc
       
       
    1: try:
    1:     from os import fspath
       except ImportError:
           try:
               from pathlib import PurePath
           except ImportError:
               PurePath = None
       
           def fspath(path):
               if hasattr(path, "__fspath__"):
                   return path.__fspath__()
       
               # Python 3.5 doesn't have __fspath__ yet, use str.
               if PurePath is not None and isinstance(path, PurePath):
                   return str(path)
       
               return path
