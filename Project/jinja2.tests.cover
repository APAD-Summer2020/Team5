       # -*- coding: utf-8 -*-
    1: """Built-in template tests used with the ``is`` operator."""
    1: import decimal
    1: import operator
    1: import re
       
    1: from ._compat import abc
    1: from ._compat import integer_types
    1: from ._compat import string_types
    1: from ._compat import text_type
    1: from .runtime import Undefined
       
    1: number_re = re.compile(r"^-?\d+(\.\d+)?$")
    1: regex_type = type(number_re)
    1: test_callable = callable
       
       
    1: def test_odd(value):
           """Return true if the variable is odd."""
           return value % 2 == 1
       
       
    1: def test_even(value):
           """Return true if the variable is even."""
           return value % 2 == 0
       
       
    1: def test_divisibleby(value, num):
           """Check if a variable is divisible by a number."""
           return value % num == 0
       
       
    1: def test_defined(value):
           """Return true if the variable is defined:
       
           .. sourcecode:: jinja
       
               {% if variable is defined %}
                   value of variable: {{ variable }}
               {% else %}
                   variable is not defined
               {% endif %}
       
           See the :func:`default` filter for a simple way to set undefined
           variables.
           """
           return not isinstance(value, Undefined)
       
       
    1: def test_undefined(value):
           """Like :func:`defined` but the other way round."""
           return isinstance(value, Undefined)
       
       
    1: def test_none(value):
           """Return true if the variable is none."""
           return value is None
       
       
    1: def test_boolean(value):
           """Return true if the object is a boolean value.
       
           .. versionadded:: 2.11
           """
           return value is True or value is False
       
       
    1: def test_false(value):
           """Return true if the object is False.
       
           .. versionadded:: 2.11
           """
           return value is False
       
       
    1: def test_true(value):
           """Return true if the object is True.
       
           .. versionadded:: 2.11
           """
           return value is True
       
       
       # NOTE: The existing 'number' test matches booleans and floats
    1: def test_integer(value):
           """Return true if the object is an integer.
       
           .. versionadded:: 2.11
           """
           return isinstance(value, integer_types) and value is not True and value is not False
       
       
       # NOTE: The existing 'number' test matches booleans and integers
    1: def test_float(value):
           """Return true if the object is a float.
       
           .. versionadded:: 2.11
           """
           return isinstance(value, float)
       
       
    1: def test_lower(value):
           """Return true if the variable is lowercased."""
           return text_type(value).islower()
       
       
    1: def test_upper(value):
           """Return true if the variable is uppercased."""
           return text_type(value).isupper()
       
       
    1: def test_string(value):
           """Return true if the object is a string."""
           return isinstance(value, string_types)
       
       
    1: def test_mapping(value):
           """Return true if the object is a mapping (dict etc.).
       
           .. versionadded:: 2.6
           """
           return isinstance(value, abc.Mapping)
       
       
    1: def test_number(value):
           """Return true if the variable is a number."""
           return isinstance(value, integer_types + (float, complex, decimal.Decimal))
       
       
    1: def test_sequence(value):
           """Return true if the variable is a sequence. Sequences are variables
           that are iterable.
           """
           try:
               len(value)
               value.__getitem__
           except Exception:
               return False
           return True
       
       
    1: def test_sameas(value, other):
           """Check if an object points to the same memory address than another
           object:
       
           .. sourcecode:: jinja
       
               {% if foo.attribute is sameas false %}
                   the foo attribute really is the `False` singleton
               {% endif %}
           """
           return value is other
       
       
    1: def test_iterable(value):
           """Check if it's possible to iterate over an object."""
           try:
               iter(value)
           except TypeError:
               return False
           return True
       
       
    1: def test_escaped(value):
           """Check if the value is escaped."""
           return hasattr(value, "__html__")
       
       
    1: def test_in(value, seq):
           """Check if value is in seq.
       
           .. versionadded:: 2.10
           """
           return value in seq
       
       
       TESTS = {
    1:     "odd": test_odd,
    1:     "even": test_even,
    1:     "divisibleby": test_divisibleby,
    1:     "defined": test_defined,
    1:     "undefined": test_undefined,
    1:     "none": test_none,
    1:     "boolean": test_boolean,
    1:     "false": test_false,
    1:     "true": test_true,
    1:     "integer": test_integer,
    1:     "float": test_float,
    1:     "lower": test_lower,
    1:     "upper": test_upper,
    1:     "string": test_string,
    1:     "mapping": test_mapping,
    1:     "number": test_number,
    1:     "sequence": test_sequence,
    1:     "iterable": test_iterable,
    1:     "callable": test_callable,
    1:     "sameas": test_sameas,
    1:     "escaped": test_escaped,
    1:     "in": test_in,
    1:     "==": operator.eq,
    1:     "eq": operator.eq,
    1:     "equalto": operator.eq,
    1:     "!=": operator.ne,
    1:     "ne": operator.ne,
    1:     ">": operator.gt,
    1:     "gt": operator.gt,
    1:     "greaterthan": operator.gt,
    1:     "ge": operator.ge,
    1:     ">=": operator.ge,
    1:     "<": operator.lt,
    1:     "lt": operator.lt,
    1:     "lessthan": operator.lt,
    1:     "<=": operator.le,
    1:     "le": operator.le,
       }
