       # Copyright 2017 Google LLC
       #
       # Licensed under the Apache License, Version 2.0 (the "License");
       # you may not use this file except in compliance with the License.
       # You may obtain a copy of the License at
       #
       #      http://www.apache.org/licenses/LICENSE-2.0
       #
       # Unless required by applicable law or agreed to in writing, software
       # distributed under the License is distributed on an "AS IS" BASIS,
       # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       # See the License for the specific language governing permissions and
       # limitations under the License.
       
       """RSA verifier and signer that use the ``cryptography`` library.
       
       This is a much faster implementation than the default (in
       ``google.auth.crypt._python_rsa``), which depends on the pure-Python
       ``rsa`` library.
    1: """
       
    1: import cryptography.exceptions
    1: from cryptography.hazmat import backends
    1: from cryptography.hazmat.primitives import hashes
    1: from cryptography.hazmat.primitives import serialization
    1: from cryptography.hazmat.primitives.asymmetric import padding
    1: import cryptography.x509
    1: import pkg_resources
       
    1: from google.auth import _helpers
    1: from google.auth.crypt import base
       
       _IMPORT_ERROR_MSG = (
    1:     "cryptography>=1.4.0 is required to use cryptography-based RSA " "implementation."
       )
       
    1: try:  # pragma: NO COVER
    1:     release = pkg_resources.get_distribution("cryptography").parsed_version
    1:     if release < pkg_resources.parse_version("1.4.0"):
               raise ImportError(_IMPORT_ERROR_MSG)
       except pkg_resources.DistributionNotFound:  # pragma: NO COVER
           raise ImportError(_IMPORT_ERROR_MSG)
       
       
    1: _CERTIFICATE_MARKER = b"-----BEGIN CERTIFICATE-----"
    1: _BACKEND = backends.default_backend()
    1: _PADDING = padding.PKCS1v15()
    1: _SHA256 = hashes.SHA256()
       
       
    2: class RSAVerifier(base.Verifier):
           """Verifies RSA cryptographic signatures using public keys.
       
           Args:
               public_key (
                       cryptography.hazmat.primitives.asymmetric.rsa.RSAPublicKey):
                   The public key used to verify signatures.
    1:     """
       
    1:     def __init__(self, public_key):
               self._pubkey = public_key
       
    1:     @_helpers.copy_docstring(base.Verifier)
           def verify(self, message, signature):
               message = _helpers.to_bytes(message)
               try:
                   self._pubkey.verify(signature, message, _PADDING, _SHA256)
                   return True
               except (ValueError, cryptography.exceptions.InvalidSignature):
                   return False
       
    1:     @classmethod
           def from_string(cls, public_key):
               """Construct an Verifier instance from a public key or public
               certificate string.
       
               Args:
                   public_key (Union[str, bytes]): The public key in PEM format or the
                       x509 public key certificate.
       
               Returns:
                   Verifier: The constructed verifier.
       
               Raises:
                   ValueError: If the public key can't be parsed.
               """
               public_key_data = _helpers.to_bytes(public_key)
       
               if _CERTIFICATE_MARKER in public_key_data:
                   cert = cryptography.x509.load_pem_x509_certificate(
                       public_key_data, _BACKEND
                   )
                   pubkey = cert.public_key()
       
               else:
                   pubkey = serialization.load_pem_public_key(public_key_data, _BACKEND)
       
               return cls(pubkey)
       
       
    2: class RSASigner(base.Signer, base.FromServiceAccountMixin):
           """Signs messages with an RSA private key.
       
           Args:
               private_key (
                       cryptography.hazmat.primitives.asymmetric.rsa.RSAPrivateKey):
                   The private key to sign with.
               key_id (str): Optional key ID used to identify this private key. This
                   can be useful to associate the private key with its associated
                   public key or certificate.
    1:     """
       
    1:     def __init__(self, private_key, key_id=None):
    1:         self._key = private_key
    1:         self._key_id = key_id
       
    1:     @property
    1:     @_helpers.copy_docstring(base.Signer)
           def key_id(self):
    1:         return self._key_id
       
    1:     @_helpers.copy_docstring(base.Signer)
           def sign(self, message):
    1:         message = _helpers.to_bytes(message)
    1:         return self._key.sign(message, _PADDING, _SHA256)
       
    1:     @classmethod
    1:     def from_string(cls, key, key_id=None):
               """Construct a RSASigner from a private key in PEM format.
       
               Args:
                   key (Union[bytes, str]): Private key in PEM format.
                   key_id (str): An optional key id used to identify the private key.
       
               Returns:
                   google.auth.crypt._cryptography_rsa.RSASigner: The
                   constructed signer.
       
               Raises:
                   ValueError: If ``key`` is not ``bytes`` or ``str`` (unicode).
                   UnicodeDecodeError: If ``key`` is ``bytes`` but cannot be decoded
                       into a UTF-8 ``str``.
                   ValueError: If ``cryptography`` "Could not deserialize key data."
               """
    1:         key = _helpers.to_bytes(key)
    1:         private_key = serialization.load_pem_private_key(
    1:             key, password=None, backend=_BACKEND
               )
    1:         return cls(private_key, key_id=key_id)
