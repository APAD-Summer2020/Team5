       # -----------------------------------------------------------------------------
       # ply: lex.py
       #
       # Copyright (C) 2001-2017
       # David M. Beazley (Dabeaz LLC)
       # All rights reserved.
       #
       # Redistribution and use in source and binary forms, with or without
       # modification, are permitted provided that the following conditions are
       # met:
       #
       # * Redistributions of source code must retain the above copyright notice,
       #   this list of conditions and the following disclaimer.
       # * Redistributions in binary form must reproduce the above copyright notice,
       #   this list of conditions and the following disclaimer in the documentation
       #   and/or other materials provided with the distribution.
       # * Neither the name of the David Beazley or Dabeaz LLC may be used to
       #   endorse or promote products derived from this software without
       #  specific prior written permission.
       #
       # THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
       # "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
       # LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
       # A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
       # OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
       # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
       # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
       # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
       # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
       # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
       # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
       # -----------------------------------------------------------------------------
       
    1: __version__    = '3.10'
    1: __tabversion__ = '3.10'
       
    1: import re
    1: import sys
    1: import types
    1: import copy
    1: import os
    1: import inspect
       
       # This tuple contains known string types
    1: try:
           # Python 2.6
    1:     StringTypes = (types.StringType, types.UnicodeType)
    1: except AttributeError:
           # Python 3.0
    1:     StringTypes = (str, bytes)
       
       # This regular expression is used to match valid token names
    1: _is_identifier = re.compile(r'^[a-zA-Z0-9_]+$')
       
       # Exception thrown when invalid token encountered and no default error
       # handler is defined.
    2: class LexError(Exception):
    1:     def __init__(self, message, s):
               self.args = (message,)
               self.text = s
       
       
       # Token class.  This class is used to represent the tokens produced.
    2: class LexToken(object):
    1:     def __str__(self):
               return 'LexToken(%s,%r,%d,%d)' % (self.type, self.value, self.lineno, self.lexpos)
       
    1:     def __repr__(self):
               return str(self)
       
       
       # This object is a stand-in for a logging object created by the
       # logging module.
       
    2: class PlyLogger(object):
    1:     def __init__(self, f):
    1:         self.f = f
       
    1:     def critical(self, msg, *args, **kwargs):
               self.f.write((msg % args) + '\n')
       
    1:     def warning(self, msg, *args, **kwargs):
               self.f.write('WARNING: ' + (msg % args) + '\n')
       
    1:     def error(self, msg, *args, **kwargs):
               self.f.write('ERROR: ' + (msg % args) + '\n')
       
    1:     info = critical
    1:     debug = critical
       
       
       # Null logger is used when no output is generated. Does nothing.
    2: class NullLogger(object):
    1:     def __getattribute__(self, name):
               return self
       
    1:     def __call__(self, *args, **kwargs):
               return self
       
       
       # -----------------------------------------------------------------------------
       #                        === Lexing Engine ===
       #
       # The following Lexer class implements the lexer runtime.   There are only
       # a few public methods and attributes:
       #
       #    input()          -  Store a new string in the lexer
       #    token()          -  Get the next token
       #    clone()          -  Clone the lexer
       #
       #    lineno           -  Current line number
       #    lexpos           -  Current position in the input string
       # -----------------------------------------------------------------------------
       
    2: class Lexer:
    1:     def __init__(self):
    1:         self.lexre = None             # Master regular expression. This is a list of
                                             # tuples (re, findex) where re is a compiled
                                             # regular expression and findex is a list
                                             # mapping regex group numbers to rules
    1:         self.lexretext = None         # Current regular expression strings
    1:         self.lexstatere = {}          # Dictionary mapping lexer states to master regexs
    1:         self.lexstateretext = {}      # Dictionary mapping lexer states to regex strings
    1:         self.lexstaterenames = {}     # Dictionary mapping lexer states to symbol names
    1:         self.lexstate = 'INITIAL'     # Current lexer state
    1:         self.lexstatestack = []       # Stack of lexer states
    1:         self.lexstateinfo = None      # State information
    1:         self.lexstateignore = {}      # Dictionary of ignored characters for each state
    1:         self.lexstateerrorf = {}      # Dictionary of error functions for each state
    1:         self.lexstateeoff = {}        # Dictionary of eof functions for each state
    1:         self.lexreflags = 0           # Optional re compile flags
    1:         self.lexdata = None           # Actual input data (as a string)
    1:         self.lexpos = 0               # Current position in input text
    1:         self.lexlen = 0               # Length of the input text
    1:         self.lexerrorf = None         # Error rule (if any)
    1:         self.lexeoff = None           # EOF rule (if any)
    1:         self.lextokens = None         # List of valid tokens
    1:         self.lexignore = ''           # Ignored characters
    1:         self.lexliterals = ''         # Literal characters that can be passed through
    1:         self.lexmodule = None         # Module
    1:         self.lineno = 1               # Current line number
    1:         self.lexoptimize = False      # Optimized mode
       
    1:     def clone(self, object=None):
               c = copy.copy(self)
       
               # If the object parameter has been supplied, it means we are attaching the
               # lexer to a new object.  In this case, we have to rebind all methods in
               # the lexstatere and lexstateerrorf tables.
       
               if object:
                   newtab = {}
                   for key, ritem in self.lexstatere.items():
                       newre = []
                       for cre, findex in ritem:
                           newfindex = []
                           for f in findex:
                               if not f or not f[0]:
                                   newfindex.append(f)
                                   continue
                               newfindex.append((getattr(object, f[0].__name__), f[1]))
                       newre.append((cre, newfindex))
                       newtab[key] = newre
                   c.lexstatere = newtab
                   c.lexstateerrorf = {}
                   for key, ef in self.lexstateerrorf.items():
                       c.lexstateerrorf[key] = getattr(object, ef.__name__)
                   c.lexmodule = object
               return c
       
           # ------------------------------------------------------------
           # writetab() - Write lexer information to a table file
           # ------------------------------------------------------------
    1:     def writetab(self, lextab, outputdir=''):
               if isinstance(lextab, types.ModuleType):
                   raise IOError("Won't overwrite existing lextab module")
               basetabmodule = lextab.split('.')[-1]
               filename = os.path.join(outputdir, basetabmodule) + '.py'
               with open(filename, 'w') as tf:
                   tf.write('# %s.py. This file automatically created by PLY (version %s). Don\'t edit!\n' % (basetabmodule, __version__))
                   tf.write('_tabversion   = %s\n' % repr(__tabversion__))
                   tf.write('_lextokens    = set(%s)\n' % repr(tuple(self.lextokens)))
                   tf.write('_lexreflags   = %s\n' % repr(self.lexreflags))
                   tf.write('_lexliterals  = %s\n' % repr(self.lexliterals))
                   tf.write('_lexstateinfo = %s\n' % repr(self.lexstateinfo))
       
                   # Rewrite the lexstatere table, replacing function objects with function names
                   tabre = {}
                   for statename, lre in self.lexstatere.items():
                       titem = []
                       for (pat, func), retext, renames in zip(lre, self.lexstateretext[statename], self.lexstaterenames[statename]):
                           titem.append((retext, _funcs_to_names(func, renames)))
                       tabre[statename] = titem
       
                   tf.write('_lexstatere   = %s\n' % repr(tabre))
                   tf.write('_lexstateignore = %s\n' % repr(self.lexstateignore))
       
                   taberr = {}
                   for statename, ef in self.lexstateerrorf.items():
                       taberr[statename] = ef.__name__ if ef else None
                   tf.write('_lexstateerrorf = %s\n' % repr(taberr))
       
                   tabeof = {}
                   for statename, ef in self.lexstateeoff.items():
                       tabeof[statename] = ef.__name__ if ef else None
                   tf.write('_lexstateeoff = %s\n' % repr(tabeof))
       
           # ------------------------------------------------------------
           # readtab() - Read lexer information from a tab file
           # ------------------------------------------------------------
    1:     def readtab(self, tabfile, fdict):
    1:         if isinstance(tabfile, types.ModuleType):
                   lextab = tabfile
               else:
    1:             exec('import %s' % tabfile)
    1:             lextab = sys.modules[tabfile]
       
    1:         if getattr(lextab, '_tabversion', '0.0') != __tabversion__:
                   raise ImportError('Inconsistent PLY version')
       
    1:         self.lextokens      = lextab._lextokens
    1:         self.lexreflags     = lextab._lexreflags
    1:         self.lexliterals    = lextab._lexliterals
    1:         self.lextokens_all  = self.lextokens | set(self.lexliterals)
    1:         self.lexstateinfo   = lextab._lexstateinfo
    1:         self.lexstateignore = lextab._lexstateignore
    1:         self.lexstatere     = {}
    1:         self.lexstateretext = {}
    4:         for statename, lre in lextab._lexstatere.items():
    3:             titem = []
    3:             txtitem = []
    9:             for pat, func_name in lre:
    6:                 titem.append((re.compile(pat, lextab._lexreflags), _names_to_funcs(func_name, fdict)))
       
    3:             self.lexstatere[statename] = titem
    3:             self.lexstateretext[statename] = txtitem
       
    1:         self.lexstateerrorf = {}
    4:         for statename, ef in lextab._lexstateerrorf.items():
    3:             self.lexstateerrorf[statename] = fdict[ef]
       
    1:         self.lexstateeoff = {}
    1:         for statename, ef in lextab._lexstateeoff.items():
                   self.lexstateeoff[statename] = fdict[ef]
       
    1:         self.begin('INITIAL')
       
           # ------------------------------------------------------------
           # input() - Push a new string into the lexer
           # ------------------------------------------------------------
    1:     def input(self, s):
               # Pull off the first character to see if s looks like a string
   19:         c = s[:1]
   19:         if not isinstance(c, StringTypes):
                   raise ValueError('Expected a string')
   19:         self.lexdata = s
   19:         self.lexpos = 0
   19:         self.lexlen = len(s)
       
           # ------------------------------------------------------------
           # begin() - Changes the lexing state
           # ------------------------------------------------------------
    1:     def begin(self, state):
   77:         if state not in self.lexstatere:
                   raise ValueError('Undefined state')
   77:         self.lexre = self.lexstatere[state]
   77:         self.lexretext = self.lexstateretext[state]
   77:         self.lexignore = self.lexstateignore.get(state, '')
   77:         self.lexerrorf = self.lexstateerrorf.get(state, None)
   77:         self.lexeoff = self.lexstateeoff.get(state, None)
   77:         self.lexstate = state
       
           # ------------------------------------------------------------
           # push_state() - Changes the lexing state and saves old on stack
           # ------------------------------------------------------------
    1:     def push_state(self, state):
               self.lexstatestack.append(self.lexstate)
               self.begin(state)
       
           # ------------------------------------------------------------
           # pop_state() - Restores the previous state
           # ------------------------------------------------------------
    1:     def pop_state(self):
               self.begin(self.lexstatestack.pop())
       
           # ------------------------------------------------------------
           # current_state() - Returns the current lexing state
           # ------------------------------------------------------------
    1:     def current_state(self):
               return self.lexstate
       
           # ------------------------------------------------------------
           # skip() - Skip ahead n characters
           # ------------------------------------------------------------
    1:     def skip(self, n):
               self.lexpos += n
       
           # ------------------------------------------------------------
           # opttoken() - Return the next token from the Lexer
           #
           # Note: This function has been carefully implemented to be as fast
           # as possible.  Don't make changes unless you really know what
           # you are doing
           # ------------------------------------------------------------
    1:     def token(self):
               # Make local copies of frequently referenced attributes
 1953:         lexpos    = self.lexpos
 1953:         lexlen    = self.lexlen
 1953:         lexignore = self.lexignore
 1953:         lexdata   = self.lexdata
       
 9671:         while lexpos < lexlen:
                   # This code provides some short-circuit code for whitespace, tabs, and other ignored characters
 9652:             if lexdata[lexpos] in lexignore:
 7266:                 lexpos += 1
 7266:                 continue
       
                   # Look for a regular expression match
 7031:             for lexre, lexindexfunc in self.lexre:
 7031:                 m = lexre.match(lexdata, lexpos)
 7031:                 if not m:
 4645:                     continue
       
                       # Create a token for return
 2386:                 tok = LexToken()
 2386:                 tok.value = m.group()
 2386:                 tok.lineno = self.lineno
 2386:                 tok.lexpos = lexpos
       
 2386:                 i = m.lastindex
 2386:                 func, tok.type = lexindexfunc[i]
       
 2386:                 if not func:
                           # If no token type was set, it's an ignored token
  788:                     if tok.type:
  788:                         self.lexpos = m.end()
  788:                         return tok
                           else:
                               lexpos = m.end()
                               break
       
 1598:                 lexpos = m.end()
       
                       # If token is processed by a function, call it
       
 1598:                 tok.lexer = self      # Set additional attributes useful in token rules
 1598:                 self.lexmatch = m
 1598:                 self.lexpos = lexpos
       
 1598:                 newtok = func(tok)
       
                       # Every function must return a token, if nothing, we just move to next token
 1598:                 if not newtok:
  452:                     lexpos    = self.lexpos         # This is here in case user has updated lexpos.
  452:                     lexignore = self.lexignore      # This is here in case there was a state change
  452:                     break
       
                       # Verify type of the token.  If not in the token map, raise an error
 1146:                 if not self.lexoptimize:
                           if newtok.type not in self.lextokens_all:
                               raise LexError("%s:%d: Rule '%s' returned an unknown token type '%s'" % (
                                   func.__code__.co_filename, func.__code__.co_firstlineno,
                                   func.__name__, newtok.type), lexdata[lexpos:])
       
 1146:                 return newtok
                   else:
                       # No match, see if in literals
                       if lexdata[lexpos] in self.lexliterals:
                           tok = LexToken()
                           tok.value = lexdata[lexpos]
                           tok.lineno = self.lineno
                           tok.type = tok.value
                           tok.lexpos = lexpos
                           self.lexpos = lexpos + 1
                           return tok
       
                       # No match. Call t_error() if defined.
                       if self.lexerrorf:
                           tok = LexToken()
                           tok.value = self.lexdata[lexpos:]
                           tok.lineno = self.lineno
                           tok.type = 'error'
                           tok.lexer = self
                           tok.lexpos = lexpos
                           self.lexpos = lexpos
                           newtok = self.lexerrorf(tok)
                           if lexpos == self.lexpos:
                               # Error method didn't change text position at all. This is an error.
                               raise LexError("Scanning error. Illegal character '%s'" % (lexdata[lexpos]), lexdata[lexpos:])
                           lexpos = self.lexpos
                           if not newtok:
                               continue
                           return newtok
       
                       self.lexpos = lexpos
                       raise LexError("Illegal character '%s' at index %d" % (lexdata[lexpos], lexpos), lexdata[lexpos:])
       
   19:         if self.lexeoff:
                   tok = LexToken()
                   tok.type = 'eof'
                   tok.value = ''
                   tok.lineno = self.lineno
                   tok.lexpos = lexpos
                   tok.lexer = self
                   self.lexpos = lexpos
                   newtok = self.lexeoff(tok)
                   return newtok
       
   19:         self.lexpos = lexpos + 1
   19:         if self.lexdata is None:
                   raise RuntimeError('No input string given with input()')
   19:         return None
       
           # Iterator interface
    1:     def __iter__(self):
               return self
       
    1:     def next(self):
               t = self.token()
               if t is None:
                   raise StopIteration
               return t
       
    1:     __next__ = next
       
       # -----------------------------------------------------------------------------
       #                           ==== Lex Builder ===
       #
       # The functions and classes below are used to collect lexing information
       # and build a Lexer object from it.
       # -----------------------------------------------------------------------------
       
       # -----------------------------------------------------------------------------
       # _get_regex(func)
       #
       # Returns the regular expression assigned to a function either as a doc string
       # or as a .regex attribute attached by the @TOKEN decorator.
       # -----------------------------------------------------------------------------
    1: def _get_regex(func):
           return getattr(func, 'regex', func.__doc__)
       
       # -----------------------------------------------------------------------------
       # get_caller_module_dict()
       #
       # This function returns a dictionary containing all of the symbols defined within
       # a caller further down the call stack.  This is used to get the environment
       # associated with the yacc() call if none was provided.
       # -----------------------------------------------------------------------------
    1: def get_caller_module_dict(levels):
           f = sys._getframe(levels)
           ldict = f.f_globals.copy()
           if f.f_globals != f.f_locals:
               ldict.update(f.f_locals)
           return ldict
       
       # -----------------------------------------------------------------------------
       # _funcs_to_names()
       #
       # Given a list of regular expression functions, this converts it to a list
       # suitable for output to a table file
       # -----------------------------------------------------------------------------
    1: def _funcs_to_names(funclist, namelist):
           result = []
           for f, name in zip(funclist, namelist):
               if f and f[0]:
                   result.append((name, f[1]))
               else:
                   result.append(f)
           return result
       
       # -----------------------------------------------------------------------------
       # _names_to_funcs()
       #
       # Given a list of regular expression function names, this converts it back to
       # functions.
       # -----------------------------------------------------------------------------
    1: def _names_to_funcs(namelist, fdict):
    6:     result = []
  201:     for n in namelist:
  195:         if n and n[0]:
   25:             result.append((fdict[n[0]], n[1]))
               else:
  170:             result.append(n)
    6:     return result
       
       # -----------------------------------------------------------------------------
       # _form_master_re()
       #
       # This function takes a list of all of the regex components and attempts to
       # form the master regular expression.  Given limitations in the Python re
       # module, it may be necessary to break the master regex into separate expressions.
       # -----------------------------------------------------------------------------
    1: def _form_master_re(relist, reflags, ldict, toknames):
           if not relist:
               return []
           regex = '|'.join(relist)
           try:
               lexre = re.compile(regex, reflags)
       
               # Build the index to function map for the matching engine
               lexindexfunc = [None] * (max(lexre.groupindex.values()) + 1)
               lexindexnames = lexindexfunc[:]
       
               for f, i in lexre.groupindex.items():
                   handle = ldict.get(f, None)
                   if type(handle) in (types.FunctionType, types.MethodType):
                       lexindexfunc[i] = (handle, toknames[f])
                       lexindexnames[i] = f
                   elif handle is not None:
                       lexindexnames[i] = f
                       if f.find('ignore_') > 0:
                           lexindexfunc[i] = (None, None)
                       else:
                           lexindexfunc[i] = (None, toknames[f])
       
               return [(lexre, lexindexfunc)], [regex], [lexindexnames]
           except Exception:
               m = int(len(relist)/2)
               if m == 0:
                   m = 1
               llist, lre, lnames = _form_master_re(relist[:m], reflags, ldict, toknames)
               rlist, rre, rnames = _form_master_re(relist[m:], reflags, ldict, toknames)
               return (llist+rlist), (lre+rre), (lnames+rnames)
       
       # -----------------------------------------------------------------------------
       # def _statetoken(s,names)
       #
       # Given a declaration name s of the form "t_" and a dictionary whose keys are
       # state names, this function returns a tuple (states,tokenname) where states
       # is a tuple of state names and tokenname is the name of the token.  For example,
       # calling this with s = "t_foo_bar_SPAM" might return (('foo','bar'),'SPAM')
       # -----------------------------------------------------------------------------
    1: def _statetoken(s, names):
   76:     nonstate = 1
   76:     parts = s.split('_')
   87:     for i, part in enumerate(parts[1:], 1):
   87:         if part not in names and part != 'ANY':
   76:             break
       
   76:     if i > 1:
   11:         states = tuple(parts[1:i])
           else:
   65:         states = ('INITIAL',)
       
   76:     if 'ANY' in states:
               states = tuple(names)
       
   76:     tokenname = '_'.join(parts[i:])
   76:     return (states, tokenname)
       
       
       # -----------------------------------------------------------------------------
       # LexerReflect()
       #
       # This class represents information needed to build a lexer as extracted from a
       # user's input file.
       # -----------------------------------------------------------------------------
    2: class LexerReflect(object):
    1:     def __init__(self, ldict, log=None, reflags=0):
    1:         self.ldict      = ldict
    1:         self.error_func = None
    1:         self.tokens     = []
    1:         self.reflags    = reflags
    1:         self.stateinfo  = {'INITIAL': 'inclusive'}
    1:         self.modules    = set()
    1:         self.error      = False
    1:         self.log        = PlyLogger(sys.stderr) if log is None else log
       
           # Get all of the basic information
    1:     def get_all(self):
    1:         self.get_tokens()
    1:         self.get_literals()
    1:         self.get_states()
    1:         self.get_rules()
       
           # Validate all of the information
    1:     def validate_all(self):
               self.validate_tokens()
               self.validate_literals()
               self.validate_rules()
               return self.error
       
           # Get the tokens map
    1:     def get_tokens(self):
    1:         tokens = self.ldict.get('tokens', None)
    1:         if not tokens:
                   self.log.error('No token list is defined')
                   self.error = True
                   return
       
    1:         if not isinstance(tokens, (list, tuple)):
                   self.log.error('tokens must be a list or tuple')
                   self.error = True
                   return
       
    1:         if not tokens:
                   self.log.error('tokens is empty')
                   self.error = True
                   return
       
    1:         self.tokens = tokens
       
           # Validate the tokens
    1:     def validate_tokens(self):
               terminals = {}
               for n in self.tokens:
                   if not _is_identifier.match(n):
                       self.log.error("Bad token name '%s'", n)
                       self.error = True
                   if n in terminals:
                       self.log.warning("Token '%s' multiply defined", n)
                   terminals[n] = 1
       
           # Get the literals specifier
    1:     def get_literals(self):
    1:         self.literals = self.ldict.get('literals', '')
    1:         if not self.literals:
    1:             self.literals = ''
       
           # Validate literals
    1:     def validate_literals(self):
               try:
                   for c in self.literals:
                       if not isinstance(c, StringTypes) or len(c) > 1:
                           self.log.error('Invalid literal %s. Must be a single character', repr(c))
                           self.error = True
       
               except TypeError:
                   self.log.error('Invalid literals specification. literals must be a sequence of characters')
                   self.error = True
       
    1:     def get_states(self):
    1:         self.states = self.ldict.get('states', None)
               # Build statemap
    1:         if self.states:
    1:             if not isinstance(self.states, (tuple, list)):
                       self.log.error('states must be defined as a tuple or list')
                       self.error = True
                   else:
    3:                 for s in self.states:
    2:                     if not isinstance(s, tuple) or len(s) != 2:
                               self.log.error("Invalid state specifier %s. Must be a tuple (statename,'exclusive|inclusive')", repr(s))
                               self.error = True
                               continue
    2:                     name, statetype = s
    2:                     if not isinstance(name, StringTypes):
                               self.log.error('State name %s must be a string', repr(name))
                               self.error = True
                               continue
    2:                     if not (statetype == 'inclusive' or statetype == 'exclusive'):
                               self.log.error("State type for state %s must be 'inclusive' or 'exclusive'", name)
                               self.error = True
                               continue
    2:                     if name in self.stateinfo:
                               self.log.error("State '%s' already defined", name)
                               self.error = True
                               continue
    2:                     self.stateinfo[name] = statetype
       
           # Get all of the symbols with a t_ prefix and sort them into various
           # categories (functions, strings, error functions, and ignore characters)
       
    1:     def get_rules(self):
  156:         tsymbols = [f for f in self.ldict if f[:2] == 't_']
       
               # Now build up a list of functions and a list of strings
    1:         self.toknames = {}        # Mapping of symbols to token names
    1:         self.funcsym  = {}        # Symbols defined as functions
    1:         self.strsym   = {}        # Symbols defined as strings
    1:         self.ignore   = {}        # Ignore strings by state
    1:         self.errorf   = {}        # Error functions by state
    1:         self.eoff     = {}        # EOF functions by state
       
    4:         for s in self.stateinfo:
    3:             self.funcsym[s] = []
    3:             self.strsym[s] = []
       
    1:         if len(tsymbols) == 0:
                   self.log.error('No rules of the form t_rulename are defined')
                   self.error = True
                   return
       
   77:         for f in tsymbols:
   76:             t = self.ldict[f]
   76:             states, tokname = _statetoken(f, self.stateinfo)
   76:             self.toknames[f] = tokname
       
   76:             if hasattr(t, '__call__'):
   28:                 if tokname == 'error':
    6:                     for s in states:
    3:                         self.errorf[s] = t
   25:                 elif tokname == 'eof':
                           for s in states:
                               self.eoff[s] = t
   25:                 elif tokname == 'ignore':
                           line = t.__code__.co_firstlineno
                           file = t.__code__.co_filename
                           self.log.error("%s:%d: Rule '%s' must be defined as a string", file, line, t.__name__)
                           self.error = True
                       else:
   50:                     for s in states:
   25:                         self.funcsym[s].append((f, t))
   48:             elif isinstance(t, StringTypes):
   48:                 if tokname == 'ignore':
    6:                     for s in states:
    3:                         self.ignore[s] = t
    3:                     if '\\' in t:
                               self.log.warning("%s contains a literal backslash '\\'", f)
       
   45:                 elif tokname == 'error':
                           self.log.error("Rule '%s' must be defined as a function", f)
                           self.error = True
                       else:
   90:                     for s in states:
   45:                         self.strsym[s].append((f, t))
                   else:
                       self.log.error('%s not defined as a function or string', f)
                       self.error = True
       
               # Sort the functions by line number
    4:         for f in self.funcsym.values():
   28:             f.sort(key=lambda x: x[1].__code__.co_firstlineno)
       
               # Sort the strings by regular expression length
    4:         for s in self.strsym.values():
   48:             s.sort(key=lambda x: len(x[1]), reverse=True)
       
           # Validate all of the t_rules collected
    1:     def validate_rules(self):
               for state in self.stateinfo:
                   # Validate all rules defined by functions
       
                   for fname, f in self.funcsym[state]:
                       line = f.__code__.co_firstlineno
                       file = f.__code__.co_filename
                       module = inspect.getmodule(f)
                       self.modules.add(module)
       
                       tokname = self.toknames[fname]
                       if isinstance(f, types.MethodType):
                           reqargs = 2
                       else:
                           reqargs = 1
                       nargs = f.__code__.co_argcount
                       if nargs > reqargs:
                           self.log.error("%s:%d: Rule '%s' has too many arguments", file, line, f.__name__)
                           self.error = True
                           continue
       
                       if nargs < reqargs:
                           self.log.error("%s:%d: Rule '%s' requires an argument", file, line, f.__name__)
                           self.error = True
                           continue
       
                       if not _get_regex(f):
                           self.log.error("%s:%d: No regular expression defined for rule '%s'", file, line, f.__name__)
                           self.error = True
                           continue
       
                       try:
                           c = re.compile('(?P<%s>%s)' % (fname, _get_regex(f)), self.reflags)
                           if c.match(''):
                               self.log.error("%s:%d: Regular expression for rule '%s' matches empty string", file, line, f.__name__)
                               self.error = True
                       except re.error as e:
                           self.log.error("%s:%d: Invalid regular expression for rule '%s'. %s", file, line, f.__name__, e)
                           if '#' in _get_regex(f):
                               self.log.error("%s:%d. Make sure '#' in rule '%s' is escaped with '\\#'", file, line, f.__name__)
                           self.error = True
       
                   # Validate all rules defined by strings
                   for name, r in self.strsym[state]:
                       tokname = self.toknames[name]
                       if tokname == 'error':
                           self.log.error("Rule '%s' must be defined as a function", name)
                           self.error = True
                           continue
       
                       if tokname not in self.tokens and tokname.find('ignore_') < 0:
                           self.log.error("Rule '%s' defined for an unspecified token %s", name, tokname)
                           self.error = True
                           continue
       
                       try:
                           c = re.compile('(?P<%s>%s)' % (name, r), self.reflags)
                           if (c.match('')):
                               self.log.error("Regular expression for rule '%s' matches empty string", name)
                               self.error = True
                       except re.error as e:
                           self.log.error("Invalid regular expression for rule '%s'. %s", name, e)
                           if '#' in r:
                               self.log.error("Make sure '#' in rule '%s' is escaped with '\\#'", name)
                           self.error = True
       
                   if not self.funcsym[state] and not self.strsym[state]:
                       self.log.error("No rules defined for state '%s'", state)
                       self.error = True
       
                   # Validate the error function
                   efunc = self.errorf.get(state, None)
                   if efunc:
                       f = efunc
                       line = f.__code__.co_firstlineno
                       file = f.__code__.co_filename
                       module = inspect.getmodule(f)
                       self.modules.add(module)
       
                       if isinstance(f, types.MethodType):
                           reqargs = 2
                       else:
                           reqargs = 1
                       nargs = f.__code__.co_argcount
                       if nargs > reqargs:
                           self.log.error("%s:%d: Rule '%s' has too many arguments", file, line, f.__name__)
                           self.error = True
       
                       if nargs < reqargs:
                           self.log.error("%s:%d: Rule '%s' requires an argument", file, line, f.__name__)
                           self.error = True
       
               for module in self.modules:
                   self.validate_module(module)
       
           # -----------------------------------------------------------------------------
           # validate_module()
           #
           # This checks to see if there are duplicated t_rulename() functions or strings
           # in the parser input file.  This is done using a simple regular expression
           # match on each line in the source code of the given module.
           # -----------------------------------------------------------------------------
       
    1:     def validate_module(self, module):
               try:
                   lines, linen = inspect.getsourcelines(module)
               except IOError:
                   return
       
               fre = re.compile(r'\s*def\s+(t_[a-zA-Z_0-9]*)\(')
               sre = re.compile(r'\s*(t_[a-zA-Z_0-9]*)\s*=')
       
               counthash = {}
               linen += 1
               for line in lines:
                   m = fre.match(line)
                   if not m:
                       m = sre.match(line)
                   if m:
                       name = m.group(1)
                       prev = counthash.get(name)
                       if not prev:
                           counthash[name] = linen
                       else:
                           filename = inspect.getsourcefile(module)
                           self.log.error('%s:%d: Rule %s redefined. Previously defined on line %d', filename, linen, name, prev)
                           self.error = True
                   linen += 1
       
       # -----------------------------------------------------------------------------
       # lex(module)
       #
       # Build all of the regular expression rules from definitions in the supplied module
       # -----------------------------------------------------------------------------
    1: def lex(module=None, object=None, debug=False, optimize=False, lextab='lextab',
    1:         reflags=int(re.VERBOSE), nowarn=False, outputdir=None, debuglog=None, errorlog=None):
       
    1:     if lextab is None:
               lextab = 'lextab'
       
           global lexer
       
    1:     ldict = None
    1:     stateinfo  = {'INITIAL': 'inclusive'}
    1:     lexobj = Lexer()
    1:     lexobj.lexoptimize = optimize
           global token, input
       
    1:     if errorlog is None:
    1:         errorlog = PlyLogger(sys.stderr)
       
    1:     if debug:
               if debuglog is None:
                   debuglog = PlyLogger(sys.stderr)
       
           # Get the module dictionary used for the lexer
    1:     if object:
    1:         module = object
       
           # Get the module dictionary used for the parser
    1:     if module:
  155:         _items = [(k, getattr(module, k)) for k in dir(module)]
    1:         ldict = dict(_items)
               # If no __file__ attribute is available, try to obtain it from the __module__ instead
    1:         if '__file__' not in ldict:
    1:             ldict['__file__'] = sys.modules[ldict['__module__']].__file__
           else:
               ldict = get_caller_module_dict(2)
       
           # Determine if the module is package of a package or not.
           # If so, fix the tabmodule setting so that tables load correctly
    1:     pkg = ldict.get('__package__')
    1:     if pkg and isinstance(lextab, str):
               if '.' not in lextab:
                   lextab = pkg + '.' + lextab
       
           # Collect parser information from the dictionary
    1:     linfo = LexerReflect(ldict, log=errorlog, reflags=reflags)
    1:     linfo.get_all()
    1:     if not optimize:
               if linfo.validate_all():
                   raise SyntaxError("Can't build lexer")
       
    1:     if optimize and lextab:
    1:         try:
    1:             lexobj.readtab(lextab, ldict)
    1:             token = lexobj.token
    1:             input = lexobj.input
    1:             lexer = lexobj
    1:             return lexobj
       
               except ImportError:
                   pass
       
           # Dump some basic debugging information
           if debug:
               debuglog.info('lex: tokens   = %r', linfo.tokens)
               debuglog.info('lex: literals = %r', linfo.literals)
               debuglog.info('lex: states   = %r', linfo.stateinfo)
       
           # Build a dictionary of valid token names
           lexobj.lextokens = set()
           for n in linfo.tokens:
               lexobj.lextokens.add(n)
       
           # Get literals specification
           if isinstance(linfo.literals, (list, tuple)):
               lexobj.lexliterals = type(linfo.literals[0])().join(linfo.literals)
           else:
               lexobj.lexliterals = linfo.literals
       
           lexobj.lextokens_all = lexobj.lextokens | set(lexobj.lexliterals)
       
           # Get the stateinfo dictionary
           stateinfo = linfo.stateinfo
       
           regexs = {}
           # Build the master regular expressions
           for state in stateinfo:
               regex_list = []
       
               # Add rules defined by functions first
               for fname, f in linfo.funcsym[state]:
                   line = f.__code__.co_firstlineno
                   file = f.__code__.co_filename
                   regex_list.append('(?P<%s>%s)' % (fname, _get_regex(f)))
                   if debug:
                       debuglog.info("lex: Adding rule %s -> '%s' (state '%s')", fname, _get_regex(f), state)
       
               # Now add all of the simple rules
               for name, r in linfo.strsym[state]:
                   regex_list.append('(?P<%s>%s)' % (name, r))
                   if debug:
                       debuglog.info("lex: Adding rule %s -> '%s' (state '%s')", name, r, state)
       
               regexs[state] = regex_list
       
           # Build the master regular expressions
       
           if debug:
               debuglog.info('lex: ==== MASTER REGEXS FOLLOW ====')
       
           for state in regexs:
               lexre, re_text, re_names = _form_master_re(regexs[state], reflags, ldict, linfo.toknames)
               lexobj.lexstatere[state] = lexre
               lexobj.lexstateretext[state] = re_text
               lexobj.lexstaterenames[state] = re_names
               if debug:
                   for i, text in enumerate(re_text):
                       debuglog.info("lex: state '%s' : regex[%d] = '%s'", state, i, text)
       
           # For inclusive states, we need to add the regular expressions from the INITIAL state
           for state, stype in stateinfo.items():
               if state != 'INITIAL' and stype == 'inclusive':
                   lexobj.lexstatere[state].extend(lexobj.lexstatere['INITIAL'])
                   lexobj.lexstateretext[state].extend(lexobj.lexstateretext['INITIAL'])
                   lexobj.lexstaterenames[state].extend(lexobj.lexstaterenames['INITIAL'])
       
           lexobj.lexstateinfo = stateinfo
           lexobj.lexre = lexobj.lexstatere['INITIAL']
           lexobj.lexretext = lexobj.lexstateretext['INITIAL']
           lexobj.lexreflags = reflags
       
           # Set up ignore variables
           lexobj.lexstateignore = linfo.ignore
           lexobj.lexignore = lexobj.lexstateignore.get('INITIAL', '')
       
           # Set up error functions
           lexobj.lexstateerrorf = linfo.errorf
           lexobj.lexerrorf = linfo.errorf.get('INITIAL', None)
           if not lexobj.lexerrorf:
               errorlog.warning('No t_error rule is defined')
       
           # Set up eof functions
           lexobj.lexstateeoff = linfo.eoff
           lexobj.lexeoff = linfo.eoff.get('INITIAL', None)
       
           # Check state information for ignore and error rules
           for s, stype in stateinfo.items():
               if stype == 'exclusive':
                   if s not in linfo.errorf:
                       errorlog.warning("No error rule is defined for exclusive state '%s'", s)
                   if s not in linfo.ignore and lexobj.lexignore:
                       errorlog.warning("No ignore rule is defined for exclusive state '%s'", s)
               elif stype == 'inclusive':
                   if s not in linfo.errorf:
                       linfo.errorf[s] = linfo.errorf.get('INITIAL', None)
                   if s not in linfo.ignore:
                       linfo.ignore[s] = linfo.ignore.get('INITIAL', '')
       
           # Create global versions of the token() and input() functions
           token = lexobj.token
           input = lexobj.input
           lexer = lexobj
       
           # If in optimize mode, we write the lextab
           if lextab and optimize:
               if outputdir is None:
                   # If no output directory is set, the location of the output files
                   # is determined according to the following rules:
                   #     - If lextab specifies a package, files go into that package directory
                   #     - Otherwise, files go in the same directory as the specifying module
                   if isinstance(lextab, types.ModuleType):
                       srcfile = lextab.__file__
                   else:
                       if '.' not in lextab:
                           srcfile = ldict['__file__']
                       else:
                           parts = lextab.split('.')
                           pkgname = '.'.join(parts[:-1])
                           exec('import %s' % pkgname)
                           srcfile = getattr(sys.modules[pkgname], '__file__', '')
                   outputdir = os.path.dirname(srcfile)
               try:
                   lexobj.writetab(lextab, outputdir)
               except IOError as e:
                   errorlog.warning("Couldn't write lextab module %r. %s" % (lextab, e))
       
           return lexobj
       
       # -----------------------------------------------------------------------------
       # runmain()
       #
       # This runs the lexer as a main program
       # -----------------------------------------------------------------------------
       
    1: def runmain(lexer=None, data=None):
           if not data:
               try:
                   filename = sys.argv[1]
                   f = open(filename)
                   data = f.read()
                   f.close()
               except IndexError:
                   sys.stdout.write('Reading from standard input (type EOF to end):\n')
                   data = sys.stdin.read()
       
           if lexer:
               _input = lexer.input
           else:
               _input = input
           _input(data)
           if lexer:
               _token = lexer.token
           else:
               _token = token
       
           while True:
               tok = _token()
               if not tok:
                   break
               sys.stdout.write('(%s,%r,%d,%d)\n' % (tok.type, tok.value, tok.lineno, tok.lexpos))
       
       # -----------------------------------------------------------------------------
       # @TOKEN(regex)
       #
       # This decorator function can be used to set the regex expression on a function
       # when its docstring might need to be set in an alternative way
       # -----------------------------------------------------------------------------
       
    1: def TOKEN(r):
   18:     def set_regex(f):
   18:         if hasattr(r, '__call__'):
                   f.regex = _get_regex(r)
               else:
   18:             f.regex = r
   18:         return f
   18:     return set_regex
       
       # Alternative spelling of the TOKEN decorator
    1: Token = TOKEN
