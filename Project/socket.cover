       # Wrapper module for _socket, providing some additional facilities
       # implemented in Python.
       
       """\
       This module provides socket operations and some related functions.
       On Unix, it supports IP (Internet Protocol) and Unix domain sockets.
       On other systems, it only supports IP. Functions specific for a
       socket are available as methods of the socket object.
       
       Functions:
       
       socket() -- create a new socket object
       socketpair() -- create a pair of new socket objects [*]
       fromfd() -- create a socket object from an open file descriptor [*]
       fromshare() -- create a socket object from data received from socket.share() [*]
       gethostname() -- return the current hostname
       gethostbyname() -- map a hostname to its IP number
       gethostbyaddr() -- map an IP number or hostname to DNS info
       getservbyname() -- map a service name and a protocol name to a port number
       getprotobyname() -- map a protocol name (e.g. 'tcp') to a number
       ntohs(), ntohl() -- convert 16, 32 bit int from network to host byte order
       htons(), htonl() -- convert 16, 32 bit int from host to network byte order
       inet_aton() -- convert IP addr string (123.45.67.89) to 32-bit packed format
       inet_ntoa() -- convert 32-bit packed format IP to string (123.45.67.89)
       socket.getdefaulttimeout() -- get the default timeout value
       socket.setdefaulttimeout() -- set the default timeout value
       create_connection() -- connects to an address, with an optional timeout and
                              optional source address.
       
        [*] not available on all platforms!
       
       Special objects:
       
       SocketType -- type object for socket objects
       error -- exception raised for I/O errors
       has_ipv6 -- boolean value indicating if IPv6 is supported
       
       IntEnum constants:
       
       AF_INET, AF_UNIX -- socket domains (first argument to socket() call)
       SOCK_STREAM, SOCK_DGRAM, SOCK_RAW -- socket types (second argument)
       
       Integer constants:
       
       Many other constants may be defined; these may be used in calls to
       the setsockopt() and getsockopt() methods.
    1: """
       
    1: import _socket
    1: from _socket import *
       
    1: import os, sys, io, selectors
    1: from enum import IntEnum, IntFlag
       
    1: try:
    1:     import errno
       except ImportError:
           errno = None
    1: EBADF = getattr(errno, 'EBADF', 9)
    1: EAGAIN = getattr(errno, 'EAGAIN', 11)
    1: EWOULDBLOCK = getattr(errno, 'EWOULDBLOCK', 11)
       
    1: __all__ = ["fromfd", "getfqdn", "create_connection",
    1:         "AddressFamily", "SocketKind"]
    1: __all__.extend(os._get_exports_list(_socket))
       
       # Set up the socket.AF_* socket.SOCK_* constants as members of IntEnums for
       # nicer string representations.
       # Note that _socket only knows about the integer values. The public interface
       # in this module understands the enums and translates them back from integers
       # where needed (e.g. .family property of a socket object).
       
    1: IntEnum._convert(
    1:         'AddressFamily',
    1:         __name__,
  218:         lambda C: C.isupper() and C.startswith('AF_'))
       
    1: IntEnum._convert(
    1:         'SocketKind',
    1:         __name__,
  219:         lambda C: C.isupper() and C.startswith('SOCK_'))
       
    1: IntFlag._convert(
    1:         'MsgFlag',
    1:         __name__,
  220:         lambda C: C.isupper() and C.startswith('MSG_'))
       
    1: IntFlag._convert(
    1:         'AddressInfo',
    1:         __name__,
  221:         lambda C: C.isupper() and C.startswith('AI_'))
       
    1: _LOCALHOST    = '127.0.0.1'
    1: _LOCALHOST_V6 = '::1'
       
       
    1: def _intenum_converter(value, enum_klass):
           """Convert a numeric family value to an IntEnum member.
       
           If it's not a known member, return the numeric value itself.
           """
    9:     try:
    9:         return enum_klass(value)
           except ValueError:
               return value
       
    1: _realsocket = socket
       
       # WSA error codes
    1: if sys.platform.lower().startswith("win"):
           errorTab = {}
           errorTab[10004] = "The operation was interrupted."
           errorTab[10009] = "A bad file handle was passed."
           errorTab[10013] = "Permission denied."
           errorTab[10014] = "A fault occurred on the network??" # WSAEFAULT
           errorTab[10022] = "An invalid operation was attempted."
           errorTab[10035] = "The socket operation would block"
           errorTab[10036] = "A blocking operation is already in progress."
           errorTab[10048] = "The network address is in use."
           errorTab[10054] = "The connection has been reset."
           errorTab[10058] = "The network has been shut down."
           errorTab[10060] = "The operation timed out."
           errorTab[10061] = "Connection refused."
           errorTab[10063] = "The name is too long."
           errorTab[10064] = "The host is down."
           errorTab[10065] = "The host is unreachable."
           __all__.append("errorTab")
       
       
    2: class _GiveupOnSendfile(Exception): pass
       
       
    2: class socket(_socket.socket):
       
    1:     """A subclass of _socket.socket adding the makefile() method."""
       
    1:     __slots__ = ["__weakref__", "_io_refs", "_closed"]
       
    1:     def __init__(self, family=-1, type=-1, proto=-1, fileno=None):
               # For user code address family and type values are IntEnum members, but
               # for the underlying _socket.socket they're just integers. The
               # constructor of _socket.socket converts the given argument to an
               # integer automatically.
    4:         if fileno is None:
    3:             if family == -1:
                       family = AF_INET
    3:             if type == -1:
    1:                 type = SOCK_STREAM
    3:             if proto == -1:
    2:                 proto = 0
    4:         _socket.socket.__init__(self, family, type, proto, fileno)
    4:         self._io_refs = 0
    4:         self._closed = False
       
    1:     def __enter__(self):
               return self
       
    1:     def __exit__(self, *args):
               if not self._closed:
                   self.close()
       
    1:     def __repr__(self):
               """Wrap __repr__() to reveal the real class name and socket
               address(es).
               """
    1:         closed = getattr(self, '_closed', False)
    1:         s = "<%s.%s%s fd=%i, family=%s, type=%s, proto=%i" \
    1:             % (self.__class__.__module__,
    1:                self.__class__.__qualname__,
    1:                " [closed]" if closed else "",
    1:                self.fileno(),
    1:                self.family,
    1:                self.type,
    1:                self.proto)
    1:         if not closed:
    1:             try:
    1:                 laddr = self.getsockname()
    1:                 if laddr:
    1:                     s += ", laddr=%s" % str(laddr)
                   except error:
                       pass
    1:             try:
    1:                 raddr = self.getpeername()
                       if raddr:
                           s += ", raddr=%s" % str(raddr)
    1:             except error:
    1:                 pass
    1:         s += '>'
    1:         return s
       
    1:     def __getstate__(self):
               raise TypeError("Cannot serialize socket object")
       
    1:     def dup(self):
               """dup() -> socket object
       
               Duplicate the socket. Return a new socket object connected to the same
               system resource. The new socket is non-inheritable.
               """
               fd = dup(self.fileno())
               sock = self.__class__(self.family, self.type, self.proto, fileno=fd)
               sock.settimeout(self.gettimeout())
               return sock
       
    1:     def accept(self):
               """accept() -> (socket object, address info)
       
               Wait for an incoming connection.  Return a new socket
               representing the connection, and the address of the client.
               For IP sockets, the address info is a pair (hostaddr, port).
               """
               fd, addr = self._accept()
               sock = socket(self.family, self.type, self.proto, fileno=fd)
               # Issue #7995: if no default timeout is set and the listening
               # socket had a (non-zero) timeout, force the new socket in blocking
               # mode to override platform-specific socket flags inheritance.
               if getdefaulttimeout() is None and self.gettimeout():
                   sock.setblocking(True)
               return sock, addr
       
    1:     def makefile(self, mode="r", buffering=None, *,
    1:                  encoding=None, errors=None, newline=None):
               """makefile(...) -> an I/O stream connected to the socket
       
               The arguments are as for io.open() after the filename, except the only
               supported mode values are 'r' (default), 'w' and 'b'.
               """
               # XXX refactor to share code?
    1:         if not set(mode) <= {"r", "w", "b"}:
                   raise ValueError("invalid mode %r (only r, w, b allowed)" % (mode,))
    1:         writing = "w" in mode
    1:         reading = "r" in mode or not writing
    1:         assert reading or writing
    1:         binary = "b" in mode
    1:         rawmode = ""
    1:         if reading:
    1:             rawmode += "r"
    1:         if writing:
                   rawmode += "w"
    1:         raw = SocketIO(self, rawmode)
    1:         self._io_refs += 1
    1:         if buffering is None:
    1:             buffering = -1
    1:         if buffering < 0:
    1:             buffering = io.DEFAULT_BUFFER_SIZE
    1:         if buffering == 0:
                   if not binary:
                       raise ValueError("unbuffered streams must be binary")
                   return raw
    1:         if reading and writing:
                   buffer = io.BufferedRWPair(raw, raw, buffering)
    1:         elif reading:
    1:             buffer = io.BufferedReader(raw, buffering)
               else:
                   assert writing
                   buffer = io.BufferedWriter(raw, buffering)
    1:         if binary:
    1:             return buffer
               text = io.TextIOWrapper(buffer, encoding, errors, newline)
               text.mode = mode
               return text
       
    1:     if hasattr(os, 'sendfile'):
       
    1:         def _sendfile_use_sendfile(self, file, offset=0, count=None):
                   self._check_sendfile_params(file, offset, count)
                   sockno = self.fileno()
                   try:
                       fileno = file.fileno()
                   except (AttributeError, io.UnsupportedOperation) as err:
                       raise _GiveupOnSendfile(err)  # not a regular file
                   try:
                       fsize = os.fstat(fileno).st_size
                   except OSError as err:
                       raise _GiveupOnSendfile(err)  # not a regular file
                   if not fsize:
                       return 0  # empty file
                   blocksize = fsize if not count else count
       
                   timeout = self.gettimeout()
                   if timeout == 0:
                       raise ValueError("non-blocking sockets are not supported")
                   # poll/select have the advantage of not requiring any
                   # extra file descriptor, contrarily to epoll/kqueue
                   # (also, they require a single syscall).
                   if hasattr(selectors, 'PollSelector'):
                       selector = selectors.PollSelector()
                   else:
                       selector = selectors.SelectSelector()
                   selector.register(sockno, selectors.EVENT_WRITE)
       
                   total_sent = 0
                   # localize variable access to minimize overhead
                   selector_select = selector.select
                   os_sendfile = os.sendfile
                   try:
                       while True:
                           if timeout and not selector_select(timeout):
                               raise _socket.timeout('timed out')
                           if count:
                               blocksize = count - total_sent
                               if blocksize <= 0:
                                   break
                           try:
                               sent = os_sendfile(sockno, fileno, offset, blocksize)
                           except BlockingIOError:
                               if not timeout:
                                   # Block until the socket is ready to send some
                                   # data; avoids hogging CPU resources.
                                   selector_select()
                               continue
                           except OSError as err:
                               if total_sent == 0:
                                   # We can get here for different reasons, the main
                                   # one being 'file' is not a regular mmap(2)-like
                                   # file, in which case we'll fall back on using
                                   # plain send().
                                   raise _GiveupOnSendfile(err)
                               raise err from None
                           else:
                               if sent == 0:
                                   break  # EOF
                               offset += sent
                               total_sent += sent
                       return total_sent
                   finally:
                       if total_sent > 0 and hasattr(file, 'seek'):
                           file.seek(offset)
           else:
               def _sendfile_use_sendfile(self, file, offset=0, count=None):
                   raise _GiveupOnSendfile(
                       "os.sendfile() not available on this platform")
       
    1:     def _sendfile_use_send(self, file, offset=0, count=None):
               self._check_sendfile_params(file, offset, count)
               if self.gettimeout() == 0:
                   raise ValueError("non-blocking sockets are not supported")
               if offset:
                   file.seek(offset)
               blocksize = min(count, 8192) if count else 8192
               total_sent = 0
               # localize variable access to minimize overhead
               file_read = file.read
               sock_send = self.send
               try:
                   while True:
                       if count:
                           blocksize = min(count - total_sent, blocksize)
                           if blocksize <= 0:
                               break
                       data = memoryview(file_read(blocksize))
                       if not data:
                           break  # EOF
                       while True:
                           try:
                               sent = sock_send(data)
                           except BlockingIOError:
                               continue
                           else:
                               total_sent += sent
                               if sent < len(data):
                                   data = data[sent:]
                               else:
                                   break
                   return total_sent
               finally:
                   if total_sent > 0 and hasattr(file, 'seek'):
                       file.seek(offset + total_sent)
       
    1:     def _check_sendfile_params(self, file, offset, count):
               if 'b' not in getattr(file, 'mode', 'b'):
                   raise ValueError("file should be opened in binary mode")
               if not self.type & SOCK_STREAM:
                   raise ValueError("only SOCK_STREAM type sockets are supported")
               if count is not None:
                   if not isinstance(count, int):
                       raise TypeError(
                           "count must be a positive integer (got {!r})".format(count))
                   if count <= 0:
                       raise ValueError(
                           "count must be a positive integer (got {!r})".format(count))
       
    1:     def sendfile(self, file, offset=0, count=None):
               """sendfile(file[, offset[, count]]) -> sent
       
               Send a file until EOF is reached by using high-performance
               os.sendfile() and return the total number of bytes which
               were sent.
               *file* must be a regular file object opened in binary mode.
               If os.sendfile() is not available (e.g. Windows) or file is
               not a regular file socket.send() will be used instead.
               *offset* tells from where to start reading the file.
               If specified, *count* is the total number of bytes to transmit
               as opposed to sending the file until EOF is reached.
               File position is updated on return or also in case of error in
               which case file.tell() can be used to figure out the number of
               bytes which were sent.
               The socket must be of SOCK_STREAM type.
               Non-blocking sockets are not supported.
               """
               try:
                   return self._sendfile_use_sendfile(file, offset, count)
               except _GiveupOnSendfile:
                   return self._sendfile_use_send(file, offset, count)
       
    1:     def _decref_socketios(self):
    1:         if self._io_refs > 0:
    1:             self._io_refs -= 1
    1:         if self._closed:
                   self.close()
       
    1:     def _real_close(self, _ss=_socket.socket):
               # This function should not reference any globals. See issue #808164.
    1:         _ss.close(self)
       
    1:     def close(self):
               # This function should not reference any globals. See issue #808164.
    1:         self._closed = True
    1:         if self._io_refs <= 0:
    1:             self._real_close()
       
    1:     def detach(self):
               """detach() -> file descriptor
       
               Close the socket object without closing the underlying file descriptor.
               The object cannot be used after this call, but the file descriptor
               can be reused for other purposes.  The file descriptor is returned.
               """
    1:         self._closed = True
    1:         return super().detach()
       
    1:     @property
           def family(self):
               """Read-only access to the address family for this socket.
               """
    3:         return _intenum_converter(super().family, AddressFamily)
       
    1:     @property
           def type(self):
               """Read-only access to the socket type.
               """
    2:         return _intenum_converter(super().type, SocketKind)
       
    1:     if os.name == 'nt':
               def get_inheritable(self):
                   return os.get_handle_inheritable(self.fileno())
               def set_inheritable(self, inheritable):
                   os.set_handle_inheritable(self.fileno(), inheritable)
           else:
    1:         def get_inheritable(self):
                   return os.get_inheritable(self.fileno())
    1:         def set_inheritable(self, inheritable):
    1:             os.set_inheritable(self.fileno(), inheritable)
    1:     get_inheritable.__doc__ = "Get the inheritable flag of the socket"
    1:     set_inheritable.__doc__ = "Set the inheritable flag of the socket"
       
    1: def fromfd(fd, family, type, proto=0):
           """ fromfd(fd, family, type[, proto]) -> socket object
       
           Create a socket object from a duplicate of the given file
           descriptor.  The remaining arguments are the same as for socket().
           """
           nfd = dup(fd)
           return socket(family, type, proto, nfd)
       
    1: if hasattr(_socket.socket, "share"):
           def fromshare(info):
               """ fromshare(info) -> socket object
       
               Create a socket object from the bytes object returned by
               socket.share(pid).
               """
               return socket(0, 0, 0, info)
           __all__.append("fromshare")
       
    1: if hasattr(_socket, "socketpair"):
       
    1:     def socketpair(family=None, type=SOCK_STREAM, proto=0):
               """socketpair([family[, type[, proto]]]) -> (socket object, socket object)
       
               Create a pair of socket objects from the sockets returned by the platform
               socketpair() function.
               The arguments are the same as for socket() except the default family is
               AF_UNIX if defined on the platform; otherwise, the default is AF_INET.
               """
               if family is None:
                   try:
                       family = AF_UNIX
                   except NameError:
                       family = AF_INET
               a, b = _socket.socketpair(family, type, proto)
               a = socket(family, type, proto, a.detach())
               b = socket(family, type, proto, b.detach())
               return a, b
       
       else:
       
           # Origin: https://gist.github.com/4325783, by Geert Jansen.  Public domain.
           def socketpair(family=AF_INET, type=SOCK_STREAM, proto=0):
               if family == AF_INET:
                   host = _LOCALHOST
               elif family == AF_INET6:
                   host = _LOCALHOST_V6
               else:
                   raise ValueError("Only AF_INET and AF_INET6 socket address families "
                                    "are supported")
               if type != SOCK_STREAM:
                   raise ValueError("Only SOCK_STREAM socket type is supported")
               if proto != 0:
                   raise ValueError("Only protocol zero is supported")
       
               # We create a connected TCP socket. Note the trick with
               # setblocking(False) that prevents us from having to create a thread.
               lsock = socket(family, type, proto)
               try:
                   lsock.bind((host, 0))
                   lsock.listen()
                   # On IPv6, ignore flow_info and scope_id
                   addr, port = lsock.getsockname()[:2]
                   csock = socket(family, type, proto)
                   try:
                       csock.setblocking(False)
                       try:
                           csock.connect((addr, port))
                       except (BlockingIOError, InterruptedError):
                           pass
                       csock.setblocking(True)
                       ssock, _ = lsock.accept()
                   except:
                       csock.close()
                       raise
               finally:
                   lsock.close()
               return (ssock, csock)
           __all__.append("socketpair")
       
       socketpair.__doc__ = """socketpair([family[, type[, proto]]]) -> (socket object, socket object)
       Create a pair of socket objects from the sockets returned by the platform
       socketpair() function.
       The arguments are the same as for socket() except the default family is AF_UNIX
       if defined on the platform; otherwise, the default is AF_INET.
    1: """
       
    1: _blocking_errnos = { EAGAIN, EWOULDBLOCK }
       
    2: class SocketIO(io.RawIOBase):
       
           """Raw I/O implementation for stream sockets.
       
           This class supports the makefile() method on sockets.  It provides
           the raw I/O interface on top of a socket object.
    1:     """
       
           # One might wonder why not let FileIO do the job instead.  There are two
           # main reasons why FileIO is not adapted:
           # - it wouldn't work under Windows (where you can't used read() and
           #   write() on a socket handle)
           # - it wouldn't work with socket timeouts (FileIO would ignore the
           #   timeout and consider the socket non-blocking)
       
           # XXX More docs
       
    1:     def __init__(self, sock, mode):
    1:         if mode not in ("r", "w", "rw", "rb", "wb", "rwb"):
                   raise ValueError("invalid mode: %r" % mode)
    1:         io.RawIOBase.__init__(self)
    1:         self._sock = sock
    1:         if "b" not in mode:
    1:             mode += "b"
    1:         self._mode = mode
    1:         self._reading = "r" in mode
    1:         self._writing = "w" in mode
    1:         self._timeout_occurred = False
       
    1:     def readinto(self, b):
               """Read up to len(b) bytes into the writable buffer *b* and return
               the number of bytes read.  If the socket is non-blocking and no bytes
               are available, None is returned.
       
               If *b* is non-empty, a 0 return value indicates that the connection
               was shutdown at the other end.
               """
    2:         self._checkClosed()
    2:         self._checkReadable()
    2:         if self._timeout_occurred:
                   raise OSError("cannot read from timed out object")
    2:         while True:
    2:             try:
    2:                 return self._sock.recv_into(b)
                   except timeout:
                       self._timeout_occurred = True
                       raise
                   except error as e:
                       if e.args[0] in _blocking_errnos:
                           return None
                       raise
       
    1:     def write(self, b):
               """Write the given bytes or bytearray object *b* to the socket
               and return the number of bytes written.  This can be less than
               len(b) if not all data could be written.  If the socket is
               non-blocking and no bytes could be written None is returned.
               """
               self._checkClosed()
               self._checkWritable()
               try:
                   return self._sock.send(b)
               except error as e:
                   # XXX what about EINTR?
                   if e.args[0] in _blocking_errnos:
                       return None
                   raise
       
    1:     def readable(self):
               """True if the SocketIO is open for reading.
               """
    3:         if self.closed:
                   raise ValueError("I/O operation on closed socket.")
    3:         return self._reading
       
    1:     def writable(self):
               """True if the SocketIO is open for writing.
               """
               if self.closed:
                   raise ValueError("I/O operation on closed socket.")
               return self._writing
       
    1:     def seekable(self):
               """True if the SocketIO is open for seeking.
               """
               if self.closed:
                   raise ValueError("I/O operation on closed socket.")
               return super().seekable()
       
    1:     def fileno(self):
               """Return the file descriptor of the underlying socket.
               """
               self._checkClosed()
               return self._sock.fileno()
       
    1:     @property
           def name(self):
               if not self.closed:
                   return self.fileno()
               else:
                   return -1
       
    1:     @property
           def mode(self):
               return self._mode
       
    1:     def close(self):
               """Close the SocketIO object.  This doesn't close the underlying
               socket, except if all references to it have disappeared.
               """
    1:         if self.closed:
                   return
    1:         io.RawIOBase.close(self)
    1:         self._sock._decref_socketios()
    1:         self._sock = None
       
       
    1: def getfqdn(name=''):
           """Get fully qualified domain name from name.
       
           An empty argument is interpreted as meaning the local host.
       
           First the hostname returned by gethostbyaddr() is checked, then
           possibly existing aliases. In case no FQDN is available, hostname
           from gethostname() is returned.
           """
           name = name.strip()
           if not name or name == '0.0.0.0':
               name = gethostname()
           try:
               hostname, aliases, ipaddrs = gethostbyaddr(name)
           except error:
               pass
           else:
               aliases.insert(0, hostname)
               for name in aliases:
                   if '.' in name:
                       break
               else:
                   name = hostname
           return name
       
       
    1: _GLOBAL_DEFAULT_TIMEOUT = object()
       
    1: def create_connection(address, timeout=_GLOBAL_DEFAULT_TIMEOUT,
    1:                       source_address=None):
           """Connect to *address* and return the socket object.
       
           Convenience function.  Connect to *address* (a 2-tuple ``(host,
           port)``) and return the socket object.  Passing the optional
           *timeout* parameter will set the timeout on the socket instance
           before attempting to connect.  If no *timeout* is supplied, the
           global default timeout setting returned by :func:`getdefaulttimeout`
           is used.  If *source_address* is set it must be a tuple of (host, port)
           for the socket to bind as a source address before making the connection.
           A host of '' or port 0 tells the OS to use the default.
           """
       
           host, port = address
           err = None
           for res in getaddrinfo(host, port, 0, SOCK_STREAM):
               af, socktype, proto, canonname, sa = res
               sock = None
               try:
                   sock = socket(af, socktype, proto)
                   if timeout is not _GLOBAL_DEFAULT_TIMEOUT:
                       sock.settimeout(timeout)
                   if source_address:
                       sock.bind(source_address)
                   sock.connect(sa)
                   # Break explicitly a reference cycle
                   err = None
                   return sock
       
               except error as _:
                   err = _
                   if sock is not None:
                       sock.close()
       
           if err is not None:
               try:
                   raise err
               finally:
                   # Break explicitly a reference cycle
                   err = None
           else:
               raise error("getaddrinfo returns an empty list")
       
    1: def getaddrinfo(host, port, family=0, type=0, proto=0, flags=0):
           """Resolve host and port into list of address info entries.
       
           Translate the host/port argument into a sequence of 5-tuples that contain
           all the necessary arguments for creating a socket connected to that service.
           host is a domain name, a string representation of an IPv4/v6 address or
           None. port is a string service name such as 'http', a numeric port number or
           None. By passing None as the value of host and port, you can pass NULL to
           the underlying C API.
       
           The family, type and proto arguments can be optionally specified in order to
           narrow the list of addresses returned. Passing zero as a value for each of
           these arguments selects the full range of results.
           """
           # We override this function since we want to translate the numeric family
           # and socket type values to enum constants.
    2:     addrlist = []
    4:     for res in _socket.getaddrinfo(host, port, family, type, proto, flags):
    2:         af, socktype, proto, canonname, sa = res
    2:         addrlist.append((_intenum_converter(af, AddressFamily),
    2:                          _intenum_converter(socktype, SocketKind),
    2:                          proto, canonname, sa))
    2:     return addrlist
