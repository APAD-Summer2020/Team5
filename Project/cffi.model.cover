    1: import types
    1: import weakref
       
    1: from .lock import allocate_lock
    1: from .error import CDefError, VerificationError, VerificationMissing
       
       # type qualifiers
    1: Q_CONST    = 0x01
    1: Q_RESTRICT = 0x02
    1: Q_VOLATILE = 0x04
       
    1: def qualify(quals, replace_with):
  247:     if quals & Q_CONST:
  113:         replace_with = ' const ' + replace_with.lstrip()
  247:     if quals & Q_VOLATILE:
               replace_with = ' volatile ' + replace_with.lstrip()
  247:     if quals & Q_RESTRICT:
               # It seems that __restrict is supported by gcc and msvc.
               # If you hit some different compiler, add a #define in
               # _cffi_include.h for it (and in its copies, documented there)
               replace_with = ' __restrict ' + replace_with.lstrip()
  247:     return replace_with
       
       
    2: class BaseTypeByIdentity(object):
    1:     is_array_type = False
    1:     is_raw_function = False
       
    1:     def get_c_name(self, replace_with='', context='a C file', quals=0):
               result = self.c_name_with_marker
               assert result.count('&') == 1
               # some logic duplication with ffi.getctype()... :-(
               replace_with = replace_with.strip()
               if replace_with:
                   if replace_with.startswith('*') and '&[' in result:
                       replace_with = '(%s)' % replace_with
                   elif not replace_with[0] in '[(':
                       replace_with = ' ' + replace_with
               replace_with = qualify(quals, replace_with)
               result = result.replace('&', replace_with)
               if '$' in result:
                   raise VerificationError(
                       "cannot generate '%s' in %s: unknown type name"
                       % (self._get_c_name(), context))
               return result
       
    1:     def _get_c_name(self):
  588:         return self.c_name_with_marker.replace('&', '')
       
    1:     def has_c_name(self):
               return '$' not in self._get_c_name()
       
    1:     def is_integer_type(self):
               return False
       
    1:     def get_cached_btype(self, ffi, finishlist, can_delay=False):
  105:         try:
  105:             BType = ffi._cached_btypes[self]
   35:         except KeyError:
   35:             BType = self.build_backend_type(ffi, finishlist)
   35:             BType2 = ffi._cached_btypes.setdefault(self, BType)
   35:             assert BType2 is BType
  105:         return BType
       
    1:     def __repr__(self):
               return '<%s>' % (self._get_c_name(),)
       
    1:     def _get_items(self):
 2962:         return [(name, getattr(self, name)) for name in self._attrs_]
       
       
    2: class BaseType(BaseTypeByIdentity):
       
    1:     def __eq__(self, other):
  133:         return (self.__class__ == other.__class__ and
  114:                 self._get_items() == other._get_items())
       
    1:     def __ne__(self, other):
               return not self == other
       
    1:     def __hash__(self):
  526:         return hash((self.__class__, tuple(self._get_items())))
       
       
    2: class VoidType(BaseType):
    1:     _attrs_ = ()
       
    1:     def __init__(self):
    1:         self.c_name_with_marker = 'void&'
       
    1:     def build_backend_type(self, ffi, finishlist):
    1:         return global_cache(self, ffi, 'new_void_type')
       
    1: void_type = VoidType()
       
       
    2: class BasePrimitiveType(BaseType):
    1:     def is_complex_type(self):
               return False
       
       
    2: class PrimitiveType(BasePrimitiveType):
    1:     _attrs_ = ('name',)
       
           ALL_PRIMITIVE_TYPES = {
    1:         'char':               'c',
    1:         'short':              'i',
    1:         'int':                'i',
    1:         'long':               'i',
    1:         'long long':          'i',
    1:         'signed char':        'i',
    1:         'unsigned char':      'i',
    1:         'unsigned short':     'i',
    1:         'unsigned int':       'i',
    1:         'unsigned long':      'i',
    1:         'unsigned long long': 'i',
    1:         'float':              'f',
    1:         'double':             'f',
    1:         'long double':        'f',
    1:         'float _Complex':     'j',
    1:         'double _Complex':    'j',
    1:         '_Bool':              'i',
               # the following types are not primitive in the C sense
    1:         'wchar_t':            'c',
    1:         'char16_t':           'c',
    1:         'char32_t':           'c',
    1:         'int8_t':             'i',
    1:         'uint8_t':            'i',
    1:         'int16_t':            'i',
    1:         'uint16_t':           'i',
    1:         'int32_t':            'i',
    1:         'uint32_t':           'i',
    1:         'int64_t':            'i',
    1:         'uint64_t':           'i',
    1:         'int_least8_t':       'i',
    1:         'uint_least8_t':      'i',
    1:         'int_least16_t':      'i',
    1:         'uint_least16_t':     'i',
    1:         'int_least32_t':      'i',
    1:         'uint_least32_t':     'i',
    1:         'int_least64_t':      'i',
    1:         'uint_least64_t':     'i',
    1:         'int_fast8_t':        'i',
    1:         'uint_fast8_t':       'i',
    1:         'int_fast16_t':       'i',
    1:         'uint_fast16_t':      'i',
    1:         'int_fast32_t':       'i',
    1:         'uint_fast32_t':      'i',
    1:         'int_fast64_t':       'i',
    1:         'uint_fast64_t':      'i',
    1:         'intptr_t':           'i',
    1:         'uintptr_t':          'i',
    1:         'intmax_t':           'i',
    1:         'uintmax_t':          'i',
    1:         'ptrdiff_t':          'i',
    1:         'size_t':             'i',
    1:         'ssize_t':            'i',
               }
       
    1:     def __init__(self, name):
    8:         assert name in self.ALL_PRIMITIVE_TYPES
    8:         self.name = name
    8:         self.c_name_with_marker = name + '&'
       
    1:     def is_char_type(self):
               return self.ALL_PRIMITIVE_TYPES[self.name] == 'c'
    1:     def is_integer_type(self):
               return self.ALL_PRIMITIVE_TYPES[self.name] == 'i'
    1:     def is_float_type(self):
               return self.ALL_PRIMITIVE_TYPES[self.name] == 'f'
    1:     def is_complex_type(self):
               return self.ALL_PRIMITIVE_TYPES[self.name] == 'j'
       
    1:     def build_backend_type(self, ffi, finishlist):
    5:         return global_cache(self, ffi, 'new_primitive_type', self.name)
       
       
    2: class UnknownIntegerType(BasePrimitiveType):
    1:     _attrs_ = ('name',)
       
    1:     def __init__(self, name):
               self.name = name
               self.c_name_with_marker = name + '&'
       
    1:     def is_integer_type(self):
               return True
       
    1:     def build_backend_type(self, ffi, finishlist):
               raise NotImplementedError("integer type '%s' can only be used after "
                                         "compilation" % self.name)
       
    2: class UnknownFloatType(BasePrimitiveType):
    1:     _attrs_ = ('name', )
       
    1:     def __init__(self, name):
               self.name = name
               self.c_name_with_marker = name + '&'
       
    1:     def build_backend_type(self, ffi, finishlist):
               raise NotImplementedError("float type '%s' can only be used after "
                                         "compilation" % self.name)
       
       
    2: class BaseFunctionType(BaseType):
    1:     _attrs_ = ('args', 'result', 'ellipsis', 'abi')
       
    1:     def __init__(self, args, result, ellipsis, abi=None):
  206:         self.args = args
  206:         self.result = result
  206:         self.ellipsis = ellipsis
  206:         self.abi = abi
               #
 1000:         reprargs = [arg._get_c_name() for arg in self.args]
  206:         if self.ellipsis:
    4:             reprargs.append('...')
  206:         reprargs = reprargs or ['void']
  206:         replace_with = self._base_pattern % (', '.join(reprargs),)
  206:         if abi is not None:
                   replace_with = replace_with[:1] + abi + ' ' + replace_with[1:]
               self.c_name_with_marker = (
  206:             self.result.c_name_with_marker.replace('&', replace_with))
       
       
    2: class RawFunctionType(BaseFunctionType):
           # Corresponds to a C type like 'int(int)', which is the C type of
           # a function, but not a pointer-to-function.  The backend has no
           # notion of such a type; it's used temporarily by parsing.
    1:     _base_pattern = '(&)(%s)'
    1:     is_raw_function = True
       
    1:     def build_backend_type(self, ffi, finishlist):
               raise CDefError("cannot render the type %r: it is a function "
                               "type, not a pointer-to-function type" % (self,))
       
    1:     def as_function_pointer(self):
  103:         return FunctionPtrType(self.args, self.result, self.ellipsis, self.abi)
       
       
    2: class FunctionPtrType(BaseFunctionType):
    1:     _base_pattern = '(*&)(%s)'
       
    1:     def build_backend_type(self, ffi, finishlist):
   18:         result = self.result.get_cached_btype(ffi, finishlist)
   18:         args = []
   69:         for tp in self.args:
   51:             args.append(tp.get_cached_btype(ffi, finishlist))
   18:         abi_args = ()
   18:         if self.abi == "__stdcall":
                   if not self.ellipsis:    # __stdcall ignored for variadic funcs
                       try:
                           abi_args = (ffi._backend.FFI_STDCALL,)
                       except AttributeError:
                           pass
   18:         return global_cache(self, ffi, 'new_function_type',
   18:                             tuple(args), result, self.ellipsis, *abi_args)
       
    1:     def as_raw_function(self):
               return RawFunctionType(self.args, self.result, self.ellipsis, self.abi)
       
       
    2: class PointerType(BaseType):
    1:     _attrs_ = ('totype', 'quals')
       
    1:     def __init__(self, totype, quals=0):
  247:         self.totype = totype
  247:         self.quals = quals
  247:         extra = qualify(quals, " *&")
  247:         if totype.is_array_type:
                   extra = "(%s)" % (extra.lstrip(),)
  247:         self.c_name_with_marker = totype.c_name_with_marker.replace('&', extra)
       
    1:     def build_backend_type(self, ffi, finishlist):
    8:         BItem = self.totype.get_cached_btype(ffi, finishlist, can_delay=True)
    8:         return global_cache(self, ffi, 'new_pointer_type', BItem)
       
    1: voidp_type = PointerType(void_type)
       
    1: def ConstPointerType(totype):
    1:     return PointerType(totype, Q_CONST)
       
    1: const_voidp_type = ConstPointerType(void_type)
       
       
    2: class NamedPointerType(PointerType):
    1:     _attrs_ = ('totype', 'name')
       
    1:     def __init__(self, totype, name, quals=0):
               PointerType.__init__(self, totype, quals)
               self.name = name
               self.c_name_with_marker = name + '&'
       
       
    2: class ArrayType(BaseType):
    1:     _attrs_ = ('item', 'length')
    1:     is_array_type = True
       
    1:     def __init__(self, item, length):
   18:         self.item = item
   18:         self.length = length
               #
   18:         if length is None:
   11:             brackets = '&[]'
    7:         elif length == '...':
                   brackets = '&[/*...*/]'
               else:
    7:             brackets = '&[%s]' % length
               self.c_name_with_marker = (
   18:             self.item.c_name_with_marker.replace('&', brackets))
       
    1:     def resolve_length(self, newlength):
               return ArrayType(self.item, newlength)
       
    1:     def build_backend_type(self, ffi, finishlist):
    2:         if self.length == '...':
                   raise CDefError("cannot render the type %r: unknown length" %
                                   (self,))
    2:         self.item.get_cached_btype(ffi, finishlist)   # force the item BType
    2:         BPtrItem = PointerType(self.item).get_cached_btype(ffi, finishlist)
    2:         return global_cache(self, ffi, 'new_array_type', BPtrItem, self.length)
       
    1: char_array_type = ArrayType(PrimitiveType('char'), None)
       
       
    2: class StructOrUnionOrEnum(BaseTypeByIdentity):
    1:     _attrs_ = ('name',)
    1:     forcename = None
       
    1:     def build_c_name_with_marker(self):
    4:         name = self.forcename or '%s %s' % (self.kind, self.name)
    4:         self.c_name_with_marker = name + '&'
       
    1:     def force_the_name(self, forcename):
    2:         self.forcename = forcename
    2:         self.build_c_name_with_marker()
       
    1:     def get_official_name(self):
    1:         assert self.c_name_with_marker.endswith('&')
    1:         return self.c_name_with_marker[:-1]
       
       
    2: class StructOrUnion(StructOrUnionOrEnum):
    1:     fixedlayout = None
    1:     completed = 0
    1:     partial = False
    1:     packed = 0
       
    1:     def __init__(self, name, fldnames, fldtypes, fldbitsize, fldquals=None):
    2:         self.name = name
    2:         self.fldnames = fldnames
    2:         self.fldtypes = fldtypes
    2:         self.fldbitsize = fldbitsize
    2:         self.fldquals = fldquals
    2:         self.build_c_name_with_marker()
       
    1:     def anonymous_struct_fields(self):
               if self.fldtypes is not None:
                   for name, type in zip(self.fldnames, self.fldtypes):
                       if name == '' and isinstance(type, StructOrUnion):
                           yield type
       
    1:     def enumfields(self, expand_anonymous_struct_union=True):
               fldquals = self.fldquals
               if fldquals is None:
                   fldquals = (0,) * len(self.fldnames)
               for name, type, bitsize, quals in zip(self.fldnames, self.fldtypes,
                                                     self.fldbitsize, fldquals):
                   if (name == '' and isinstance(type, StructOrUnion)
                           and expand_anonymous_struct_union):
                       # nested anonymous struct/union
                       for result in type.enumfields():
                           yield result
                   else:
                       yield (name, type, bitsize, quals)
       
    1:     def force_flatten(self):
               # force the struct or union to have a declaration that lists
               # directly all fields returned by enumfields(), flattening
               # nested anonymous structs/unions.
               names = []
               types = []
               bitsizes = []
               fldquals = []
               for name, type, bitsize, quals in self.enumfields():
                   names.append(name)
                   types.append(type)
                   bitsizes.append(bitsize)
                   fldquals.append(quals)
               self.fldnames = tuple(names)
               self.fldtypes = tuple(types)
               self.fldbitsize = tuple(bitsizes)
               self.fldquals = tuple(fldquals)
       
    1:     def get_cached_btype(self, ffi, finishlist, can_delay=False):
    2:         BType = StructOrUnionOrEnum.get_cached_btype(self, ffi, finishlist,
    2:                                                      can_delay)
    2:         if not can_delay:
                   self.finish_backend_type(ffi, finishlist)
    2:         return BType
       
    1:     def finish_backend_type(self, ffi, finishlist):
    1:         if self.completed:
                   if self.completed != 2:
                       raise NotImplementedError("recursive structure declaration "
                                                 "for '%s'" % (self.name,))
                   return
    1:         BType = ffi._cached_btypes[self]
               #
    1:         self.completed = 1
               #
    1:         if self.fldtypes is None:
                   pass    # not completing it: it's an opaque struct
                   #
    1:         elif self.fixedlayout is None:
    5:             fldtypes = [tp.get_cached_btype(ffi, finishlist)
    4:                         for tp in self.fldtypes]
    1:             lst = list(zip(self.fldnames, fldtypes, self.fldbitsize))
    1:             extra_flags = ()
    1:             if self.packed:
                       if self.packed == 1:
                           extra_flags = (8,)    # SF_PACKED
                       else:
                           extra_flags = (0, self.packed)
    1:             ffi._backend.complete_struct_or_union(BType, lst, self,
    1:                                                   -1, -1, *extra_flags)
                   #
               else:
                   fldtypes = []
                   fieldofs, fieldsize, totalsize, totalalignment = self.fixedlayout
                   for i in range(len(self.fldnames)):
                       fsize = fieldsize[i]
                       ftype = self.fldtypes[i]
                       #
                       if isinstance(ftype, ArrayType) and ftype.length == '...':
                           # fix the length to match the total size
                           BItemType = ftype.item.get_cached_btype(ffi, finishlist)
                           nlen, nrest = divmod(fsize, ffi.sizeof(BItemType))
                           if nrest != 0:
                               self._verification_error(
                                   "field '%s.%s' has a bogus size?" % (
                                   self.name, self.fldnames[i] or '{}'))
                           ftype = ftype.resolve_length(nlen)
                           self.fldtypes = (self.fldtypes[:i] + (ftype,) +
                                            self.fldtypes[i+1:])
                       #
                       BFieldType = ftype.get_cached_btype(ffi, finishlist)
                       if isinstance(ftype, ArrayType) and ftype.length is None:
                           assert fsize == 0
                       else:
                           bitemsize = ffi.sizeof(BFieldType)
                           if bitemsize != fsize:
                               self._verification_error(
                                   "field '%s.%s' is declared as %d bytes, but is "
                                   "really %d bytes" % (self.name,
                                                        self.fldnames[i] or '{}',
                                                        bitemsize, fsize))
                       fldtypes.append(BFieldType)
                   #
                   lst = list(zip(self.fldnames, fldtypes, self.fldbitsize, fieldofs))
                   ffi._backend.complete_struct_or_union(BType, lst, self,
                                                         totalsize, totalalignment)
    1:         self.completed = 2
       
    1:     def _verification_error(self, msg):
               raise VerificationError(msg)
       
    1:     def check_not_partial(self):
    1:         if self.partial and self.fixedlayout is None:
                   raise VerificationMissing(self._get_c_name())
       
    1:     def build_backend_type(self, ffi, finishlist):
    1:         self.check_not_partial()
    1:         finishlist.append(self)
               #
    1:         return global_cache(self, ffi, 'new_%s_type' % self.kind,
    1:                             self.get_official_name(), key=self)
       
       
    2: class StructType(StructOrUnion):
    1:     kind = 'struct'
       
       
    2: class UnionType(StructOrUnion):
    1:     kind = 'union'
       
       
    2: class EnumType(StructOrUnionOrEnum):
    1:     kind = 'enum'
    1:     partial = False
    1:     partial_resolved = False
       
    1:     def __init__(self, name, enumerators, enumvalues, baseinttype=None):
               self.name = name
               self.enumerators = enumerators
               self.enumvalues = enumvalues
               self.baseinttype = baseinttype
               self.build_c_name_with_marker()
       
    1:     def force_the_name(self, forcename):
               StructOrUnionOrEnum.force_the_name(self, forcename)
               if self.forcename is None:
                   name = self.get_official_name()
                   self.forcename = '$' + name.replace(' ', '_')
       
    1:     def check_not_partial(self):
               if self.partial and not self.partial_resolved:
                   raise VerificationMissing(self._get_c_name())
       
    1:     def build_backend_type(self, ffi, finishlist):
               self.check_not_partial()
               base_btype = self.build_baseinttype(ffi, finishlist)
               return global_cache(self, ffi, 'new_enum_type',
                                   self.get_official_name(),
                                   self.enumerators, self.enumvalues,
                                   base_btype, key=self)
       
    1:     def build_baseinttype(self, ffi, finishlist):
               if self.baseinttype is not None:
                   return self.baseinttype.get_cached_btype(ffi, finishlist)
               #
               if self.enumvalues:
                   smallest_value = min(self.enumvalues)
                   largest_value = max(self.enumvalues)
               else:
                   import warnings
                   try:
                       # XXX!  The goal is to ensure that the warnings.warn()
                       # will not suppress the warning.  We want to get it
                       # several times if we reach this point several times.
                       __warningregistry__.clear()
                   except NameError:
                       pass
                   warnings.warn("%r has no values explicitly defined; "
                                 "guessing that it is equivalent to 'unsigned int'"
                                 % self._get_c_name())
                   smallest_value = largest_value = 0
               if smallest_value < 0:   # needs a signed type
                   sign = 1
                   candidate1 = PrimitiveType("int")
                   candidate2 = PrimitiveType("long")
               else:
                   sign = 0
                   candidate1 = PrimitiveType("unsigned int")
                   candidate2 = PrimitiveType("unsigned long")
               btype1 = candidate1.get_cached_btype(ffi, finishlist)
               btype2 = candidate2.get_cached_btype(ffi, finishlist)
               size1 = ffi.sizeof(btype1)
               size2 = ffi.sizeof(btype2)
               if (smallest_value >= ((-1) << (8*size1-1)) and
                   largest_value < (1 << (8*size1-sign))):
                   return btype1
               if (smallest_value >= ((-1) << (8*size2-1)) and
                   largest_value < (1 << (8*size2-sign))):
                   return btype2
               raise CDefError("%s values don't all fit into either 'long' "
                               "or 'unsigned long'" % self._get_c_name())
       
    1: def unknown_type(name, structname=None):
    1:     if structname is None:
               structname = '$%s' % name
    1:     tp = StructType(structname, None, None, None)
    1:     tp.force_the_name(name)
    1:     tp.origin = "unknown_type"
    1:     return tp
       
    1: def unknown_ptr_type(name, structname=None):
           if structname is None:
               structname = '$$%s' % name
           tp = StructType(structname, None, None, None)
           return NamedPointerType(tp, name)
       
       
    1: global_lock = allocate_lock()
    1: _typecache_cffi_backend = weakref.WeakValueDictionary()
       
    1: def get_typecache(backend):
           # returns _typecache_cffi_backend if backend is the _cffi_backend
           # module, or type(backend).__typecache if backend is an instance of
           # CTypesBackend (or some FakeBackend class during tests)
    1:     if isinstance(backend, types.ModuleType):
    1:         return _typecache_cffi_backend
           with global_lock:
               if not hasattr(type(backend), '__typecache'):
                   type(backend).__typecache = weakref.WeakValueDictionary()
               return type(backend).__typecache
       
    1: def global_cache(srctype, ffi, funcname, *args, **kwds):
   35:     key = kwds.pop('key', (funcname, args))
   35:     assert not kwds
   35:     try:
   35:         return ffi._typecache[key]
   32:     except KeyError:
   32:         pass
   32:     try:
   32:         res = getattr(ffi._backend, funcname)(*args)
           except NotImplementedError as e:
               raise NotImplementedError("%s: %r: %s" % (funcname, srctype, e))
           # note that setdefault() on WeakValueDictionary is not atomic
           # and contains a rare bug (http://bugs.python.org/issue19542);
           # we have to use a lock and do it ourselves
   32:     cache = ffi._typecache
   32:     with global_lock:
   32:         res1 = cache.get(key)
   32:         if res1 is None:
   32:             cache[key] = res
   32:             return res
               else:
                   return res1
       
    1: def pointer_cache(ffi, BType):
           return global_cache('?', ffi, 'new_pointer_type', BType)
       
    1: def attach_exception_info(e, name):
           if e.args and type(e.args[0]) is str:
               e.args = ('%s: %s' % (name, e.args[0]),) + e.args[1:]
