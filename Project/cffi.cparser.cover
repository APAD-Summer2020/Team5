    1: from . import model
    1: from .commontypes import COMMON_TYPES, resolve_common_type
    1: from .error import FFIError, CDefError
    1: try:
    1:     from . import _pycparser as pycparser
    1: except ImportError:
    1:     import pycparser
    1: import weakref, re, sys
       
    1: try:
    1:     if sys.version_info < (3,):
               import thread as _thread
           else:
    1:         import _thread
    1:     lock = _thread.allocate_lock()
       except ImportError:
           lock = None
       
    1: def _workaround_for_static_import_finders():
           # Issue #392: packaging tools like cx_Freeze can not find these
           # because pycparser uses exec dynamic import.  This is an obscure
           # workaround.  This function is never called.
           import pycparser.yacctab
           import pycparser.lextab
       
    1: CDEF_SOURCE_STRING = "<cdef source string>"
    1: _r_comment = re.compile(r"/\*.*?\*/|//([^\n\\]|\\.)*?$",
    1:                         re.DOTALL | re.MULTILINE)
    1: _r_define  = re.compile(r"^\s*#\s*define\s+([A-Za-z_][A-Za-z_0-9]*)"
                               r"\b((?:[^\n\\]|\\.)*?)$",
    1:                         re.DOTALL | re.MULTILINE)
    1: _r_partial_enum = re.compile(r"=\s*\.\.\.\s*[,}]|\.\.\.\s*\}")
    1: _r_enum_dotdotdot = re.compile(r"__dotdotdot\d+__$")
    1: _r_partial_array = re.compile(r"\[\s*\.\.\.\s*\]")
    1: _r_words = re.compile(r"\w+|\S")
    1: _parser_cache = None
    1: _r_int_literal = re.compile(r"-?0?x?[0-9a-f]+[lu]*$", re.IGNORECASE)
    1: _r_stdcall1 = re.compile(r"\b(__stdcall|WINAPI)\b")
    1: _r_stdcall2 = re.compile(r"[(]\s*(__stdcall|WINAPI)\b")
    1: _r_cdecl = re.compile(r"\b__cdecl\b")
    1: _r_extern_python = re.compile(r'\bextern\s*"'
                                     r'(Python|Python\s*\+\s*C|C\s*\+\s*Python)"\s*.')
    1: _r_star_const_space = re.compile(       # matches "* const "
    1:     r"[*]\s*((const|volatile|restrict)\b\s*)+")
    1: _r_int_dotdotdot = re.compile(r"(\b(int|long|short|signed|unsigned|char)\s*)+"
                                     r"\.\.\.")
    1: _r_float_dotdotdot = re.compile(r"\b(double|float)\s*\.\.\.")
       
    1: def _get_parser():
           global _parser_cache
   19:     if _parser_cache is None:
    1:         _parser_cache = pycparser.CParser()
   19:     return _parser_cache
       
    1: def _workaround_for_old_pycparser(csource):
           # Workaround for a pycparser issue (fixed between pycparser 2.10 and
           # 2.14): "char*const***" gives us a wrong syntax tree, the same as
           # for "char***(*const)".  This means we can't tell the difference
           # afterwards.  But "char(*const(***))" gives us the right syntax
           # tree.  The issue only occurs if there are several stars in
           # sequence with no parenthesis inbetween, just possibly qualifiers.
           # Attempt to fix it by adding some parentheses in the source: each
           # time we see "* const" or "* const *", we add an opening
           # parenthesis before each star---the hard part is figuring out where
           # to close them.
           parts = []
           while True:
               match = _r_star_const_space.search(csource)
               if not match:
                   break
               #print repr(''.join(parts)+csource), '=>',
               parts.append(csource[:match.start()])
               parts.append('('); closing = ')'
               parts.append(match.group())   # e.g. "* const "
               endpos = match.end()
               if csource.startswith('*', endpos):
                   parts.append('('); closing += ')'
               level = 0
               i = endpos
               while i < len(csource):
                   c = csource[i]
                   if c == '(':
                       level += 1
                   elif c == ')':
                       if level == 0:
                           break
                       level -= 1
                   elif c in ',;=':
                       if level == 0:
                           break
                   i += 1
               csource = csource[endpos:i] + closing + csource[i:]
               #print repr(''.join(parts)+csource)
           parts.append(csource)
           return ''.join(parts)
       
    1: def _preprocess_extern_python(csource):
           # input: `extern "Python" int foo(int);` or
           #        `extern "Python" { int foo(int); }`
           # output:
           #     void __cffi_extern_python_start;
           #     int foo(int);
           #     void __cffi_extern_python_stop;
           #
           # input: `extern "Python+C" int foo(int);`
           # output:
           #     void __cffi_extern_python_plus_c_start;
           #     int foo(int);
           #     void __cffi_extern_python_stop;
   19:     parts = []
   19:     while True:
   19:         match = _r_extern_python.search(csource)
   19:         if not match:
   19:             break
               endpos = match.end() - 1
               #print
               #print ''.join(parts)+csource
               #print '=>'
               parts.append(csource[:match.start()])
               if 'C' in match.group(1):
                   parts.append('void __cffi_extern_python_plus_c_start; ')
               else:
                   parts.append('void __cffi_extern_python_start; ')
               if csource[endpos] == '{':
                   # grouping variant
                   closing = csource.find('}', endpos)
                   if closing < 0:
                       raise CDefError("'extern \"Python\" {': no '}' found")
                   if csource.find('{', endpos + 1, closing) >= 0:
                       raise NotImplementedError("cannot use { } inside a block "
                                                 "'extern \"Python\" { ... }'")
                   parts.append(csource[endpos+1:closing])
                   csource = csource[closing+1:]
               else:
                   # non-grouping variant
                   semicolon = csource.find(';', endpos)
                   if semicolon < 0:
                       raise CDefError("'extern \"Python\": no ';' found")
                   parts.append(csource[endpos:semicolon+1])
                   csource = csource[semicolon+1:]
               parts.append(' void __cffi_extern_python_stop;')
               #print ''.join(parts)+csource
               #print
   19:     parts.append(csource)
   19:     return ''.join(parts)
       
    1: def _warn_for_string_literal(csource):
   19:     if '"' not in csource:
   19:         return
           for line in csource.splitlines():
               if '"' in line and not line.lstrip().startswith('#'):
                   import warnings
                   warnings.warn("String literal found in cdef() or type source. "
                                 "String literals are ignored here, but you should "
                                 "remove them anyway because some character sequences "
                                 "confuse pre-parsing.")
                   break
       
    1: def _warn_for_non_extern_non_static_global_variable(decl):
           if not decl.storage:
               import warnings
               warnings.warn("Global variable '%s' in cdef(): for consistency "
                             "with C it should have a storage class specifier "
                             "(usually 'extern')" % (decl.name,))
       
    1: def _preprocess(csource):
           # Remove comments.  NOTE: this only work because the cdef() section
           # should not contain any string literal!
   19:     csource = _r_comment.sub(' ', csource)
           # Remove the "#define FOO x" lines
   19:     macros = {}
   19:     for match in _r_define.finditer(csource):
               macroname, macrovalue = match.groups()
               macrovalue = macrovalue.replace('\\\n', '').strip()
               macros[macroname] = macrovalue
   19:     csource = _r_define.sub('', csource)
           #
   19:     if pycparser.__version__ < '2.14':
               csource = _workaround_for_old_pycparser(csource)
           #
           # BIG HACK: replace WINAPI or __stdcall with "volatile const".
           # It doesn't make sense for the return type of a function to be
           # "volatile volatile const", so we abuse it to detect __stdcall...
           # Hack number 2 is that "int(volatile *fptr)();" is not valid C
           # syntax, so we place the "volatile" before the opening parenthesis.
   19:     csource = _r_stdcall2.sub(' volatile volatile const(', csource)
   19:     csource = _r_stdcall1.sub(' volatile volatile const ', csource)
   19:     csource = _r_cdecl.sub(' ', csource)
           #
           # Replace `extern "Python"` with start/end markers
   19:     csource = _preprocess_extern_python(csource)
           #
           # Now there should not be any string literal left; warn if we get one
   19:     _warn_for_string_literal(csource)
           #
           # Replace "[...]" with "[__dotdotdotarray__]"
   19:     csource = _r_partial_array.sub('[__dotdotdotarray__]', csource)
           #
           # Replace "...}" with "__dotdotdotNUM__}".  This construction should
           # occur only at the end of enums; at the end of structs we have "...;}"
           # and at the end of vararg functions "...);".  Also replace "=...[,}]"
           # with ",__dotdotdotNUM__[,}]": this occurs in the enums too, when
           # giving an unknown value.
   19:     matches = list(_r_partial_enum.finditer(csource))
   19:     for number, match in enumerate(reversed(matches)):
               p = match.start()
               if csource[p] == '=':
                   p2 = csource.find('...', p, match.end())
                   assert p2 > p
                   csource = '%s,__dotdotdot%d__ %s' % (csource[:p], number,
                                                        csource[p2+3:])
               else:
                   assert csource[p:p+3] == '...'
                   csource = '%s __dotdotdot%d__ %s' % (csource[:p], number,
                                                        csource[p+3:])
           # Replace "int ..." or "unsigned long int..." with "__dotdotdotint__"
   19:     csource = _r_int_dotdotdot.sub(' __dotdotdotint__ ', csource)
           # Replace "float ..." or "double..." with "__dotdotdotfloat__"
   19:     csource = _r_float_dotdotdot.sub(' __dotdotdotfloat__ ', csource)
           # Replace all remaining "..." with the same name, "__dotdotdot__",
           # which is declared with a typedef for the purpose of C parsing.
   19:     return csource.replace('...', ' __dotdotdot__ '), macros
       
    1: def _common_type_names(csource):
           # Look in the source for what looks like usages of types from the
           # list of common types.  A "usage" is approximated here as the
           # appearance of the word, minus a "definition" of the type, which
           # is the last word in a "typedef" statement.  Approximative only
           # but should be fine for all the common types.
   19:     look_for_words = set(COMMON_TYPES)
   19:     look_for_words.add(';')
   19:     look_for_words.add(',')
   19:     look_for_words.add('(')
   19:     look_for_words.add(')')
   19:     look_for_words.add('typedef')
   19:     words_used = set()
   19:     is_typedef = False
   19:     paren = 0
   19:     previous_word = ''
 1657:     for word in _r_words.findall(csource):
 1638:         if word in look_for_words:
  641:             if word == ';':
  112:                 if is_typedef:
    4:                     words_used.discard(previous_word)
    4:                     look_for_words.discard(previous_word)
    4:                     is_typedef = False
  529:             elif word == 'typedef':
    4:                 is_typedef = True
    4:                 paren = 0
  525:             elif word == '(':
  105:                 paren += 1
  420:             elif word == ')':
  105:                 paren -= 1
  315:             elif word == ',':
  194:                 if is_typedef and paren == 0:
                           words_used.discard(previous_word)
                           look_for_words.discard(previous_word)
                   else:   # word in COMMON_TYPES
  121:                 words_used.add(word)
 1638:         previous_word = word
   19:     return words_used
       
       
    2: class Parser(object):
       
    1:     def __init__(self):
    1:         self._declarations = {}
    1:         self._included_declarations = set()
    1:         self._anonymous_counter = 0
    1:         self._structnode2type = weakref.WeakKeyDictionary()
    1:         self._options = {}
    1:         self._int_constants = {}
    1:         self._recomplete = []
    1:         self._uses_new_feature = None
       
    1:     def _parse(self, csource):
   19:         csource, macros = _preprocess(csource)
               # XXX: for more efficiency we would need to poke into the
               # internals of CParser...  the following registers the
               # typedefs, because their presence or absence influences the
               # parsing itself (but what they are typedef'ed to plays no role)
   19:         ctn = _common_type_names(csource)
   19:         typenames = []
  676:         for name in sorted(self._declarations):
  657:             if name.startswith('typedef '):
    4:                 name = name[8:]
    4:                 typenames.append(name)
    4:                 ctn.discard(name)
   19:         typenames += sorted(ctn)
               #
   19:         csourcelines = []
   19:         csourcelines.append('# 1 "<cdef automatic initialization code>"')
   55:         for typename in typenames:
   36:             csourcelines.append('typedef int %s;' % typename)
   19:         csourcelines.append('typedef int __dotdotdotint__, __dotdotdotfloat__,'
                                   ' __dotdotdot__;')
               # this forces pycparser to consider the following in the file
               # called <cdef source string> from line 1
   19:         csourcelines.append('# 1 "%s"' % (CDEF_SOURCE_STRING,))
   19:         csourcelines.append(csource)
   19:         fullcsource = '\n'.join(csourcelines)
   19:         if lock is not None:
   19:             lock.acquire()     # pycparser is not thread-safe...
   19:         try:
   19:             ast = _get_parser().parse(fullcsource)
               except pycparser.c_parser.ParseError as e:
                   self.convert_pycparser_error(e, csource)
               finally:
   19:             if lock is not None:
   19:                 lock.release()
               # csource will be used to find buggy source text
   19:         return ast, macros, csource
       
    1:     def _convert_pycparser_error(self, e, csource):
               # xxx look for "<cdef source string>:NUM:" at the start of str(e)
               # and interpret that as a line number.  This will not work if
               # the user gives explicit ``# NUM "FILE"`` directives.
               line = None
               msg = str(e)
               match = re.match(r"%s:(\d+):" % (CDEF_SOURCE_STRING,), msg)
               if match:
                   linenum = int(match.group(1), 10)
                   csourcelines = csource.splitlines()
                   if 1 <= linenum <= len(csourcelines):
                       line = csourcelines[linenum-1]
               return line
       
    1:     def convert_pycparser_error(self, e, csource):
               line = self._convert_pycparser_error(e, csource)
       
               msg = str(e)
               if line:
                   msg = 'cannot parse "%s"\n%s' % (line.strip(), msg)
               else:
                   msg = 'parse error\n%s' % (msg,)
               raise CDefError(msg)
       
           def parse(self, csource, override=False, packed=False, pack=None,
    1:                     dllexport=False):
   17:         if packed:
                   if packed != True:
                       raise ValueError("'packed' should be False or True; use "
                                        "'pack' to give another value")
                   if pack:
                       raise ValueError("cannot give both 'pack' and 'packed'")
                   pack = 1
   17:         elif pack:
                   if pack & (pack - 1):
                       raise ValueError("'pack' must be a power of two, not %r" %
                           (pack,))
               else:
   17:             pack = 0
   17:         prev_options = self._options
   17:         try:
   17:             self._options = {'override': override,
   17:                              'packed': pack,
   17:                              'dllexport': dllexport}
   17:             self._internal_parse(csource)
               finally:
   17:             self._options = prev_options
       
    1:     def _internal_parse(self, csource):
   17:         ast, macros, csource = self._parse(csource)
               # add the macros
   17:         self._process_macros(macros)
               # find the first "__dotdotdot__" and use that as a separator
               # between the repeated typedefs and the real csource
   17:         iterator = iter(ast.ext)
   82:         for decl in iterator:
   82:             if decl.name == '__dotdotdot__':
   17:                 break
               else:
                   assert 0
   17:         current_decl = None
               #
   17:         try:
   17:             self._inside_extern_python = '__cffi_extern_python_stop'
  124:             for decl in iterator:
  107:                 current_decl = decl
  107:                 if isinstance(decl, pycparser.c_ast.Decl):
  103:                     self._parse_decl(decl)
    4:                 elif isinstance(decl, pycparser.c_ast.Typedef):
    4:                     if not decl.name:
                               raise CDefError("typedef does not declare any name",
                                               decl)
    4:                     quals = 0
    4:                     if (isinstance(decl.type.type, pycparser.c_ast.IdentifierType) and
    2:                             decl.type.type.names[-1].startswith('__dotdotdot')):
                               realtype = self._get_unknown_type(decl)
    4:                     elif (isinstance(decl.type, pycparser.c_ast.PtrDecl) and
                                 isinstance(decl.type.type, pycparser.c_ast.TypeDecl) and
                                 isinstance(decl.type.type.type,
                                            pycparser.c_ast.IdentifierType) and
                                 decl.type.type.type.names[-1].startswith('__dotdotdot')):
                               realtype = self._get_unknown_ptr_type(decl)
                           else:
    4:                         realtype, quals = self._get_type_and_quals(
    4:                             decl.type, name=decl.name, partial_length_ok=True)
    4:                     self._declare('typedef ' + decl.name, realtype, quals=quals)
                       elif decl.__class__.__name__ == 'Pragma':
                           pass    # skip pragma, only in pycparser 2.15
                       else:
                           raise CDefError("unexpected <%s>: this construct is valid "
                                           "C but not valid in cdef()" %
                                           decl.__class__.__name__, decl)
               except CDefError as e:
                   if len(e.args) == 1:
                       e.args = e.args + (current_decl,)
                   raise
               except FFIError as e:
                   msg = self._convert_pycparser_error(e, csource)
                   if msg:
                       e.args = (e.args[0] + "\n    *** Err: %s" % msg,)
                   raise
       
    1:     def _add_constants(self, key, val):
               if key in self._int_constants:
                   if self._int_constants[key] == val:
                       return     # ignore identical double declarations
                   raise FFIError(
                       "multiple declarations of constant: %s" % (key,))
               self._int_constants[key] = val
       
    1:     def _add_integer_constant(self, name, int_str):
               int_str = int_str.lower().rstrip("ul")
               neg = int_str.startswith('-')
               if neg:
                   int_str = int_str[1:]
               # "010" is not valid oct in py3
               if (int_str.startswith("0") and int_str != '0'
                       and not int_str.startswith("0x")):
                   int_str = "0o" + int_str[1:]
               pyvalue = int(int_str, 0)
               if neg:
                   pyvalue = -pyvalue
               self._add_constants(name, pyvalue)
               self._declare('macro ' + name, pyvalue)
       
    1:     def _process_macros(self, macros):
   17:         for key, value in macros.items():
                   value = value.strip()
                   if _r_int_literal.match(value):
                       self._add_integer_constant(key, value)
                   elif value == '...':
                       self._declare('macro ' + key, value)
                   else:
                       raise CDefError(
                           'only supports one of the following syntax:\n'
                           '  #define %s ...     (literally dot-dot-dot)\n'
                           '  #define %s NUMBER  (with NUMBER an integer'
                                           ' constant, decimal/hex/octal)\n'
                           'got:\n'
                           '  #define %s %s'
                           % (key, key, key, value))
       
    1:     def _declare_function(self, tp, quals, decl):
  103:         tp = self._get_type_pointer(tp, quals)
  103:         if self._options.get('dllexport'):
                   tag = 'dllexport_python '
  103:         elif self._inside_extern_python == '__cffi_extern_python_start':
                   tag = 'extern_python '
  103:         elif self._inside_extern_python == '__cffi_extern_python_plus_c_start':
                   tag = 'extern_python_plus_c '
               else:
  103:             tag = 'function '
  103:         self._declare(tag + decl.name, tp)
       
    1:     def _parse_decl(self, decl):
  103:         node = decl.type
  103:         if isinstance(node, pycparser.c_ast.FuncDecl):
  103:             tp, quals = self._get_type_and_quals(node, name=decl.name)
  103:             assert isinstance(tp, model.RawFunctionType)
  103:             self._declare_function(tp, quals, decl)
               else:
                   if isinstance(node, pycparser.c_ast.Struct):
                       self._get_struct_union_enum_type('struct', node)
                   elif isinstance(node, pycparser.c_ast.Union):
                       self._get_struct_union_enum_type('union', node)
                   elif isinstance(node, pycparser.c_ast.Enum):
                       self._get_struct_union_enum_type('enum', node)
                   elif not decl.name:
                       raise CDefError("construct does not declare any variable",
                                       decl)
                   #
                   if decl.name:
                       tp, quals = self._get_type_and_quals(node,
                                                            partial_length_ok=True)
                       if tp.is_raw_function:
                           self._declare_function(tp, quals, decl)
                       elif (tp.is_integer_type() and
                               hasattr(decl, 'init') and
                               hasattr(decl.init, 'value') and
                               _r_int_literal.match(decl.init.value)):
                           self._add_integer_constant(decl.name, decl.init.value)
                       elif (tp.is_integer_type() and
                               isinstance(decl.init, pycparser.c_ast.UnaryOp) and
                               decl.init.op == '-' and
                               hasattr(decl.init.expr, 'value') and
                               _r_int_literal.match(decl.init.expr.value)):
                           self._add_integer_constant(decl.name,
                                                      '-' + decl.init.expr.value)
                       elif (tp is model.void_type and
                             decl.name.startswith('__cffi_extern_python_')):
                           # hack: `extern "Python"` in the C source is replaced
                           # with "void __cffi_extern_python_start;" and
                           # "void __cffi_extern_python_stop;"
                           self._inside_extern_python = decl.name
                       else:
                           if self._inside_extern_python !='__cffi_extern_python_stop':
                               raise CDefError(
                                   "cannot declare constants or "
                                   "variables with 'extern \"Python\"'")
                           if (quals & model.Q_CONST) and not tp.is_array_type:
                               self._declare('constant ' + decl.name, tp, quals=quals)
                           else:
                               _warn_for_non_extern_non_static_global_variable(decl)
                               self._declare('variable ' + decl.name, tp, quals=quals)
       
    1:     def parse_type(self, cdecl):
    2:         return self.parse_type_and_quals(cdecl)[0]
       
    1:     def parse_type_and_quals(self, cdecl):
    2:         ast, macros = self._parse('void __dummy(\n%s\n);' % cdecl)[:2]
    2:         assert not macros
    2:         exprnode = ast.ext[-1].type.args.params[0]
    2:         if isinstance(exprnode, pycparser.c_ast.ID):
                   raise CDefError("unknown identifier '%s'" % (exprnode.name,))
    2:         return self._get_type_and_quals(exprnode.type)
       
    1:     def _declare(self, name, obj, included=False, quals=0):
  108:         if name in self._declarations:
                   prevobj, prevquals = self._declarations[name]
                   if prevobj is obj and prevquals == quals:
                       return
                   if not self._options.get('override'):
                       raise FFIError(
                           "multiple declarations of %s (for interactive usage, "
                           "try cdef(xx, override=True))" % (name,))
  108:         assert '__dotdotdot__' not in name.split()
  108:         self._declarations[name] = (obj, quals)
  108:         if included:
                   self._included_declarations.add(obj)
       
    1:     def _extract_quals(self, type):
  552:         quals = 0
  552:         if isinstance(type, (pycparser.c_ast.TypeDecl,
  552:                              pycparser.c_ast.PtrDecl)):
  552:             if 'const' in type.quals:
  112:                 quals |= model.Q_CONST
  552:             if 'volatile' in type.quals:
                       quals |= model.Q_VOLATILE
  552:             if 'restrict' in type.quals:
                       quals |= model.Q_RESTRICT
  552:         return quals
       
    1:     def _get_type_pointer(self, type, quals, declname=None):
  248:         if isinstance(type, model.RawFunctionType):
  103:             return type.as_function_pointer()
  145:         if (isinstance(type, model.StructOrUnionOrEnum) and
    1:                 type.name.startswith('$') and type.name[1:].isdigit() and
                       type.forcename is None and declname is not None):
                   return model.NamedPointerType(type, declname, quals)
  145:         return model.PointerType(type, quals)
       
    1:     def _get_type_and_quals(self, typenode, name=None, partial_length_ok=False):
               # first, dereference typedefs, if we have it already parsed, we're good
  672:         if (isinstance(typenode, pycparser.c_ast.TypeDecl) and
  407:             isinstance(typenode.type, pycparser.c_ast.IdentifierType) and
  406:             len(typenode.type.names) == 1 and
  405:             ('typedef ' + typenode.type.names[0]) in self._declarations):
  100:             tp, quals = self._declarations['typedef ' + typenode.type.names[0]]
  100:             quals |= self._extract_quals(typenode)
  100:             return tp, quals
               #
  572:         if isinstance(typenode, pycparser.c_ast.ArrayDecl):
                   # array type
   17:             if typenode.dim is None:
   10:                 length = None
                   else:
    7:                 length = self._parse_constant(
    7:                     typenode.dim, partial_length_ok=partial_length_ok)
   17:             tp, quals = self._get_type_and_quals(typenode.type,
   17:                                 partial_length_ok=partial_length_ok)
   17:             return model.ArrayType(tp, length), quals
               #
  555:         if isinstance(typenode, pycparser.c_ast.PtrDecl):
                   # pointer type
  145:             itemtype, itemquals = self._get_type_and_quals(typenode.type)
  145:             tp = self._get_type_pointer(itemtype, itemquals, declname=name)
  145:             quals = self._extract_quals(typenode)
  145:             return tp, quals
               #
  410:         if isinstance(typenode, pycparser.c_ast.TypeDecl):
  307:             quals = self._extract_quals(typenode)
  307:             type = typenode.type
  307:             if isinstance(type, pycparser.c_ast.IdentifierType):
                       # assume a primitive type.  get it from .names, but reduce
                       # synonyms to a single chosen combination
  306:                 names = list(type.names)
  306:                 if names != ['signed', 'char']:    # keep this unmodified
  306:                     prefixes = {}
  310:                     while names:
  307:                         name = names[0]
  307:                         if name in ('short', 'long', 'signed', 'unsigned'):
    4:                             prefixes[name] = prefixes.get(name, 0) + 1
    4:                             del names[0]
                               else:
  303:                             break
                           # ignore the 'signed' prefix below, and reorder the others
  306:                     newnames = []
 1224:                     for prefix in ('unsigned', 'short', 'long'):
  922:                         for i in range(prefixes.get(prefix, 0)):
    4:                             newnames.append(prefix)
  306:                     if not names:
    3:                         names = ['int']    # implicitly
  306:                     if names == ['int']:   # but kill it if 'short' or 'long'
   80:                         if 'short' in prefixes or 'long' in prefixes:
    1:                             names = []
  306:                     names = newnames + names
  306:                 ident = ' '.join(names)
  306:                 if ident == 'void':
  101:                     return model.void_type, quals
  205:                 if ident == '__dotdotdot__':
                           raise FFIError(':%d: bad usage of "..."' %
                                   typenode.coord.line)
  205:                 tp0, quals0 = resolve_common_type(self, ident)
  205:                 return tp0, (quals | quals0)
                   #
    1:             if isinstance(type, pycparser.c_ast.Struct):
                       # 'struct foobar'
    1:                 tp = self._get_struct_union_enum_type('struct', type, name)
    1:                 return tp, quals
                   #
                   if isinstance(type, pycparser.c_ast.Union):
                       # 'union foobar'
                       tp = self._get_struct_union_enum_type('union', type, name)
                       return tp, quals
                   #
                   if isinstance(type, pycparser.c_ast.Enum):
                       # 'enum foobar'
                       tp = self._get_struct_union_enum_type('enum', type, name)
                       return tp, quals
               #
  103:         if isinstance(typenode, pycparser.c_ast.FuncDecl):
                   # a function type
  103:             return self._parse_function_type(typenode, name), 0
               #
               # nested anonymous structs or unions end up here
               if isinstance(typenode, pycparser.c_ast.Struct):
                   return self._get_struct_union_enum_type('struct', typenode, name,
                                                           nested=True), 0
               if isinstance(typenode, pycparser.c_ast.Union):
                   return self._get_struct_union_enum_type('union', typenode, name,
                                                           nested=True), 0
               #
               raise FFIError(":%d: bad or unsupported type declaration" %
                       typenode.coord.line)
       
    1:     def _parse_function_type(self, typenode, funcname=None):
  103:         params = list(getattr(typenode.args, 'params', []))
  400:         for i, arg in enumerate(params):
  297:             if not hasattr(arg, 'type'):
                       raise CDefError("%s arg %d: unknown type '%s'"
                           " (if you meant to use the old C syntax of giving"
                           " untyped arguments, it is not supported)"
                           % (funcname or 'in expression', i + 1,
                              getattr(arg, 'name', '?')))
               ellipsis = (
  103:             len(params) > 0 and
  103:             isinstance(params[-1].type, pycparser.c_ast.TypeDecl) and
   68:             isinstance(params[-1].type.type,
   68:                        pycparser.c_ast.IdentifierType) and
   68:             params[-1].type.type.names == ['__dotdotdot__'])
  103:         if ellipsis:
    2:             params.pop()
    2:             if not params:
                       raise CDefError(
                           "%s: a function with only '(...)' as argument"
                           " is not correct C" % (funcname or 'in expression'))
  501:         args = [self._as_func_arg(*self._get_type_and_quals(argdeclnode.type))
  398:                 for argdeclnode in params]
  103:         if not ellipsis and args == [model.void_type]:
    1:             args = []
  103:         result, quals = self._get_type_and_quals(typenode.type)
               # the 'quals' on the result type are ignored.  HACK: we absure them
               # to detect __stdcall functions: we textually replace "__stdcall"
               # with "volatile volatile const" above.
  103:         abi = None
  103:         if hasattr(typenode.type, 'quals'): # else, probable syntax error anyway
  103:             if typenode.type.quals[-3:] == ['volatile', 'volatile', 'const']:
                       abi = '__stdcall'
  103:         return model.RawFunctionType(tuple(args), result, ellipsis, abi)
       
    1:     def _as_func_arg(self, type, quals):
  295:         if isinstance(type, model.ArrayType):
   98:             return model.PointerType(type.item, quals)
  197:         elif isinstance(type, model.RawFunctionType):
                   return type.as_function_pointer()
               else:
  197:             return type
       
    1:     def _get_struct_union_enum_type(self, kind, type, name=None, nested=False):
               # First, a level of caching on the exact 'type' node of the AST.
               # This is obscure, but needed because pycparser "unrolls" declarations
               # such as "typedef struct { } foo_t, *foo_p" and we end up with
               # an AST that is not a tree, but a DAG, with the "type" node of the
               # two branches foo_t and foo_p of the trees being the same node.
               # It's a bit silly but detecting "DAG-ness" in the AST tree seems
               # to be the only way to distinguish this case from two independent
               # structs.  See test_struct_with_two_usages.
    1:         try:
    1:             return self._structnode2type[type]
    1:         except KeyError:
    1:             pass
               #
               # Note that this must handle parsing "struct foo" any number of
               # times and always return the same StructType object.  Additionally,
               # one of these times (not necessarily the first), the fields of
               # the struct can be specified with "struct foo { ...fields... }".
               # If no name is given, then we have to create a new anonymous struct
               # with no caching; in this case, the fields are either specified
               # right now or never.
               #
    1:         force_name = name
    1:         name = type.name
               #
               # get the type or create it if needed
    1:         if name is None:
                   # 'force_name' is used to guess a more readable name for
                   # anonymous structs, for the common case "typedef struct { } foo".
    1:             if force_name is not None:
    1:                 explicit_name = '$%s' % force_name
                   else:
                       self._anonymous_counter += 1
                       explicit_name = '$%d' % self._anonymous_counter
    1:             tp = None
               else:
                   explicit_name = name
                   key = '%s %s' % (kind, name)
                   tp, _ = self._declarations.get(key, (None, None))
               #
    1:         if tp is None:
    1:             if kind == 'struct':
    1:                 tp = model.StructType(explicit_name, None, None, None)
                   elif kind == 'union':
                       tp = model.UnionType(explicit_name, None, None, None)
                   elif kind == 'enum':
                       if explicit_name == '__dotdotdot__':
                           raise CDefError("Enums cannot be declared with ...")
                       tp = self._build_enum_type(explicit_name, type.values)
                   else:
                       raise AssertionError("kind = %r" % (kind,))
    1:             if name is not None:
                       self._declare(key, tp)
               else:
                   if kind == 'enum' and type.values is not None:
                       raise NotImplementedError(
                           "enum %s: the '{}' declaration should appear on the first "
                           "time the enum is mentioned, not later" % explicit_name)
    1:         if not tp.forcename:
    1:             tp.force_the_name(force_name)
    1:         if tp.forcename and '$' in tp.name:
    1:             self._declare('anonymous %s' % tp.forcename, tp)
               #
    1:         self._structnode2type[type] = tp
               #
               # enums: done here
    1:         if kind == 'enum':
                   return tp
               #
               # is there a 'type.decls'?  If yes, then this is the place in the
               # C sources that declare the fields.  If no, then just return the
               # existing type, possibly still incomplete.
    1:         if type.decls is None:
                   return tp
               #
    1:         if tp.fldnames is not None:
                   raise CDefError("duplicate declaration of struct %s" % name)
    1:         fldnames = []
    1:         fldtypes = []
    1:         fldbitsize = []
    1:         fldquals = []
    4:         for decl in type.decls:
    3:             if (isinstance(decl.type, pycparser.c_ast.IdentifierType) and
                           ''.join(decl.type.names) == '__dotdotdot__'):
                       # XXX pycparser is inconsistent: 'names' should be a list
                       # of strings, but is sometimes just one string.  Use
                       # str.join() as a way to cope with both.
                       self._make_partial(tp, nested)
                       continue
    3:             if decl.bitsize is None:
    3:                 bitsize = -1
                   else:
                       bitsize = self._parse_constant(decl.bitsize)
    3:             self._partial_length = False
    3:             type, fqual = self._get_type_and_quals(decl.type,
    3:                                                    partial_length_ok=True)
    3:             if self._partial_length:
                       self._make_partial(tp, nested)
    3:             if isinstance(type, model.StructType) and type.partial:
                       self._make_partial(tp, nested)
    3:             fldnames.append(decl.name or '')
    3:             fldtypes.append(type)
    3:             fldbitsize.append(bitsize)
    3:             fldquals.append(fqual)
    1:         tp.fldnames = tuple(fldnames)
    1:         tp.fldtypes = tuple(fldtypes)
    1:         tp.fldbitsize = tuple(fldbitsize)
    1:         tp.fldquals = tuple(fldquals)
    1:         if fldbitsize != [-1] * len(fldbitsize):
                   if isinstance(tp, model.StructType) and tp.partial:
                       raise NotImplementedError("%s: using both bitfields and '...;'"
                                                 % (tp,))
    1:         tp.packed = self._options.get('packed')
    1:         if tp.completed:    # must be re-completed: it is not opaque any more
                   tp.completed = 0
                   self._recomplete.append(tp)
    1:         return tp
       
    1:     def _make_partial(self, tp, nested):
               if not isinstance(tp, model.StructOrUnion):
                   raise CDefError("%s cannot be partial" % (tp,))
               if not tp.has_c_name() and not nested:
                   raise NotImplementedError("%s is partial but has no C name" %(tp,))
               tp.partial = True
       
    1:     def _parse_constant(self, exprnode, partial_length_ok=False):
               # for now, limited to expressions that are an immediate number
               # or positive/negative number
    7:         if isinstance(exprnode, pycparser.c_ast.Constant):
    7:             s = exprnode.value
    7:             if '0' <= s[0] <= '9':
    7:                 s = s.rstrip('uUlL')
    7:                 try:
    7:                     if s.startswith('0'):
                               return int(s, 8)
                           else:
    7:                         return int(s, 10)
                       except ValueError:
                           if len(s) > 1:
                               if s.lower()[0:2] == '0x':
                                   return int(s, 16)
                               elif s.lower()[0:2] == '0b':
                                   return int(s, 2)
                       raise CDefError("invalid constant %r" % (s,))
                   elif s[0] == "'" and s[-1] == "'" and (
                           len(s) == 3 or (len(s) == 4 and s[1] == "\\")):
                       return ord(s[-2])
                   else:
                       raise CDefError("invalid constant %r" % (s,))
               #
               if (isinstance(exprnode, pycparser.c_ast.UnaryOp) and
                       exprnode.op == '+'):
                   return self._parse_constant(exprnode.expr)
               #
               if (isinstance(exprnode, pycparser.c_ast.UnaryOp) and
                       exprnode.op == '-'):
                   return -self._parse_constant(exprnode.expr)
               # load previously defined int constant
               if (isinstance(exprnode, pycparser.c_ast.ID) and
                       exprnode.name in self._int_constants):
                   return self._int_constants[exprnode.name]
               #
               if (isinstance(exprnode, pycparser.c_ast.ID) and
                           exprnode.name == '__dotdotdotarray__'):
                   if partial_length_ok:
                       self._partial_length = True
                       return '...'
                   raise FFIError(":%d: unsupported '[...]' here, cannot derive "
                                  "the actual array length in this context"
                                  % exprnode.coord.line)
               #
               if isinstance(exprnode, pycparser.c_ast.BinaryOp):
                   left = self._parse_constant(exprnode.left)
                   right = self._parse_constant(exprnode.right)
                   if exprnode.op == '+':
                       return left + right
                   elif exprnode.op == '-':
                       return left - right
                   elif exprnode.op == '*':
                       return left * right
                   elif exprnode.op == '/':
                       return self._c_div(left, right)
                   elif exprnode.op == '%':
                       return left - self._c_div(left, right) * right
                   elif exprnode.op == '<<':
                       return left << right
                   elif exprnode.op == '>>':
                       return left >> right
                   elif exprnode.op == '&':
                       return left & right
                   elif exprnode.op == '|':
                       return left | right
                   elif exprnode.op == '^':
                       return left ^ right
               #
               raise FFIError(":%d: unsupported expression: expected a "
                              "simple numeric constant" % exprnode.coord.line)
       
    1:     def _c_div(self, a, b):
               result = a // b
               if ((a < 0) ^ (b < 0)) and (a % b) != 0:
                   result += 1
               return result
       
    1:     def _build_enum_type(self, explicit_name, decls):
               if decls is not None:
                   partial = False
                   enumerators = []
                   enumvalues = []
                   nextenumvalue = 0
                   for enum in decls.enumerators:
                       if _r_enum_dotdotdot.match(enum.name):
                           partial = True
                           continue
                       if enum.value is not None:
                           nextenumvalue = self._parse_constant(enum.value)
                       enumerators.append(enum.name)
                       enumvalues.append(nextenumvalue)
                       self._add_constants(enum.name, nextenumvalue)
                       nextenumvalue += 1
                   enumerators = tuple(enumerators)
                   enumvalues = tuple(enumvalues)
                   tp = model.EnumType(explicit_name, enumerators, enumvalues)
                   tp.partial = partial
               else:   # opaque enum
                   tp = model.EnumType(explicit_name, (), ())
               return tp
       
    1:     def include(self, other):
               for name, (tp, quals) in other._declarations.items():
                   if name.startswith('anonymous $enum_$'):
                       continue   # fix for test_anonymous_enum_include
                   kind = name.split(' ', 1)[0]
                   if kind in ('struct', 'union', 'enum', 'anonymous', 'typedef'):
                       self._declare(name, tp, included=True, quals=quals)
               for k, v in other._int_constants.items():
                   self._add_constants(k, v)
       
    1:     def _get_unknown_type(self, decl):
               typenames = decl.type.type.names
               if typenames == ['__dotdotdot__']:
                   return model.unknown_type(decl.name)
       
               if typenames == ['__dotdotdotint__']:
                   if self._uses_new_feature is None:
                       self._uses_new_feature = "'typedef int... %s'" % decl.name
                   return model.UnknownIntegerType(decl.name)
       
               if typenames == ['__dotdotdotfloat__']:
                   # note: not for 'long double' so far
                   if self._uses_new_feature is None:
                       self._uses_new_feature = "'typedef float... %s'" % decl.name
                   return model.UnknownFloatType(decl.name)
       
               raise FFIError(':%d: unsupported usage of "..." in typedef'
                              % decl.coord.line)
       
    1:     def _get_unknown_ptr_type(self, decl):
               if decl.type.type.type.names == ['__dotdotdot__']:
                   return model.unknown_ptr_type(decl.name)
               raise FFIError(':%d: unsupported usage of "..." in typedef'
                              % decl.coord.line)
