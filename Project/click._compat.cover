    1: import re
    1: import io
    1: import os
    1: import sys
    1: import codecs
    1: from weakref import WeakKeyDictionary
       
       
    1: PY2 = sys.version_info[0] == 2
    1: CYGWIN = sys.platform.startswith('cygwin')
       # Determine local App Engine environment, per Google's own suggestion
    1: APP_ENGINE = ('APPENGINE_RUNTIME' in os.environ and
                     'Development/' in os.environ['SERVER_SOFTWARE'])
    1: WIN = sys.platform.startswith('win') and not APP_ENGINE
    1: DEFAULT_COLUMNS = 80
       
       
    1: _ansi_re = re.compile(r'\033\[((?:\d|;)*)([a-zA-Z])')
       
       
    1: def get_filesystem_encoding():
           return sys.getfilesystemencoding() or sys.getdefaultencoding()
       
       
       def _make_text_stream(stream, encoding, errors,
    1:                       force_readable=False, force_writable=False):
           if encoding is None:
               encoding = get_best_encoding(stream)
           if errors is None:
               errors = 'replace'
           return _NonClosingTextIOWrapper(stream, encoding, errors,
                                           line_buffering=True,
                                           force_readable=force_readable,
                                           force_writable=force_writable)
       
       
    1: def is_ascii_encoding(encoding):
           """Checks if a given encoding is ascii."""
    1:     try:
    1:         return codecs.lookup(encoding).name == 'ascii'
           except LookupError:
               return False
       
       
    1: def get_best_encoding(stream):
           """Returns the default stream encoding if not found."""
           rv = getattr(stream, 'encoding', None) or sys.getdefaultencoding()
           if is_ascii_encoding(rv):
               return 'utf-8'
           return rv
       
       
    2: class _NonClosingTextIOWrapper(io.TextIOWrapper):
       
           def __init__(self, stream, encoding, errors,
    1:                  force_readable=False, force_writable=False, **extra):
               self._stream = stream = _FixupStream(stream, force_readable,
                                                    force_writable)
               io.TextIOWrapper.__init__(self, stream, encoding, errors, **extra)
       
           # The io module is a place where the Python 3 text behavior
           # was forced upon Python 2, so we need to unbreak
           # it to look like Python 2.
    1:     if PY2:
               def write(self, x):
                   if isinstance(x, str) or is_bytes(x):
                       try:
                           self.flush()
                       except Exception:
                           pass
                       return self.buffer.write(str(x))
                   return io.TextIOWrapper.write(self, x)
       
               def writelines(self, lines):
                   for line in lines:
                       self.write(line)
       
    1:     def __del__(self):
               try:
                   self.detach()
               except Exception:
                   pass
       
    1:     def isatty(self):
               # https://bitbucket.org/pypy/pypy/issue/1803
               return self._stream.isatty()
       
       
    2: class _FixupStream(object):
           """The new io interface needs more from streams than streams
           traditionally implement.  As such, this fix-up code is necessary in
           some circumstances.
       
           The forcing of readable and writable flags are there because some tools
           put badly patched objects on sys (one such offender are certain version
           of jupyter notebook).
    1:     """
       
    1:     def __init__(self, stream, force_readable=False, force_writable=False):
               self._stream = stream
               self._force_readable = force_readable
               self._force_writable = force_writable
       
    1:     def __getattr__(self, name):
               return getattr(self._stream, name)
       
    1:     def read1(self, size):
               f = getattr(self._stream, 'read1', None)
               if f is not None:
                   return f(size)
               # We only dispatch to readline instead of read in Python 2 as we
               # do not want cause problems with the different implementation
               # of line buffering.
               if PY2:
                   return self._stream.readline(size)
               return self._stream.read(size)
       
    1:     def readable(self):
               if self._force_readable:
                   return True
               x = getattr(self._stream, 'readable', None)
               if x is not None:
                   return x()
               try:
                   self._stream.read(0)
               except Exception:
                   return False
               return True
       
    1:     def writable(self):
               if self._force_writable:
                   return True
               x = getattr(self._stream, 'writable', None)
               if x is not None:
                   return x()
               try:
                   self._stream.write('')
               except Exception:
                   try:
                       self._stream.write(b'')
                   except Exception:
                       return False
               return True
       
    1:     def seekable(self):
               x = getattr(self._stream, 'seekable', None)
               if x is not None:
                   return x()
               try:
                   self._stream.seek(self._stream.tell())
               except Exception:
                   return False
               return True
       
       
    1: if PY2:
           text_type = unicode
           bytes = str
           raw_input = raw_input
           string_types = (str, unicode)
           int_types = (int, long)
           iteritems = lambda x: x.iteritems()
           range_type = xrange
       
           def is_bytes(x):
               return isinstance(x, (buffer, bytearray))
       
           _identifier_re = re.compile(r'^[a-zA-Z_][a-zA-Z0-9_]*$')
       
           # For Windows, we need to force stdout/stdin/stderr to binary if it's
           # fetched for that.  This obviously is not the most correct way to do
           # it as it changes global state.  Unfortunately, there does not seem to
           # be a clear better way to do it as just reopening the file in binary
           # mode does not change anything.
           #
           # An option would be to do what Python 3 does and to open the file as
           # binary only, patch it back to the system, and then use a wrapper
           # stream that converts newlines.  It's not quite clear what's the
           # correct option here.
           #
           # This code also lives in _winconsole for the fallback to the console
           # emulation stream.
           #
           # There are also Windows environments where the `msvcrt` module is not
           # available (which is why we use try-catch instead of the WIN variable
           # here), such as the Google App Engine development server on Windows. In
           # those cases there is just nothing we can do.
           def set_binary_mode(f):
               return f
       
           try:
               import msvcrt
           except ImportError:
               pass
           else:
               def set_binary_mode(f):
                   try:
                       fileno = f.fileno()
                   except Exception:
                       pass
                   else:
                       msvcrt.setmode(fileno, os.O_BINARY)
                   return f
       
           try:
               import fcntl
           except ImportError:
               pass
           else:
               def set_binary_mode(f):
                   try:
                       fileno = f.fileno()
                   except Exception:
                       pass
                   else:
                       flags = fcntl.fcntl(fileno, fcntl.F_GETFL)
                       fcntl.fcntl(fileno, fcntl.F_SETFL, flags & ~os.O_NONBLOCK)
                   return f
       
           def isidentifier(x):
               return _identifier_re.search(x) is not None
       
           def get_binary_stdin():
               return set_binary_mode(sys.stdin)
       
           def get_binary_stdout():
               _wrap_std_stream('stdout')
               return set_binary_mode(sys.stdout)
       
           def get_binary_stderr():
               _wrap_std_stream('stderr')
               return set_binary_mode(sys.stderr)
       
           def get_text_stdin(encoding=None, errors=None):
               rv = _get_windows_console_stream(sys.stdin, encoding, errors)
               if rv is not None:
                   return rv
               return _make_text_stream(sys.stdin, encoding, errors,
                                        force_readable=True)
       
           def get_text_stdout(encoding=None, errors=None):
               _wrap_std_stream('stdout')
               rv = _get_windows_console_stream(sys.stdout, encoding, errors)
               if rv is not None:
                   return rv
               return _make_text_stream(sys.stdout, encoding, errors,
                                        force_writable=True)
       
           def get_text_stderr(encoding=None, errors=None):
               _wrap_std_stream('stderr')
               rv = _get_windows_console_stream(sys.stderr, encoding, errors)
               if rv is not None:
                   return rv
               return _make_text_stream(sys.stderr, encoding, errors,
                                        force_writable=True)
       
           def filename_to_ui(value):
               if isinstance(value, bytes):
                   value = value.decode(get_filesystem_encoding(), 'replace')
               return value
       else:
    1:     import io
    1:     text_type = str
    1:     raw_input = input
    1:     string_types = (str,)
    1:     int_types = (int,)
    1:     range_type = range
   28:     isidentifier = lambda x: x.isidentifier()
    1:     iteritems = lambda x: iter(x.items())
       
    1:     def is_bytes(x):
   10:         return isinstance(x, (bytes, memoryview, bytearray))
       
    1:     def _is_binary_reader(stream, default=False):
               try:
                   return isinstance(stream.read(0), bytes)
               except Exception:
                   return default
                   # This happens in some cases where the stream was already
                   # closed.  In this case, we assume the default.
       
    1:     def _is_binary_writer(stream, default=False):
    1:         try:
    1:             stream.write(b'')
    1:         except Exception:
    1:             try:
    1:                 stream.write('')
    1:                 return False
                   except Exception:
                       pass
                   return default
               return True
       
    1:     def _find_binary_reader(stream):
               # We need to figure out if the given stream is already binary.
               # This can happen because the official docs recommend detaching
               # the streams to get binary streams.  Some code might do this, so
               # we need to deal with this case explicitly.
               if _is_binary_reader(stream, False):
                   return stream
       
               buf = getattr(stream, 'buffer', None)
       
               # Same situation here; this time we assume that the buffer is
               # actually binary in case it's closed.
               if buf is not None and _is_binary_reader(buf, True):
                   return buf
       
    1:     def _find_binary_writer(stream):
               # We need to figure out if the given stream is already binary.
               # This can happen because the official docs recommend detatching
               # the streams to get binary streams.  Some code might do this, so
               # we need to deal with this case explicitly.
               if _is_binary_writer(stream, False):
                   return stream
       
               buf = getattr(stream, 'buffer', None)
       
               # Same situation here; this time we assume that the buffer is
               # actually binary in case it's closed.
               if buf is not None and _is_binary_writer(buf, True):
                   return buf
       
    1:     def _stream_is_misconfigured(stream):
               """A stream is misconfigured if its encoding is ASCII."""
               # If the stream does not have an encoding set, we assume it's set
               # to ASCII.  This appears to happen in certain unittest
               # environments.  It's not quite clear what the correct behavior is
               # but this at least will force Click to recover somehow.
    1:         return is_ascii_encoding(getattr(stream, 'encoding', None) or 'ascii')
       
    1:     def _is_compatible_text_stream(stream, encoding, errors):
               stream_encoding = getattr(stream, 'encoding', None)
               stream_errors = getattr(stream, 'errors', None)
       
               # Perfect match.
               if stream_encoding == encoding and stream_errors == errors:
                   return True
       
               # Otherwise, it's only a compatible stream if we did not ask for
               # an encoding.
               if encoding is None:
                   return stream_encoding is not None
       
               return False
       
           def _force_correct_text_reader(text_reader, encoding, errors,
    1:                                    force_readable=False):
               if _is_binary_reader(text_reader, False):
                   binary_reader = text_reader
               else:
                   # If there is no target encoding set, we need to verify that the
                   # reader is not actually misconfigured.
                   if encoding is None and not _stream_is_misconfigured(text_reader):
                       return text_reader
       
                   if _is_compatible_text_stream(text_reader, encoding, errors):
                       return text_reader
       
                   # If the reader has no encoding, we try to find the underlying
                   # binary reader for it.  If that fails because the environment is
                   # misconfigured, we silently go with the same reader because this
                   # is too common to happen.  In that case, mojibake is better than
                   # exceptions.
                   binary_reader = _find_binary_reader(text_reader)
                   if binary_reader is None:
                       return text_reader
       
               # At this point, we default the errors to replace instead of strict
               # because nobody handles those errors anyways and at this point
               # we're so fundamentally fucked that nothing can repair it.
               if errors is None:
                   errors = 'replace'
               return _make_text_stream(binary_reader, encoding, errors,
                                        force_readable=force_readable)
       
           def _force_correct_text_writer(text_writer, encoding, errors,
    1:                                    force_writable=False):
    1:         if _is_binary_writer(text_writer, False):
                   binary_writer = text_writer
               else:
                   # If there is no target encoding set, we need to verify that the
                   # writer is not actually misconfigured.
    1:             if encoding is None and not _stream_is_misconfigured(text_writer):
    1:                 return text_writer
       
                   if _is_compatible_text_stream(text_writer, encoding, errors):
                       return text_writer
       
                   # If the writer has no encoding, we try to find the underlying
                   # binary writer for it.  If that fails because the environment is
                   # misconfigured, we silently go with the same writer because this
                   # is too common to happen.  In that case, mojibake is better than
                   # exceptions.
                   binary_writer = _find_binary_writer(text_writer)
                   if binary_writer is None:
                       return text_writer
       
               # At this point, we default the errors to replace instead of strict
               # because nobody handles those errors anyways and at this point
               # we're so fundamentally fucked that nothing can repair it.
               if errors is None:
                   errors = 'replace'
               return _make_text_stream(binary_writer, encoding, errors,
                                        force_writable=force_writable)
       
    1:     def get_binary_stdin():
               reader = _find_binary_reader(sys.stdin)
               if reader is None:
                   raise RuntimeError('Was not able to determine binary '
                                      'stream for sys.stdin.')
               return reader
       
    1:     def get_binary_stdout():
               writer = _find_binary_writer(sys.stdout)
               if writer is None:
                   raise RuntimeError('Was not able to determine binary '
                                      'stream for sys.stdout.')
               return writer
       
    1:     def get_binary_stderr():
               writer = _find_binary_writer(sys.stderr)
               if writer is None:
                   raise RuntimeError('Was not able to determine binary '
                                      'stream for sys.stderr.')
               return writer
       
    1:     def get_text_stdin(encoding=None, errors=None):
               rv = _get_windows_console_stream(sys.stdin, encoding, errors)
               if rv is not None:
                   return rv
               return _force_correct_text_reader(sys.stdin, encoding, errors,
                                                 force_readable=True)
       
    1:     def get_text_stdout(encoding=None, errors=None):
    1:         rv = _get_windows_console_stream(sys.stdout, encoding, errors)
    1:         if rv is not None:
                   return rv
    1:         return _force_correct_text_writer(sys.stdout, encoding, errors,
    1:                                           force_writable=True)
       
    1:     def get_text_stderr(encoding=None, errors=None):
               rv = _get_windows_console_stream(sys.stderr, encoding, errors)
               if rv is not None:
                   return rv
               return _force_correct_text_writer(sys.stderr, encoding, errors,
                                                 force_writable=True)
       
    1:     def filename_to_ui(value):
               if isinstance(value, bytes):
                   value = value.decode(get_filesystem_encoding(), 'replace')
               else:
                   value = value.encode('utf-8', 'surrogateescape') \
                       .decode('utf-8', 'replace')
               return value
       
       
    1: def get_streerror(e, default=None):
           if hasattr(e, 'strerror'):
               msg = e.strerror
           else:
               if default is not None:
                   msg = default
               else:
                   msg = str(e)
           if isinstance(msg, bytes):
               msg = msg.decode('utf-8', 'replace')
           return msg
       
       
       def open_stream(filename, mode='r', encoding=None, errors='strict',
    1:                 atomic=False):
           # Standard streams first.  These are simple because they don't need
           # special handling for the atomic flag.  It's entirely ignored.
           if filename == '-':
               if any(m in mode for m in ['w', 'a', 'x']):
                   if 'b' in mode:
                       return get_binary_stdout(), False
                   return get_text_stdout(encoding=encoding, errors=errors), False
               if 'b' in mode:
                   return get_binary_stdin(), False
               return get_text_stdin(encoding=encoding, errors=errors), False
       
           # Non-atomic writes directly go out through the regular open functions.
           if not atomic:
               if encoding is None:
                   return open(filename, mode), True
               return io.open(filename, mode, encoding=encoding, errors=errors), True
       
           # Some usability stuff for atomic writes
           if 'a' in mode:
               raise ValueError(
                   'Appending to an existing file is not supported, because that '
                   'would involve an expensive `copy`-operation to a temporary '
                   'file. Open the file in normal `w`-mode and copy explicitly '
                   'if that\'s what you\'re after.'
               )
           if 'x' in mode:
               raise ValueError('Use the `overwrite`-parameter instead.')
           if 'w' not in mode:
               raise ValueError('Atomic writes only make sense with `w`-mode.')
       
           # Atomic writes are more complicated.  They work by opening a file
           # as a proxy in the same folder and then using the fdopen
           # functionality to wrap it in a Python file.  Then we wrap it in an
           # atomic file that moves the file over on close.
           import tempfile
           fd, tmp_filename = tempfile.mkstemp(dir=os.path.dirname(filename),
                                               prefix='.__atomic-write')
       
           if encoding is not None:
               f = io.open(fd, mode, encoding=encoding, errors=errors)
           else:
               f = os.fdopen(fd, mode)
       
           return _AtomicFile(f, tmp_filename, os.path.realpath(filename)), True
       
       
       # Used in a destructor call, needs extra protection from interpreter cleanup.
    1: if hasattr(os, 'replace'):
    1:     _replace = os.replace
    1:     _can_replace = True
       else:
           _replace = os.rename
           _can_replace = not WIN
       
       
    2: class _AtomicFile(object):
       
    1:     def __init__(self, f, tmp_filename, real_filename):
               self._f = f
               self._tmp_filename = tmp_filename
               self._real_filename = real_filename
               self.closed = False
       
    1:     @property
           def name(self):
               return self._real_filename
       
    1:     def close(self, delete=False):
               if self.closed:
                   return
               self._f.close()
               if not _can_replace:
                   try:
                       os.remove(self._real_filename)
                   except OSError:
                       pass
               _replace(self._tmp_filename, self._real_filename)
               self.closed = True
       
    1:     def __getattr__(self, name):
               return getattr(self._f, name)
       
    1:     def __enter__(self):
               return self
       
    1:     def __exit__(self, exc_type, exc_value, tb):
               self.close(delete=exc_type is not None)
       
    1:     def __repr__(self):
               return repr(self._f)
       
       
    1: auto_wrap_for_ansi = None
    1: colorama = None
    1: get_winterm_size = None
       
       
    1: def strip_ansi(value):
           return _ansi_re.sub('', value)
       
       
    1: def should_strip_ansi(stream=None, color=None):
    5:     if color is None:
    5:         if stream is None:
                   stream = sys.stdin
    5:         return not isatty(stream)
           return not color
       
       
       # If we're on Windows, we provide transparent integration through
       # colorama.  This will make ANSI colors through the echo function
       # work automatically.
    1: if WIN:
           # Windows has a smaller terminal
           DEFAULT_COLUMNS = 79
       
           from ._winconsole import _get_windows_console_stream, _wrap_std_stream
       
           def _get_argv_encoding():
               import locale
               return locale.getpreferredencoding()
       
           if PY2:
               def raw_input(prompt=''):
                   sys.stderr.flush()
                   if prompt:
                       stdout = _default_text_stdout()
                       stdout.write(prompt)
                   stdin = _default_text_stdin()
                   return stdin.readline().rstrip('\r\n')
       
           try:
               import colorama
           except ImportError:
               pass
           else:
               _ansi_stream_wrappers = WeakKeyDictionary()
       
               def auto_wrap_for_ansi(stream, color=None):
                   """This function wraps a stream so that calls through colorama
                   are issued to the win32 console API to recolor on demand.  It
                   also ensures to reset the colors if a write call is interrupted
                   to not destroy the console afterwards.
                   """
                   try:
                       cached = _ansi_stream_wrappers.get(stream)
                   except Exception:
                       cached = None
                   if cached is not None:
                       return cached
                   strip = should_strip_ansi(stream, color)
                   ansi_wrapper = colorama.AnsiToWin32(stream, strip=strip)
                   rv = ansi_wrapper.stream
                   _write = rv.write
       
                   def _safe_write(s):
                       try:
                           return _write(s)
                       except:
                           ansi_wrapper.reset_all()
                           raise
       
                   rv.write = _safe_write
                   try:
                       _ansi_stream_wrappers[stream] = rv
                   except Exception:
                       pass
                   return rv
       
               def get_winterm_size():
                   win = colorama.win32.GetConsoleScreenBufferInfo(
                       colorama.win32.STDOUT).srWindow
                   return win.Right - win.Left, win.Bottom - win.Top
       else:
    1:     def _get_argv_encoding():
               return getattr(sys.stdin, 'encoding', None) or get_filesystem_encoding()
       
    2:     _get_windows_console_stream = lambda *x: None
    1:     _wrap_std_stream = lambda *x: None
       
       
    1: def term_len(x):
           return len(strip_ansi(x))
       
       
    1: def isatty(stream):
    5:     try:
    5:         return stream.isatty()
           except Exception:
               return False
       
       
    1: def _make_cached_stream_func(src_func, wrapper_func):
    3:     cache = WeakKeyDictionary()
    3:     def func():
    5:         stream = src_func()
    5:         try:
    5:             rv = cache.get(stream)
               except Exception:
                   rv = None
    5:         if rv is not None:
    4:             return rv
    1:         rv = wrapper_func()
    1:         try:
    1:             stream = src_func()  # In case wrapper_func() modified the stream
    1:             cache[stream] = rv
               except Exception:
                   pass
    1:         return rv
    3:     return func
       
       
    1: _default_text_stdin = _make_cached_stream_func(
    1:     lambda: sys.stdin, get_text_stdin)
    1: _default_text_stdout = _make_cached_stream_func(
    7:     lambda: sys.stdout, get_text_stdout)
    1: _default_text_stderr = _make_cached_stream_func(
    1:     lambda: sys.stderr, get_text_stderr)
       
       
       binary_streams = {
    1:     'stdin': get_binary_stdin,
    1:     'stdout': get_binary_stdout,
    1:     'stderr': get_binary_stderr,
       }
       
       text_streams = {
    1:     'stdin': get_text_stdin,
    1:     'stdout': get_text_stdout,
    1:     'stderr': get_text_stderr,
       }
