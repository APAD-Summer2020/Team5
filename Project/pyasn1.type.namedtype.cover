       #
       # This file is part of pyasn1 software.
       #
       # Copyright (c) 2005-2019, Ilya Etingof <etingof@gmail.com>
       # License: http://snmplabs.com/pyasn1/license.html
       #
    1: import sys
       
    1: from pyasn1 import error
    1: from pyasn1.type import tag
    1: from pyasn1.type import tagmap
       
    1: __all__ = ['NamedType', 'OptionalNamedType', 'DefaultedNamedType',
    1:            'NamedTypes']
       
    1: try:
    1:     any
       
       except NameError:
           any = lambda x: bool(filter(bool, x))
       
       
    2: class NamedType(object):
           """Create named field object for a constructed ASN.1 type.
       
           The |NamedType| object represents a single name and ASN.1 type of a constructed ASN.1 type.
       
           |NamedType| objects are immutable and duck-type Python :class:`tuple` objects
           holding *name* and *asn1Object* components.
       
           Parameters
           ----------
           name: :py:class:`str`
               Field name
       
           asn1Object:
               ASN.1 type object
    1:     """
    1:     isOptional = False
    1:     isDefaulted = False
       
    1:     def __init__(self, name, asn1Object, openType=None):
  327:         self.__name = name
  327:         self.__type = asn1Object
  327:         self.__nameAndType = name, asn1Object
  327:         self.__openType = openType
       
    1:     def __repr__(self):
  669:         representation = '%s=%r' % (self.name, self.asn1Object)
       
  669:         if self.openType:
   17:             representation += ', open type %r' % self.openType
       
  669:         return '<%s object, type %s>' % (
  669:             self.__class__.__name__, representation)
       
    1:     def __eq__(self, other):
               return self.__nameAndType == other
       
    1:     def __ne__(self, other):
               return self.__nameAndType != other
       
    1:     def __lt__(self, other):
               return self.__nameAndType < other
       
    1:     def __le__(self, other):
               return self.__nameAndType <= other
       
    1:     def __gt__(self, other):
               return self.__nameAndType > other
       
    1:     def __ge__(self, other):
               return self.__nameAndType >= other
       
    1:     def __hash__(self):
               return hash(self.__nameAndType)
       
    1:     def __getitem__(self, idx):
               return self.__nameAndType[idx]
       
    1:     def __iter__(self):
               return iter(self.__nameAndType)
       
    1:     @property
           def name(self):
 3473:         return self.__name
       
    1:     @property
           def asn1Object(self):
 6362:         return self.__type
       
    1:     @property
           def openType(self):
 1387:         return self.__openType
       
           # Backward compatibility
       
    1:     def getName(self):
               return self.name
       
    1:     def getType(self):
               return self.asn1Object
       
       
    2: class OptionalNamedType(NamedType):
    1:     __doc__ = NamedType.__doc__
       
    1:     isOptional = True
       
       
    2: class DefaultedNamedType(NamedType):
    1:     __doc__ = NamedType.__doc__
       
    1:     isDefaulted = True
       
       
    2: class NamedTypes(object):
           """Create a collection of named fields for a constructed ASN.1 type.
       
           The NamedTypes object represents a collection of named fields of a constructed ASN.1 type.
       
           *NamedTypes* objects are immutable and duck-type Python :class:`dict` objects
           holding *name* as keys and ASN.1 type object as values.
       
           Parameters
           ----------
           *namedTypes: :class:`~pyasn1.type.namedtype.NamedType`
       
           Examples
           --------
       
           .. code-block:: python
       
               class Description(Sequence):
                   '''
                   ASN.1 specification:
       
                   Description ::= SEQUENCE {
                       surname    IA5String,
                       first-name IA5String OPTIONAL,
                       age        INTEGER DEFAULT 40
                   }
                   '''
                   componentType = NamedTypes(
                       NamedType('surname', IA5String()),
                       OptionalNamedType('first-name', IA5String()),
                       DefaultedNamedType('age', Integer(40))
                   )
       
               descr = Description()
               descr['surname'] = 'Smith'
               descr['first-name'] = 'John'
    1:     """
    1:     def __init__(self, *namedTypes, **kwargs):
  410:         self.__namedTypes = namedTypes
  410:         self.__namedTypesLen = len(self.__namedTypes)
  410:         self.__minTagSet = self.__computeMinTagSet()
  410:         self.__nameToPosMap = self.__computeNameToPosMap()
  410:         self.__tagToPosMap = self.__computeTagToPosMap()
  410:         self.__ambiguousTypes = 'terminal' not in kwargs and self.__computeAmbiguousTypes() or {}
  410:         self.__uniqueTagMap = self.__computeTagMaps(unique=True)
  410:         self.__nonUniqueTagMap = self.__computeTagMaps(unique=False)
 1521:         self.__hasOptionalOrDefault = any([True for namedType in self.__namedTypes
  701:                                            if namedType.isDefaulted or namedType.isOptional])
 1521:         self.__hasOpenTypes = any([True for namedType in self.__namedTypes
  701:                                    if namedType.openType])
       
  410:         self.__requiredComponents = frozenset(
 1521:                 [idx for idx, nt in enumerate(self.__namedTypes) if not nt.isOptional and not nt.isDefaulted]
                   )
 1521:         self.__keys = frozenset([namedType.name for namedType in self.__namedTypes])
 1521:         self.__values = tuple([namedType.asn1Object for namedType in self.__namedTypes])
 1521:         self.__items = tuple([(namedType.name, namedType.asn1Object) for namedType in self.__namedTypes])
       
    1:     def __repr__(self):
 1047:         representation = ', '.join(['%r' % x for x in self.__namedTypes])
  211:         return '<%s object, types %s>' % (
  211:             self.__class__.__name__, representation)
       
    1:     def __eq__(self, other):
               return self.__namedTypes == other
       
    1:     def __ne__(self, other):
               return self.__namedTypes != other
       
    1:     def __lt__(self, other):
               return self.__namedTypes < other
       
    1:     def __le__(self, other):
               return self.__namedTypes <= other
       
    1:     def __gt__(self, other):
               return self.__namedTypes > other
       
    1:     def __ge__(self, other):
               return self.__namedTypes >= other
       
    1:     def __hash__(self):
               return hash(self.__namedTypes)
       
    1:     def __getitem__(self, idx):
               try:
                   return self.__namedTypes[idx]
       
               except TypeError:
                   return self.__namedTypes[self.__nameToPosMap[idx]]
       
    1:     def __contains__(self, key):
               return key in self.__nameToPosMap
       
    1:     def __iter__(self):
               return (x[0] for x in self.__namedTypes)
       
    1:     if sys.version_info[0] <= 2:
               def __nonzero__(self):
                   return self.__namedTypesLen > 0
           else:
    1:         def __bool__(self):
  258:             return self.__namedTypesLen > 0
       
    1:     def __len__(self):
  163:         return self.__namedTypesLen
       
           # Python dict protocol
       
    1:     def values(self):
               return self.__values
       
    1:     def keys(self):
               return self.__keys
       
    1:     def items(self):
               return self.__items
       
    1:     def clone(self):
               return self.__class__(*self.__namedTypes)
       
    2:     class PostponedError(object):
    1:         def __init__(self, errorMsg):
   44:             self.__errorMsg = errorMsg
       
    1:         def __getitem__(self, item):
                   raise  error.PyAsn1Error(self.__errorMsg)
       
    1:     def __computeTagToPosMap(self):
  410:         tagToPosMap = {}
 1054:         for idx, namedType in enumerate(self.__namedTypes):
  666:             tagMap = namedType.asn1Object.tagMap
  666:             if isinstance(tagMap, NamedTypes.PostponedError):
                       return tagMap
  666:             if not tagMap:
                       continue
 1410:             for _tagSet in tagMap.presentTypes:
  766:                 if _tagSet in tagToPosMap:
   22:                     return NamedTypes.PostponedError('Duplicate component tag %s at %s' % (_tagSet, namedType))
  744:                 tagToPosMap[_tagSet] = idx
       
  388:         return tagToPosMap
       
    1:     def __computeNameToPosMap(self):
  410:         nameToPosMap = {}
 1111:         for idx, namedType in enumerate(self.__namedTypes):
  701:             if namedType.name in nameToPosMap:
                       return NamedTypes.PostponedError('Duplicate component name %s at %s' % (namedType.name, namedType))
  701:             nameToPosMap[namedType.name] = idx
       
  410:         return nameToPosMap
       
    1:     def __computeAmbiguousTypes(self):
   96:         ambiguousTypes = {}
   96:         partialAmbiguousTypes = ()
  423:         for idx, namedType in reversed(tuple(enumerate(self.__namedTypes))):
  327:             if namedType.isOptional or namedType.isDefaulted:
   76:                 partialAmbiguousTypes = (namedType,) + partialAmbiguousTypes
                   else:
  251:                 partialAmbiguousTypes = (namedType,)
  327:             if len(partialAmbiguousTypes) == len(self.__namedTypes):
   13:                 ambiguousTypes[idx] = self
                   else:
  314:                 ambiguousTypes[idx] = NamedTypes(*partialAmbiguousTypes, **dict(terminal=True))
   96:         return ambiguousTypes
       
    1:     def getTypeByPosition(self, idx):
               """Return ASN.1 type object by its position in fields set.
       
               Parameters
               ----------
               idx: :py:class:`int`
                   Field index
       
               Returns
               -------
               :
                   ASN.1 type
       
               Raises
               ------
               ~pyasn1.error.PyAsn1Error
                   If given position is out of fields range
               """
               try:
                   return self.__namedTypes[idx].asn1Object
       
               except IndexError:
                   raise error.PyAsn1Error('Type position out of range')
       
    1:     def getPositionByType(self, tagSet):
               """Return field position by its ASN.1 type.
       
               Parameters
               ----------
               tagSet: :class:`~pysnmp.type.tag.TagSet`
                   ASN.1 tag set distinguishing one ASN.1 type from others.
       
               Returns
               -------
               : :py:class:`int`
                   ASN.1 type position in fields set
       
               Raises
               ------
               ~pyasn1.error.PyAsn1Error
                   If *tagSet* is not present or ASN.1 types are not unique within callee *NamedTypes*
               """
               try:
                   return self.__tagToPosMap[tagSet]
       
               except KeyError:
                   raise error.PyAsn1Error('Type %s not found' % (tagSet,))
       
    1:     def getNameByPosition(self, idx):
               """Return field name by its position in fields set.
       
               Parameters
               ----------
               idx: :py:class:`idx`
                   Field index
       
               Returns
               -------
               : :py:class:`str`
                   Field name
       
               Raises
               ------
               ~pyasn1.error.PyAsn1Error
                   If given field name is not present in callee *NamedTypes*
               """
               try:
                   return self.__namedTypes[idx].name
       
               except IndexError:
                   raise error.PyAsn1Error('Type position out of range')
       
    1:     def getPositionByName(self, name):
               """Return field position by filed name.
       
               Parameters
               ----------
               name: :py:class:`str`
                   Field name
       
               Returns
               -------
               : :py:class:`int`
                   Field position in fields set
       
               Raises
               ------
               ~pyasn1.error.PyAsn1Error
                   If *name* is not present or not unique within callee *NamedTypes*
               """
               try:
                   return self.__nameToPosMap[name]
       
               except KeyError:
                   raise error.PyAsn1Error('Name %s not found' % (name,))
       
    1:     def getTagMapNearPosition(self, idx):
               """Return ASN.1 types that are allowed at or past given field position.
       
               Some ASN.1 serialisation allow for skipping optional and defaulted fields.
               Some constructed ASN.1 types allow reordering of the fields. When recovering
               such objects it may be important to know which types can possibly be
               present at any given position in the field sets.
       
               Parameters
               ----------
               idx: :py:class:`int`
                   Field index
       
               Returns
               -------
               : :class:`~pyasn1.type.tagmap.TagMap`
                   Map if ASN.1 types allowed at given field position
       
               Raises
               ------
               ~pyasn1.error.PyAsn1Error
                   If given position is out of fields range
               """
               try:
                   return self.__ambiguousTypes[idx].tagMap
       
               except KeyError:
                   raise error.PyAsn1Error('Type position out of range')
       
    1:     def getPositionNearType(self, tagSet, idx):
               """Return the closest field position where given ASN.1 type is allowed.
       
               Some ASN.1 serialisation allow for skipping optional and defaulted fields.
               Some constructed ASN.1 types allow reordering of the fields. When recovering
               such objects it may be important to know at which field position, in field set,
               given *tagSet* is allowed at or past *idx* position.
       
               Parameters
               ----------
               tagSet: :class:`~pyasn1.type.tag.TagSet`
                  ASN.1 type which field position to look up
       
               idx: :py:class:`int`
                   Field position at or past which to perform ASN.1 type look up
       
               Returns
               -------
               : :py:class:`int`
                   Field position in fields set
       
               Raises
               ------
               ~pyasn1.error.PyAsn1Error
                   If *tagSet* is not present or not unique within callee *NamedTypes*
                   or *idx* is out of fields range
               """
               try:
                   return idx + self.__ambiguousTypes[idx].getPositionByType(tagSet)
       
               except KeyError:
                   raise error.PyAsn1Error('Type position out of range')
       
    1:     def __computeMinTagSet(self):
  410:         minTagSet = None
 1111:         for namedType in self.__namedTypes:
  701:             asn1Object = namedType.asn1Object
       
  701:             try:
  701:                 tagSet = asn1Object.minTagSet
       
  701:             except AttributeError:
  701:                 tagSet = asn1Object.tagSet
       
  701:             if minTagSet is None or tagSet < minTagSet:
  472:                 minTagSet = tagSet
       
  410:         return minTagSet or tag.TagSet()
       
    1:     @property
           def minTagSet(self):
               """Return the minimal TagSet among ASN.1 type in callee *NamedTypes*.
       
               Some ASN.1 types/serialisation protocols require ASN.1 types to be
               arranged based on their numerical tag value. The *minTagSet* property
               returns that.
       
               Returns
               -------
               : :class:`~pyasn1.type.tagset.TagSet`
                   Minimal TagSet among ASN.1 types in callee *NamedTypes*
               """
               return self.__minTagSet
       
    1:     def __computeTagMaps(self, unique):
  820:         presentTypes = {}
  820:         skipTypes = {}
  820:         defaultType = None
 2165:         for namedType in self.__namedTypes:
 1367:             tagMap = namedType.asn1Object.tagMap
 1367:             if isinstance(tagMap, NamedTypes.PostponedError):
                       return tagMap
 2924:             for tagSet in tagMap:
 1579:                 if unique and tagSet in presentTypes:
   22:                     return NamedTypes.PostponedError('Non-unique tagSet %s of %s at %s' % (tagSet, namedType, self))
 1557:                 presentTypes[tagSet] = namedType.asn1Object
 1345:             skipTypes.update(tagMap.skipTypes)
       
 1345:             if defaultType is None:
 1345:                 defaultType = tagMap.defaultType
                   elif tagMap.defaultType is not None:
                       return NamedTypes.PostponedError('Duplicate default ASN.1 type at %s' % (self,))
       
  798:         return tagmap.TagMap(presentTypes, skipTypes, defaultType)
       
    1:     @property
           def tagMap(self):
               """Return a *TagMap* object from tags and types recursively.
       
               Return a :class:`~pyasn1.type.tagmap.TagMap` object by
               combining tags from *TagMap* objects of children types and
               associating them with their immediate child type.
       
               Example
               -------
               .. code-block:: python
       
                  OuterType ::= CHOICE {
                      innerType INTEGER
                  }
       
               Calling *.tagMap* on *OuterType* will yield a map like this:
       
               .. code-block:: python
       
                  Integer.tagSet -> Choice
               """
               return self.__nonUniqueTagMap
       
    1:     @property
           def tagMapUnique(self):
               """Return a *TagMap* object from unique tags and types recursively.
       
               Return a :class:`~pyasn1.type.tagmap.TagMap` object by
               combining tags from *TagMap* objects of children types and
               associating them with their immediate child type.
       
               Example
               -------
               .. code-block:: python
       
                  OuterType ::= CHOICE {
                      innerType INTEGER
                  }
       
               Calling *.tagMapUnique* on *OuterType* will yield a map like this:
       
               .. code-block:: python
       
                  Integer.tagSet -> Choice
       
               Note
               ----
       
               Duplicate *TagSet* objects found in the tree of children
               types would cause error.
               """
   82:         return self.__uniqueTagMap
       
    1:     @property
           def hasOptionalOrDefault(self):
               return self.__hasOptionalOrDefault
       
    1:     @property
           def hasOpenTypes(self):
               return self.__hasOpenTypes
       
    1:     @property
           def namedTypes(self):
  258:         return tuple(self.__namedTypes)
       
    1:     @property
           def requiredComponents(self):
               return self.__requiredComponents
