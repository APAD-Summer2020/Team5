       # -*- coding: utf-8 -*-
       """
       markupsafe
       ~~~~~~~~~~
       
       Implements an escape function and a Markup string to replace HTML
       special characters with safe representations.
       
       :copyright: 2010 Pallets
       :license: BSD-3-Clause
    1: """
    1: import re
    1: import string
       
    1: from ._compat import int_types
    1: from ._compat import iteritems
    1: from ._compat import Mapping
    1: from ._compat import PY2
    1: from ._compat import string_types
    1: from ._compat import text_type
    1: from ._compat import unichr
       
    1: __version__ = "1.1.1"
       
    1: __all__ = ["Markup", "soft_unicode", "escape", "escape_silent"]
       
    1: _striptags_re = re.compile(r"(<!--.*?-->|<[^>]*>)")
    1: _entity_re = re.compile(r"&([^& ;]+);")
       
       
    2: class Markup(text_type):
           """A string that is ready to be safely inserted into an HTML or XML
           document, either because it was escaped or because it was marked
           safe.
       
           Passing an object to the constructor converts it to text and wraps
           it to mark it safe without escaping. To escape the text, use the
           :meth:`escape` class method instead.
       
           >>> Markup('Hello, <em>World</em>!')
           Markup('Hello, <em>World</em>!')
           >>> Markup(42)
           Markup('42')
           >>> Markup.escape('Hello, <em>World</em>!')
           Markup('Hello &lt;em&gt;World&lt;/em&gt;!')
       
           This implements the ``__html__()`` interface that some frameworks
           use. Passing an object that implements ``__html__()`` will wrap the
           output of that method, marking it safe.
       
           >>> class Foo:
           ...     def __html__(self):
           ...         return '<a href="/foo">foo</a>'
           ...
           >>> Markup(Foo())
           Markup('<a href="/foo">foo</a>')
       
           This is a subclass of the text type (``str`` in Python 3,
           ``unicode`` in Python 2). It has the same methods as that type, but
           all methods escape their arguments and return a ``Markup`` instance.
       
           >>> Markup('<em>%s</em>') % 'foo & bar'
           Markup('<em>foo &amp; bar</em>')
           >>> Markup('<em>Hello</em> ') + '<foo>'
           Markup('<em>Hello</em> &lt;foo&gt;')
    1:     """
       
    1:     __slots__ = ()
       
    1:     def __new__(cls, base=u"", encoding=None, errors="strict"):
               if hasattr(base, "__html__"):
                   base = base.__html__()
               if encoding is None:
                   return text_type.__new__(cls, base)
               return text_type.__new__(cls, base, encoding, errors)
       
    1:     def __html__(self):
               return self
       
    1:     def __add__(self, other):
               if isinstance(other, string_types) or hasattr(other, "__html__"):
                   return self.__class__(super(Markup, self).__add__(self.escape(other)))
               return NotImplemented
       
    1:     def __radd__(self, other):
               if hasattr(other, "__html__") or isinstance(other, string_types):
                   return self.escape(other).__add__(self)
               return NotImplemented
       
    1:     def __mul__(self, num):
               if isinstance(num, int_types):
                   return self.__class__(text_type.__mul__(self, num))
               return NotImplemented
       
    1:     __rmul__ = __mul__
       
    1:     def __mod__(self, arg):
               if isinstance(arg, tuple):
                   arg = tuple(_MarkupEscapeHelper(x, self.escape) for x in arg)
               else:
                   arg = _MarkupEscapeHelper(arg, self.escape)
               return self.__class__(text_type.__mod__(self, arg))
       
    1:     def __repr__(self):
               return "%s(%s)" % (self.__class__.__name__, text_type.__repr__(self))
       
    1:     def join(self, seq):
               return self.__class__(text_type.join(self, map(self.escape, seq)))
       
    1:     join.__doc__ = text_type.join.__doc__
       
    1:     def split(self, *args, **kwargs):
               return list(map(self.__class__, text_type.split(self, *args, **kwargs)))
       
    1:     split.__doc__ = text_type.split.__doc__
       
    1:     def rsplit(self, *args, **kwargs):
               return list(map(self.__class__, text_type.rsplit(self, *args, **kwargs)))
       
    1:     rsplit.__doc__ = text_type.rsplit.__doc__
       
    1:     def splitlines(self, *args, **kwargs):
               return list(map(self.__class__, text_type.splitlines(self, *args, **kwargs)))
       
    1:     splitlines.__doc__ = text_type.splitlines.__doc__
       
    1:     def unescape(self):
               """Convert escaped markup back into a text string. This replaces
               HTML entities with the characters they represent.
       
               >>> Markup('Main &raquo; <em>About</em>').unescape()
               'Main » <em>About</em>'
               """
               from ._constants import HTML_ENTITIES
       
               def handle_match(m):
                   name = m.group(1)
                   if name in HTML_ENTITIES:
                       return unichr(HTML_ENTITIES[name])
                   try:
                       if name[:2] in ("#x", "#X"):
                           return unichr(int(name[2:], 16))
                       elif name.startswith("#"):
                           return unichr(int(name[1:]))
                   except ValueError:
                       pass
                   # Don't modify unexpected input.
                   return m.group()
       
               return _entity_re.sub(handle_match, text_type(self))
       
    1:     def striptags(self):
               """:meth:`unescape` the markup, remove tags, and normalize
               whitespace to single spaces.
       
               >>> Markup('Main &raquo;\t<em>About</em>').striptags()
               'Main » About'
               """
               stripped = u" ".join(_striptags_re.sub("", self).split())
               return Markup(stripped).unescape()
       
    1:     @classmethod
           def escape(cls, s):
               """Escape a string. Calls :func:`escape` and ensures that for
               subclasses the correct type is returned.
               """
               rv = escape(s)
               if rv.__class__ is not cls:
                   return cls(rv)
               return rv
       
    1:     def make_simple_escaping_wrapper(name):  # noqa: B902
   16:         orig = getattr(text_type, name)
       
   16:         def func(self, *args, **kwargs):
                   args = _escape_argspec(list(args), enumerate(args), self.escape)
                   _escape_argspec(kwargs, iteritems(kwargs), self.escape)
                   return self.__class__(orig(self, *args, **kwargs))
       
   16:         func.__name__ = orig.__name__
   16:         func.__doc__ = orig.__doc__
   16:         return func
       
    1:     for method in (
   17:         "__getitem__",
               "capitalize",
               "title",
               "lower",
               "upper",
               "replace",
               "ljust",
               "rjust",
               "lstrip",
               "rstrip",
               "center",
               "strip",
               "translate",
               "expandtabs",
               "swapcase",
               "zfill",
           ):
   16:         locals()[method] = make_simple_escaping_wrapper(method)
       
    1:     def partition(self, sep):
               return tuple(map(self.__class__, text_type.partition(self, self.escape(sep))))
       
    1:     def rpartition(self, sep):
               return tuple(map(self.__class__, text_type.rpartition(self, self.escape(sep))))
       
    1:     def format(self, *args, **kwargs):
               formatter = EscapeFormatter(self.escape)
               kwargs = _MagicFormatMapping(args, kwargs)
               return self.__class__(formatter.vformat(self, args, kwargs))
       
    1:     def __html_format__(self, format_spec):
               if format_spec:
                   raise ValueError("Unsupported format specification " "for Markup.")
               return self
       
           # not in python 3
    1:     if hasattr(text_type, "__getslice__"):
               __getslice__ = make_simple_escaping_wrapper("__getslice__")
       
    1:     del method, make_simple_escaping_wrapper
       
       
    2: class _MagicFormatMapping(Mapping):
           """This class implements a dummy wrapper to fix a bug in the Python
           standard library for string formatting.
       
           See http://bugs.python.org/issue13598 for information about why
           this is necessary.
    1:     """
       
    1:     def __init__(self, args, kwargs):
               self._args = args
               self._kwargs = kwargs
               self._last_index = 0
       
    1:     def __getitem__(self, key):
               if key == "":
                   idx = self._last_index
                   self._last_index += 1
                   try:
                       return self._args[idx]
                   except LookupError:
                       pass
                   key = str(idx)
               return self._kwargs[key]
       
    1:     def __iter__(self):
               return iter(self._kwargs)
       
    1:     def __len__(self):
               return len(self._kwargs)
       
       
    1: if hasattr(text_type, "format"):
       
    2:     class EscapeFormatter(string.Formatter):
    1:         def __init__(self, escape):
                   self.escape = escape
       
    1:         def format_field(self, value, format_spec):
                   if hasattr(value, "__html_format__"):
                       rv = value.__html_format__(format_spec)
                   elif hasattr(value, "__html__"):
                       if format_spec:
                           raise ValueError(
                               "Format specifier {0} given, but {1} does not"
                               " define __html_format__. A class that defines"
                               " __html__ must define __html_format__ to work"
                               " with format specifiers.".format(format_spec, type(value))
                           )
                       rv = value.__html__()
                   else:
                       # We need to make sure the format spec is unicode here as
                       # otherwise the wrong callback methods are invoked.  For
                       # instance a byte string there would invoke __str__ and
                       # not __unicode__.
                       rv = string.Formatter.format_field(self, value, text_type(format_spec))
                   return text_type(self.escape(rv))
       
       
    1: def _escape_argspec(obj, iterable, escape):
           """Helper for various string-wrapped functions."""
           for key, value in iterable:
               if hasattr(value, "__html__") or isinstance(value, string_types):
                   obj[key] = escape(value)
           return obj
       
       
    2: class _MarkupEscapeHelper(object):
    1:     """Helper for Markup.__mod__"""
       
    1:     def __init__(self, obj, escape):
               self.obj = obj
               self.escape = escape
       
    1:     def __getitem__(self, item):
               return _MarkupEscapeHelper(self.obj[item], self.escape)
       
    1:     def __str__(self):
               return text_type(self.escape(self.obj))
       
    1:     __unicode__ = __str__
       
    1:     def __repr__(self):
               return str(self.escape(repr(self.obj)))
       
    1:     def __int__(self):
               return int(self.obj)
       
    1:     def __float__(self):
               return float(self.obj)
       
       
       # we have to import it down here as the speedups and native
       # modules imports the markup type which is define above.
    1: try:
    1:     from ._speedups import escape, escape_silent, soft_unicode
       except ImportError:
           from ._native import escape, escape_silent, soft_unicode
       
    1: if not PY2:
    1:     soft_str = soft_unicode
    1:     __all__.append("soft_str")
