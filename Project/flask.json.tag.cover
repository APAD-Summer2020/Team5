       # -*- coding: utf-8 -*-
       """
       Tagged JSON
       ~~~~~~~~~~~
       
       A compact representation for lossless serialization of non-standard JSON types.
       :class:`~flask.sessions.SecureCookieSessionInterface` uses this to serialize
       the session data, but it may be useful in other places. It can be extended to
       support other types.
       
       .. autoclass:: TaggedJSONSerializer
           :members:
       
       .. autoclass:: JSONTag
           :members:
       
       Let's seen an example that adds support for :class:`~collections.OrderedDict`.
       Dicts don't have an order in Python or JSON, so to handle this we will dump
       the items as a list of ``[key, value]`` pairs. Subclass :class:`JSONTag` and
       give it the new key ``' od'`` to identify the type. The session serializer
       processes dicts first, so insert the new tag at the front of the order since
       ``OrderedDict`` must be processed before ``dict``. ::
       
           from flask.json.tag import JSONTag
       
           class TagOrderedDict(JSONTag):
               __slots__ = ('serializer',)
               key = ' od'
       
               def check(self, value):
                   return isinstance(value, OrderedDict)
       
               def to_json(self, value):
                   return [[k, self.serializer.tag(v)] for k, v in iteritems(value)]
       
               def to_python(self, value):
                   return OrderedDict(value)
       
           app.session_interface.serializer.register(TagOrderedDict, index=0)
       
       :copyright: 2010 Pallets
       :license: BSD-3-Clause
    1: """
    1: from base64 import b64decode
    1: from base64 import b64encode
    1: from datetime import datetime
    1: from uuid import UUID
       
    1: from jinja2 import Markup
    1: from werkzeug.http import http_date
    1: from werkzeug.http import parse_date
       
    1: from .._compat import iteritems
    1: from .._compat import text_type
    1: from ..json import dumps
    1: from ..json import loads
       
       
    2: class JSONTag(object):
    1:     """Base class for defining type tags for :class:`TaggedJSONSerializer`."""
       
    1:     __slots__ = ("serializer",)
       
           #: The tag to mark the serialized object with. If ``None``, this tag is
           #: only used as an intermediate step during tagging.
    1:     key = None
       
    1:     def __init__(self, serializer):
               """Create a tagger for the given serializer."""
    8:         self.serializer = serializer
       
    1:     def check(self, value):
               """Check if the given value should be tagged by this tag."""
               raise NotImplementedError
       
    1:     def to_json(self, value):
               """Convert the Python object to an object that is a valid JSON type.
               The tag will be added later."""
               raise NotImplementedError
       
    1:     def to_python(self, value):
               """Convert the JSON representation back to the correct type. The tag
               will already be removed."""
               raise NotImplementedError
       
    1:     def tag(self, value):
               """Convert the value to a valid JSON type and add the tag structure
               around it."""
               return {self.key: self.to_json(value)}
       
       
    2: class TagDict(JSONTag):
           """Tag for 1-item dicts whose only key matches a registered tag.
       
           Internally, the dict key is suffixed with `__`, and the suffix is removed
           when deserializing.
    1:     """
       
    1:     __slots__ = ()
    1:     key = " di"
       
    1:     def check(self, value):
               return (
                   isinstance(value, dict)
                   and len(value) == 1
                   and next(iter(value)) in self.serializer.tags
               )
       
    1:     def to_json(self, value):
               key = next(iter(value))
               return {key + "__": self.serializer.tag(value[key])}
       
    1:     def to_python(self, value):
               key = next(iter(value))
               return {key[:-2]: value[key]}
       
       
    2: class PassDict(JSONTag):
    1:     __slots__ = ()
       
    1:     def check(self, value):
               return isinstance(value, dict)
       
    1:     def to_json(self, value):
               # JSON objects may only have string keys, so don't bother tagging the
               # key here.
               return dict((k, self.serializer.tag(v)) for k, v in iteritems(value))
       
    1:     tag = to_json
       
       
    2: class TagTuple(JSONTag):
    1:     __slots__ = ()
    1:     key = " t"
       
    1:     def check(self, value):
               return isinstance(value, tuple)
       
    1:     def to_json(self, value):
               return [self.serializer.tag(item) for item in value]
       
    1:     def to_python(self, value):
               return tuple(value)
       
       
    2: class PassList(JSONTag):
    1:     __slots__ = ()
       
    1:     def check(self, value):
               return isinstance(value, list)
       
    1:     def to_json(self, value):
               return [self.serializer.tag(item) for item in value]
       
    1:     tag = to_json
       
       
    2: class TagBytes(JSONTag):
    1:     __slots__ = ()
    1:     key = " b"
       
    1:     def check(self, value):
               return isinstance(value, bytes)
       
    1:     def to_json(self, value):
               return b64encode(value).decode("ascii")
       
    1:     def to_python(self, value):
               return b64decode(value)
       
       
    2: class TagMarkup(JSONTag):
           """Serialize anything matching the :class:`~flask.Markup` API by
           having a ``__html__`` method to the result of that method. Always
    1:     deserializes to an instance of :class:`~flask.Markup`."""
       
    1:     __slots__ = ()
    1:     key = " m"
       
    1:     def check(self, value):
               return callable(getattr(value, "__html__", None))
       
    1:     def to_json(self, value):
               return text_type(value.__html__())
       
    1:     def to_python(self, value):
               return Markup(value)
       
       
    2: class TagUUID(JSONTag):
    1:     __slots__ = ()
    1:     key = " u"
       
    1:     def check(self, value):
               return isinstance(value, UUID)
       
    1:     def to_json(self, value):
               return value.hex
       
    1:     def to_python(self, value):
               return UUID(value)
       
       
    2: class TagDateTime(JSONTag):
    1:     __slots__ = ()
    1:     key = " d"
       
    1:     def check(self, value):
               return isinstance(value, datetime)
       
    1:     def to_json(self, value):
               return http_date(value)
       
    1:     def to_python(self, value):
               return parse_date(value)
       
       
    2: class TaggedJSONSerializer(object):
           """Serializer that uses a tag system to compactly represent objects that
           are not JSON types. Passed as the intermediate serializer to
           :class:`itsdangerous.Serializer`.
       
           The following extra types are supported:
       
           * :class:`dict`
           * :class:`tuple`
           * :class:`bytes`
           * :class:`~flask.Markup`
           * :class:`~uuid.UUID`
           * :class:`~datetime.datetime`
    1:     """
       
    1:     __slots__ = ("tags", "order")
       
           #: Tag classes to bind when creating the serializer. Other tags can be
           #: added later using :meth:`~register`.
           default_tags = [
    1:         TagDict,
    1:         PassDict,
    1:         TagTuple,
    1:         PassList,
    1:         TagBytes,
    1:         TagMarkup,
    1:         TagUUID,
    1:         TagDateTime,
           ]
       
    1:     def __init__(self):
    1:         self.tags = {}
    1:         self.order = []
       
    9:         for cls in self.default_tags:
    8:             self.register(cls)
       
    1:     def register(self, tag_class, force=False, index=None):
               """Register a new tag with this serializer.
       
               :param tag_class: tag class to register. Will be instantiated with this
                   serializer instance.
               :param force: overwrite an existing tag. If false (default), a
                   :exc:`KeyError` is raised.
               :param index: index to insert the new tag in the tag order. Useful when
                   the new tag is a special case of an existing tag. If ``None``
                   (default), the tag is appended to the end of the order.
       
               :raise KeyError: if the tag key is already registered and ``force`` is
                   not true.
               """
    8:         tag = tag_class(self)
    8:         key = tag.key
       
    8:         if key is not None:
    6:             if not force and key in self.tags:
                       raise KeyError("Tag '{0}' is already registered.".format(key))
       
    6:             self.tags[key] = tag
       
    8:         if index is None:
    8:             self.order.append(tag)
               else:
                   self.order.insert(index, tag)
       
    1:     def tag(self, value):
               """Convert a value to a tagged representation if necessary."""
               for tag in self.order:
                   if tag.check(value):
                       return tag.tag(value)
       
               return value
       
    1:     def untag(self, value):
               """Convert a tagged representation back to the original type."""
               if len(value) != 1:
                   return value
       
               key = next(iter(value))
       
               if key not in self.tags:
                   return value
       
               return self.tags[key].to_python(value[key])
       
    1:     def dumps(self, value):
               """Tag the value and dump it to a compact JSON string."""
               return dumps(self.tag(value), separators=(",", ":"))
       
    1:     def loads(self, value):
               """Load data from a JSON string and deserialized any tagged objects."""
               return loads(value, object_hook=self.untag)
