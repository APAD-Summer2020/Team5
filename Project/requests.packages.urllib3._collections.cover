    1: from __future__ import absolute_import
    1: from collections import Mapping, MutableMapping
    1: try:
    1:     from threading import RLock
       except ImportError:  # Platform-specific: No threads available
           class RLock:
               def __enter__(self):
                   pass
       
               def __exit__(self, exc_type, exc_value, traceback):
                   pass
       
       
    1: try:  # Python 2.7+
    1:     from collections import OrderedDict
       except ImportError:
           from .packages.ordered_dict import OrderedDict
    1: from .packages.six import iterkeys, itervalues, PY3
       
       
    1: __all__ = ['RecentlyUsedContainer', 'HTTPHeaderDict']
       
       
    1: _Null = object()
       
       
    2: class RecentlyUsedContainer(MutableMapping):
           """
           Provides a thread-safe dict-like container which maintains up to
           ``maxsize`` keys while throwing away the least-recently-used keys beyond
           ``maxsize``.
       
           :param maxsize:
               Maximum number of recent elements to retain.
       
           :param dispose_func:
               Every time an item is evicted from the container,
               ``dispose_func(value)`` is called.  Callback which will get called
    1:     """
       
    1:     ContainerCls = OrderedDict
       
    1:     def __init__(self, maxsize=10, dispose_func=None):
   10:         self._maxsize = maxsize
   10:         self.dispose_func = dispose_func
       
   10:         self._container = self.ContainerCls()
   10:         self.lock = RLock()
       
    1:     def __getitem__(self, key):
               # Re-insert the item, moving it to the end of the eviction line.
    2:         with self.lock:
    2:             item = self._container.pop(key)
                   self._container[key] = item
                   return item
       
    1:     def __setitem__(self, key, value):
    1:         evicted_value = _Null
    1:         with self.lock:
                   # Possibly evict the existing value of 'key'
    1:             evicted_value = self._container.get(key, _Null)
    1:             self._container[key] = value
       
                   # If we didn't evict an existing value, we might have to evict the
                   # least recently used item from the beginning of the container.
    1:             if len(self._container) > self._maxsize:
                       _key, evicted_value = self._container.popitem(last=False)
       
    1:         if self.dispose_func and evicted_value is not _Null:
                   self.dispose_func(evicted_value)
       
    1:     def __delitem__(self, key):
               with self.lock:
                   value = self._container.pop(key)
       
               if self.dispose_func:
                   self.dispose_func(value)
       
    1:     def __len__(self):
               with self.lock:
                   return len(self._container)
       
    1:     def __iter__(self):
               raise NotImplementedError('Iteration over this class is unlikely to be threadsafe.')
       
    1:     def clear(self):
               with self.lock:
                   # Copy pointers to all values, then wipe the mapping
                   values = list(itervalues(self._container))
                   self._container.clear()
       
               if self.dispose_func:
                   for value in values:
                       self.dispose_func(value)
       
    1:     def keys(self):
               with self.lock:
                   return list(iterkeys(self._container))
       
       
    2: class HTTPHeaderDict(MutableMapping):
           """
           :param headers:
               An iterable of field-value pairs. Must not contain multiple field names
               when compared case-insensitively.
       
           :param kwargs:
               Additional field-value pairs to pass in to ``dict.update``.
       
           A ``dict`` like container for storing HTTP Headers.
       
           Field names are stored and compared case-insensitively in compliance with
           RFC 7230. Iteration provides the first case-sensitive key seen for each
           case-insensitive pair.
       
           Using ``__setitem__`` syntax overwrites fields that compare equal
           case-insensitively in order to maintain ``dict``'s api. For fields that
           compare equal, instead create a new ``HTTPHeaderDict`` and use ``.add``
           in a loop.
       
           If multiple fields that are equal case-insensitively are passed to the
           constructor or ``.update``, the behavior is undefined and some will be
           lost.
       
           >>> headers = HTTPHeaderDict()
           >>> headers.add('Set-Cookie', 'foo=bar')
           >>> headers.add('set-cookie', 'baz=quxx')
           >>> headers['content-length'] = '7'
           >>> headers['SET-cookie']
           'foo=bar, baz=quxx'
           >>> headers['Content-Length']
           '7'
    1:     """
       
    1:     def __init__(self, headers=None, **kwargs):
    1:         super(HTTPHeaderDict, self).__init__()
    1:         self._container = OrderedDict()
    1:         if headers is not None:
    1:             if isinstance(headers, HTTPHeaderDict):
                       self._copy_from(headers)
                   else:
    1:                 self.extend(headers)
    1:         if kwargs:
                   self.extend(kwargs)
       
    1:     def __setitem__(self, key, val):
               self._container[key.lower()] = (key, val)
               return self._container[key.lower()]
       
    1:     def __getitem__(self, key):
   13:         val = self._container[key.lower()]
   13:         return ', '.join(val[1:])
       
    1:     def __delitem__(self, key):
               del self._container[key.lower()]
       
    1:     def __contains__(self, key):
               return key.lower() in self._container
       
    1:     def __eq__(self, other):
               if not isinstance(other, Mapping) and not hasattr(other, 'keys'):
                   return False
               if not isinstance(other, type(self)):
                   other = type(self)(other)
               return (dict((k.lower(), v) for k, v in self.itermerged()) ==
                       dict((k.lower(), v) for k, v in other.itermerged()))
       
    1:     def __ne__(self, other):
               return not self.__eq__(other)
       
    1:     if not PY3:  # Python 2
               iterkeys = MutableMapping.iterkeys
               itervalues = MutableMapping.itervalues
       
    1:     __marker = object()
       
    1:     def __len__(self):
               return len(self._container)
       
    1:     def __iter__(self):
               # Only provide the originally cased names
   12:         for vals in self._container.values():
   11:             yield vals[0]
       
    1:     def pop(self, key, default=__marker):
               '''D.pop(k[,d]) -> v, remove specified key and return the corresponding value.
                 If key is not found, d is returned if given, otherwise KeyError is raised.
               '''
               # Using the MutableMapping function directly fails due to the private marker.
               # Using ordinary dict.pop would expose the internal structures.
               # So let's reinvent the wheel.
               try:
                   value = self[key]
               except KeyError:
                   if default is self.__marker:
                       raise
                   return default
               else:
                   del self[key]
                   return value
       
    1:     def discard(self, key):
               try:
                   del self[key]
               except KeyError:
                   pass
       
    1:     def add(self, key, val):
               """Adds a (name, value) pair, doesn't overwrite the value if it already
               exists.
       
               >>> headers = HTTPHeaderDict(foo='bar')
               >>> headers.add('Foo', 'baz')
               >>> headers['foo']
               'bar, baz'
               """
   13:         key_lower = key.lower()
   13:         new_vals = key, val
               # Keep the common case aka no item present as fast as possible
   13:         vals = self._container.setdefault(key_lower, new_vals)
   13:         if new_vals is not vals:
                   # new_vals was not inserted, as there was a previous one
    2:             if isinstance(vals, list):
                       # If already several items got inserted, we have a list
    1:                 vals.append(val)
                   else:
                       # vals should be a tuple then, i.e. only one item so far
                       # Need to convert the tuple to list for further extension
    1:                 self._container[key_lower] = [vals[0], vals[1], val]
       
    1:     def extend(self, *args, **kwargs):
               """Generic import function for any type of header-like object.
               Adapted version of MutableMapping.update in order to insert items
               with self.add instead of self.__setitem__
               """
    1:         if len(args) > 1:
                   raise TypeError("extend() takes at most 1 positional "
                                   "arguments ({0} given)".format(len(args)))
    1:         other = args[0] if len(args) >= 1 else ()
       
    1:         if isinstance(other, HTTPHeaderDict):
                   for key, val in other.iteritems():
                       self.add(key, val)
    1:         elif isinstance(other, Mapping):
                   for key in other:
                       self.add(key, other[key])
    1:         elif hasattr(other, "keys"):
                   for key in other.keys():
                       self.add(key, other[key])
               else:
   14:             for key, value in other:
   13:                 self.add(key, value)
       
    1:         for key, value in kwargs.items():
                   self.add(key, value)
       
    1:     def getlist(self, key):
               """Returns a list of all the values for the named field. Returns an
               empty list if the key doesn't exist."""
               try:
                   vals = self._container[key.lower()]
               except KeyError:
                   return []
               else:
                   if isinstance(vals, tuple):
                       return [vals[1]]
                   else:
                       return vals[1:]
       
           # Backwards compatibility for httplib
    1:     getheaders = getlist
    1:     getallmatchingheaders = getlist
    1:     iget = getlist
       
    1:     def __repr__(self):
               return "%s(%s)" % (type(self).__name__, dict(self.itermerged()))
       
    1:     def _copy_from(self, other):
               for key in other:
                   val = other.getlist(key)
                   if isinstance(val, list):
                       # Don't need to convert tuples
                       val = list(val)
                   self._container[key.lower()] = [key] + val
       
    1:     def copy(self):
               clone = type(self)()
               clone._copy_from(self)
               return clone
       
    1:     def iteritems(self):
               """Iterate over all header lines, including duplicate ones."""
               for key in self:
                   vals = self._container[key.lower()]
                   for val in vals[1:]:
                       yield vals[0], val
       
    1:     def itermerged(self):
               """Iterate over all headers, merging duplicate ones together."""
               for key in self:
                   val = self._container[key.lower()]
                   yield val[0], ', '.join(val[1:])
       
    1:     def items(self):
               return list(self.iteritems())
       
    1:     @classmethod
           def from_httplib(cls, message):  # Python 2
               """Read headers from a Python 2 httplib message object."""
               # python2.7 does not expose a proper API for exporting multiheaders
               # efficiently. This function re-reads raw lines from the message
               # object and extracts the multiheaders properly.
               headers = []
       
               for line in message.headers:
                   if line.startswith((' ', '\t')):
                       key, value = headers[-1]
                       headers[-1] = (key, value + '\r\n' + line.rstrip())
                       continue
       
                   key, value = line.split(':', 1)
                   headers.append((key, value.strip()))
       
               return cls(headers)
