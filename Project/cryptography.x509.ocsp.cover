       # This file is dual licensed under the terms of the Apache License, Version
       # 2.0, and the BSD License. See the LICENSE file in the root of this repository
       # for complete details.
       
    1: from __future__ import absolute_import, division, print_function
       
    1: import abc
    1: import datetime
    1: from enum import Enum
       
    1: import six
       
    1: from cryptography import x509
    1: from cryptography.hazmat.primitives import hashes
    1: from cryptography.hazmat.primitives.asymmetric import ed25519, ed448
    1: from cryptography.x509.base import (
           _EARLIEST_UTC_TIME, _convert_to_naive_utc_time, _reject_duplicate_extension
       )
       
       
       _OIDS_TO_HASH = {
    1:     "1.3.14.3.2.26": hashes.SHA1(),
    1:     "2.16.840.1.101.3.4.2.4": hashes.SHA224(),
    1:     "2.16.840.1.101.3.4.2.1": hashes.SHA256(),
    1:     "2.16.840.1.101.3.4.2.2": hashes.SHA384(),
    1:     "2.16.840.1.101.3.4.2.3": hashes.SHA512(),
       }
       
       
    2: class OCSPResponderEncoding(Enum):
    1:     HASH = "By Hash"
    1:     NAME = "By Name"
       
       
    2: class OCSPResponseStatus(Enum):
    1:     SUCCESSFUL = 0
    1:     MALFORMED_REQUEST = 1
    1:     INTERNAL_ERROR = 2
    1:     TRY_LATER = 3
    1:     SIG_REQUIRED = 5
    1:     UNAUTHORIZED = 6
       
       
    8: _RESPONSE_STATUS_TO_ENUM = dict((x.value, x) for x in OCSPResponseStatus)
       _ALLOWED_HASHES = (
    1:     hashes.SHA1, hashes.SHA224, hashes.SHA256,
    1:     hashes.SHA384, hashes.SHA512
       )
       
       
    1: def _verify_algorithm(algorithm):
           if not isinstance(algorithm, _ALLOWED_HASHES):
               raise ValueError(
                   "Algorithm must be SHA1, SHA224, SHA256, SHA384, or SHA512"
               )
       
       
    2: class OCSPCertStatus(Enum):
    1:     GOOD = 0
    1:     REVOKED = 1
    1:     UNKNOWN = 2
       
       
    5: _CERT_STATUS_TO_ENUM = dict((x.value, x) for x in OCSPCertStatus)
       
       
    1: def load_der_ocsp_request(data):
           from cryptography.hazmat.backends.openssl.backend import backend
           return backend.load_der_ocsp_request(data)
       
       
    1: def load_der_ocsp_response(data):
           from cryptography.hazmat.backends.openssl.backend import backend
           return backend.load_der_ocsp_response(data)
       
       
    2: class OCSPRequestBuilder(object):
    1:     def __init__(self, request=None, extensions=[]):
               self._request = request
               self._extensions = extensions
       
    1:     def add_certificate(self, cert, issuer, algorithm):
               if self._request is not None:
                   raise ValueError("Only one certificate can be added to a request")
       
               _verify_algorithm(algorithm)
               if (
                   not isinstance(cert, x509.Certificate) or
                   not isinstance(issuer, x509.Certificate)
               ):
                   raise TypeError("cert and issuer must be a Certificate")
       
               return OCSPRequestBuilder((cert, issuer, algorithm), self._extensions)
       
    1:     def add_extension(self, extension, critical):
               if not isinstance(extension, x509.ExtensionType):
                   raise TypeError("extension must be an ExtensionType")
       
               extension = x509.Extension(extension.oid, critical, extension)
               _reject_duplicate_extension(extension, self._extensions)
       
               return OCSPRequestBuilder(
                   self._request, self._extensions + [extension]
               )
       
    1:     def build(self):
               from cryptography.hazmat.backends.openssl.backend import backend
               if self._request is None:
                   raise ValueError("You must add a certificate before building")
       
               return backend.create_ocsp_request(self)
       
       
    2: class _SingleResponse(object):
    1:     def __init__(self, cert, issuer, algorithm, cert_status, this_update,
                        next_update, revocation_time, revocation_reason):
               if (
                   not isinstance(cert, x509.Certificate) or
                   not isinstance(issuer, x509.Certificate)
               ):
                   raise TypeError("cert and issuer must be a Certificate")
       
               _verify_algorithm(algorithm)
               if not isinstance(this_update, datetime.datetime):
                   raise TypeError("this_update must be a datetime object")
               if (
                   next_update is not None and
                   not isinstance(next_update, datetime.datetime)
               ):
                   raise TypeError("next_update must be a datetime object or None")
       
               self._cert = cert
               self._issuer = issuer
               self._algorithm = algorithm
               self._this_update = this_update
               self._next_update = next_update
       
               if not isinstance(cert_status, OCSPCertStatus):
                   raise TypeError(
                       "cert_status must be an item from the OCSPCertStatus enum"
                   )
               if cert_status is not OCSPCertStatus.REVOKED:
                   if revocation_time is not None:
                       raise ValueError(
                           "revocation_time can only be provided if the certificate "
                           "is revoked"
                       )
                   if revocation_reason is not None:
                       raise ValueError(
                           "revocation_reason can only be provided if the certificate"
                           " is revoked"
                       )
               else:
                   if not isinstance(revocation_time, datetime.datetime):
                       raise TypeError("revocation_time must be a datetime object")
       
                   revocation_time = _convert_to_naive_utc_time(revocation_time)
                   if revocation_time < _EARLIEST_UTC_TIME:
                       raise ValueError('The revocation_time must be on or after'
                                        ' 1950 January 1.')
       
                   if (
                       revocation_reason is not None and
                       not isinstance(revocation_reason, x509.ReasonFlags)
                   ):
                       raise TypeError(
                           "revocation_reason must be an item from the ReasonFlags "
                           "enum or None"
                       )
       
               self._cert_status = cert_status
               self._revocation_time = revocation_time
               self._revocation_reason = revocation_reason
       
       
    2: class OCSPResponseBuilder(object):
    1:     def __init__(self, response=None, responder_id=None, certs=None,
    1:                  extensions=[]):
               self._response = response
               self._responder_id = responder_id
               self._certs = certs
               self._extensions = extensions
       
    1:     def add_response(self, cert, issuer, algorithm, cert_status, this_update,
                            next_update, revocation_time, revocation_reason):
               if self._response is not None:
                   raise ValueError("Only one response per OCSPResponse.")
       
               singleresp = _SingleResponse(
                   cert, issuer, algorithm, cert_status, this_update, next_update,
                   revocation_time, revocation_reason
               )
               return OCSPResponseBuilder(
                   singleresp, self._responder_id,
                   self._certs, self._extensions,
               )
       
    1:     def responder_id(self, encoding, responder_cert):
               if self._responder_id is not None:
                   raise ValueError("responder_id can only be set once")
               if not isinstance(responder_cert, x509.Certificate):
                   raise TypeError("responder_cert must be a Certificate")
               if not isinstance(encoding, OCSPResponderEncoding):
                   raise TypeError(
                       "encoding must be an element from OCSPResponderEncoding"
                   )
       
               return OCSPResponseBuilder(
                   self._response, (responder_cert, encoding),
                   self._certs, self._extensions,
               )
       
    1:     def certificates(self, certs):
               if self._certs is not None:
                   raise ValueError("certificates may only be set once")
               certs = list(certs)
               if len(certs) == 0:
                   raise ValueError("certs must not be an empty list")
               if not all(isinstance(x, x509.Certificate) for x in certs):
                   raise TypeError("certs must be a list of Certificates")
               return OCSPResponseBuilder(
                   self._response, self._responder_id,
                   certs, self._extensions,
               )
       
    1:     def add_extension(self, extension, critical):
               if not isinstance(extension, x509.ExtensionType):
                   raise TypeError("extension must be an ExtensionType")
       
               extension = x509.Extension(extension.oid, critical, extension)
               _reject_duplicate_extension(extension, self._extensions)
       
               return OCSPResponseBuilder(
                   self._response, self._responder_id,
                   self._certs, self._extensions + [extension],
               )
       
    1:     def sign(self, private_key, algorithm):
               from cryptography.hazmat.backends.openssl.backend import backend
               if self._response is None:
                   raise ValueError("You must add a response before signing")
               if self._responder_id is None:
                   raise ValueError("You must add a responder_id before signing")
       
               if isinstance(private_key,
                             (ed25519.Ed25519PrivateKey, ed448.Ed448PrivateKey)):
                   if algorithm is not None:
                       raise ValueError(
                           "algorithm must be None when signing via ed25519 or ed448"
                       )
               elif not isinstance(algorithm, hashes.HashAlgorithm):
                   raise TypeError("Algorithm must be a registered hash algorithm.")
       
               return backend.create_ocsp_response(
                   OCSPResponseStatus.SUCCESSFUL, self, private_key, algorithm
               )
       
    1:     @classmethod
           def build_unsuccessful(cls, response_status):
               from cryptography.hazmat.backends.openssl.backend import backend
               if not isinstance(response_status, OCSPResponseStatus):
                   raise TypeError(
                       "response_status must be an item from OCSPResponseStatus"
                   )
               if response_status is OCSPResponseStatus.SUCCESSFUL:
                   raise ValueError("response_status cannot be SUCCESSFUL")
       
               return backend.create_ocsp_response(response_status, None, None, None)
       
       
    2: @six.add_metaclass(abc.ABCMeta)
    1: class OCSPRequest(object):
    1:     @abc.abstractproperty
           def issuer_key_hash(self):
               """
               The hash of the issuer public key
               """
       
    1:     @abc.abstractproperty
           def issuer_name_hash(self):
               """
               The hash of the issuer name
               """
       
    1:     @abc.abstractproperty
           def hash_algorithm(self):
               """
               The hash algorithm used in the issuer name and key hashes
               """
       
    1:     @abc.abstractproperty
           def serial_number(self):
               """
               The serial number of the cert whose status is being checked
               """
    1:     @abc.abstractmethod
           def public_bytes(self, encoding):
               """
               Serializes the request to DER
               """
       
    1:     @abc.abstractproperty
           def extensions(self):
               """
               The list of request extensions. Not single request extensions.
               """
       
       
    2: @six.add_metaclass(abc.ABCMeta)
    1: class OCSPResponse(object):
    1:     @abc.abstractproperty
           def response_status(self):
               """
               The status of the response. This is a value from the OCSPResponseStatus
               enumeration
               """
       
    1:     @abc.abstractproperty
           def signature_algorithm_oid(self):
               """
               The ObjectIdentifier of the signature algorithm
               """
       
    1:     @abc.abstractproperty
           def signature_hash_algorithm(self):
               """
               Returns a HashAlgorithm corresponding to the type of the digest signed
               """
       
    1:     @abc.abstractproperty
           def signature(self):
               """
               The signature bytes
               """
       
    1:     @abc.abstractproperty
           def tbs_response_bytes(self):
               """
               The tbsResponseData bytes
               """
       
    1:     @abc.abstractproperty
           def certificates(self):
               """
               A list of certificates used to help build a chain to verify the OCSP
               response. This situation occurs when the OCSP responder uses a delegate
               certificate.
               """
       
    1:     @abc.abstractproperty
           def responder_key_hash(self):
               """
               The responder's key hash or None
               """
       
    1:     @abc.abstractproperty
           def responder_name(self):
               """
               The responder's Name or None
               """
       
    1:     @abc.abstractproperty
           def produced_at(self):
               """
               The time the response was produced
               """
       
    1:     @abc.abstractproperty
           def certificate_status(self):
               """
               The status of the certificate (an element from the OCSPCertStatus enum)
               """
       
    1:     @abc.abstractproperty
           def revocation_time(self):
               """
               The date of when the certificate was revoked or None if not
               revoked.
               """
       
    1:     @abc.abstractproperty
           def revocation_reason(self):
               """
               The reason the certificate was revoked or None if not specified or
               not revoked.
               """
       
    1:     @abc.abstractproperty
           def this_update(self):
               """
               The most recent time at which the status being indicated is known by
               the responder to have been correct
               """
       
    1:     @abc.abstractproperty
           def next_update(self):
               """
               The time when newer information will be available
               """
       
    1:     @abc.abstractproperty
           def issuer_key_hash(self):
               """
               The hash of the issuer public key
               """
       
    1:     @abc.abstractproperty
           def issuer_name_hash(self):
               """
               The hash of the issuer name
               """
       
    1:     @abc.abstractproperty
           def hash_algorithm(self):
               """
               The hash algorithm used in the issuer name and key hashes
               """
       
    1:     @abc.abstractproperty
           def serial_number(self):
               """
               The serial number of the cert whose status is being checked
               """
       
    1:     @abc.abstractproperty
           def extensions(self):
               """
               The list of response extensions. Not single response extensions.
               """
