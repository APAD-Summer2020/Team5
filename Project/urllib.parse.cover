       """Parse (absolute and relative) URLs.
       
       urlparse module is based upon the following RFC specifications.
       
       RFC 3986 (STD66): "Uniform Resource Identifiers" by T. Berners-Lee, R. Fielding
       and L.  Masinter, January 2005.
       
       RFC 2732 : "Format for Literal IPv6 Addresses in URL's by R.Hinden, B.Carpenter
       and L.Masinter, December 1999.
       
       RFC 2396:  "Uniform Resource Identifiers (URI)": Generic Syntax by T.
       Berners-Lee, R. Fielding, and L. Masinter, August 1998.
       
       RFC 2368: "The mailto URL scheme", by P.Hoffman , L Masinter, J. Zawinski, July 1998.
       
       RFC 1808: "Relative Uniform Resource Locators", by R. Fielding, UC Irvine, June
       1995.
       
       RFC 1738: "Uniform Resource Locators (URL)" by T. Berners-Lee, L. Masinter, M.
       McCahill, December 1994
       
       RFC 3986 is considered the current standard and any future changes to
       urlparse module should conform with it.  The urlparse module is
       currently not entirely compliant with this RFC due to defacto
       scenarios for parsing, and for backward compatibility purposes, some
       parsing quirks from older RFCs are retained. The testcases in
       test_urlparse.py provides a good indicator of parsing behavior.
    1: """
       
    1: import re
    1: import sys
    1: import collections
       
    1: __all__ = ["urlparse", "urlunparse", "urljoin", "urldefrag",
    1:            "urlsplit", "urlunsplit", "urlencode", "parse_qs",
    1:            "parse_qsl", "quote", "quote_plus", "quote_from_bytes",
    1:            "unquote", "unquote_plus", "unquote_to_bytes",
    1:            "DefragResult", "ParseResult", "SplitResult",
    1:            "DefragResultBytes", "ParseResultBytes", "SplitResultBytes"]
       
       # A classification of schemes.
       # The empty string classifies URLs with no scheme specified,
       # being the default value returned by “urlsplit” and “urlparse”.
       
    1: uses_relative = ['', 'ftp', 'http', 'gopher', 'nntp', 'imap',
    1:                  'wais', 'file', 'https', 'shttp', 'mms',
    1:                  'prospero', 'rtsp', 'rtspu', 'sftp',
    1:                  'svn', 'svn+ssh', 'ws', 'wss']
       
    1: uses_netloc = ['', 'ftp', 'http', 'gopher', 'nntp', 'telnet',
    1:                'imap', 'wais', 'file', 'mms', 'https', 'shttp',
    1:                'snews', 'prospero', 'rtsp', 'rtspu', 'rsync',
    1:                'svn', 'svn+ssh', 'sftp', 'nfs', 'git', 'git+ssh',
    1:                'ws', 'wss']
       
    1: uses_params = ['', 'ftp', 'hdl', 'prospero', 'http', 'imap',
    1:                'https', 'shttp', 'rtsp', 'rtspu', 'sip', 'sips',
    1:                'mms', 'sftp', 'tel']
       
       # These are not actually used anymore, but should stay for backwards
       # compatibility.  (They are undocumented, but have a public-looking name.)
       
    1: non_hierarchical = ['gopher', 'hdl', 'mailto', 'news',
    1:                     'telnet', 'wais', 'imap', 'snews', 'sip', 'sips']
       
    1: uses_query = ['', 'http', 'wais', 'imap', 'https', 'shttp', 'mms',
    1:               'gopher', 'rtsp', 'rtspu', 'sip', 'sips']
       
    1: uses_fragment = ['', 'ftp', 'hdl', 'http', 'gopher', 'news',
    1:                  'nntp', 'wais', 'https', 'shttp', 'snews',
    1:                  'file', 'prospero']
       
       # Characters valid in scheme names
    1: scheme_chars = ('abcdefghijklmnopqrstuvwxyz'
                       'ABCDEFGHIJKLMNOPQRSTUVWXYZ'
                       '0123456789'
                       '+-.')
       
       # XXX: Consider replacing with functools.lru_cache
    1: MAX_CACHE_SIZE = 20
    1: _parse_cache = {}
       
    1: def clear_cache():
           """Clear the parse cache and the quoters cache."""
           _parse_cache.clear()
           _safe_quoters.clear()
       
       
       # Helpers for bytes handling
       # For 3.2, we deliberately require applications that
       # handle improperly quoted URLs to do their own
       # decoding and encoding. If valid use cases are
       # presented, we may relax this by using latin-1
       # decoding internally for 3.3
    1: _implicit_encoding = 'ascii'
    1: _implicit_errors = 'strict'
       
    1: def _noop(obj):
   25:     return obj
       
    1: def _encode_result(obj, encoding=_implicit_encoding,
    1:                         errors=_implicit_errors):
           return obj.encode(encoding, errors)
       
    1: def _decode_args(args, encoding=_implicit_encoding,
    1:                        errors=_implicit_errors):
           return tuple(x.decode(encoding, errors) if x else '' for x in args)
       
    1: def _coerce_args(*args):
           # Invokes decode if necessary to create str args
           # and returns the coerced inputs along with
           # an appropriate result coercion function
           #   - noop for str inputs
           #   - encoding function otherwise
   25:     str_input = isinstance(args[0], str)
   64:     for arg in args[1:]:
               # We special-case the empty string to support the
               # "scheme=''" default argument to some functions
   39:         if arg and isinstance(arg, str) != str_input:
                   raise TypeError("Cannot mix str and non-str arguments")
   25:     if str_input:
   25:         return args + (_noop,)
           return _decode_args(args) + (_encode_result,)
       
       # Result objects are more helpful than simple tuples
    2: class _ResultMixinStr(object):
    1:     """Standard approach to encoding parsed results from str to bytes"""
    1:     __slots__ = ()
       
    1:     def encode(self, encoding='ascii', errors='strict'):
               return self._encoded_counterpart(*(x.encode(encoding, errors) for x in self))
       
       
    2: class _ResultMixinBytes(object):
    1:     """Standard approach to decoding parsed results from bytes to str"""
    1:     __slots__ = ()
       
    1:     def decode(self, encoding='ascii', errors='strict'):
               return self._decoded_counterpart(*(x.decode(encoding, errors) for x in self))
       
       
    2: class _NetlocResultMixinBase(object):
    1:     """Shared methods for the parsed result objects containing a netloc element"""
    1:     __slots__ = ()
       
    1:     @property
           def username(self):
    1:         return self._userinfo[0]
       
    1:     @property
           def password(self):
               return self._userinfo[1]
       
    1:     @property
           def hostname(self):
    6:         hostname = self._hostinfo[0]
    6:         if not hostname:
                   return None
               # Scoped IPv6 address may have zone info, which must not be lowercased
               # like http://[fe80::822a:a8ff:fe49:470c%tESt]:1234/keys
    6:         separator = '%' if isinstance(hostname, str) else b'%'
    6:         hostname, percent, zone = hostname.partition(separator)
    6:         return hostname.lower() + percent + zone
       
    1:     @property
           def port(self):
               port = self._hostinfo[1]
               if port is not None:
                   port = int(port, 10)
                   if not ( 0 <= port <= 65535):
                       raise ValueError("Port out of range 0-65535")
               return port
       
       
    2: class _NetlocResultMixinStr(_NetlocResultMixinBase, _ResultMixinStr):
    1:     __slots__ = ()
       
    1:     @property
           def _userinfo(self):
    1:         netloc = self.netloc
    1:         userinfo, have_info, hostinfo = netloc.rpartition('@')
    1:         if have_info:
                   username, have_password, password = userinfo.partition(':')
                   if not have_password:
                       password = None
               else:
    1:             username = password = None
    1:         return username, password
       
    1:     @property
           def _hostinfo(self):
    6:         netloc = self.netloc
    6:         _, _, hostinfo = netloc.rpartition('@')
    6:         _, have_open_br, bracketed = hostinfo.partition('[')
    6:         if have_open_br:
                   hostname, _, port = bracketed.partition(']')
                   _, _, port = port.partition(':')
               else:
    6:             hostname, _, port = hostinfo.partition(':')
    6:         if not port:
    6:             port = None
    6:         return hostname, port
       
       
    2: class _NetlocResultMixinBytes(_NetlocResultMixinBase, _ResultMixinBytes):
    1:     __slots__ = ()
       
    1:     @property
           def _userinfo(self):
               netloc = self.netloc
               userinfo, have_info, hostinfo = netloc.rpartition(b'@')
               if have_info:
                   username, have_password, password = userinfo.partition(b':')
                   if not have_password:
                       password = None
               else:
                   username = password = None
               return username, password
       
    1:     @property
           def _hostinfo(self):
               netloc = self.netloc
               _, _, hostinfo = netloc.rpartition(b'@')
               _, have_open_br, bracketed = hostinfo.partition(b'[')
               if have_open_br:
                   hostname, _, port = bracketed.partition(b']')
                   _, _, port = port.partition(b':')
               else:
                   hostname, _, port = hostinfo.partition(b':')
               if not port:
                   port = None
               return hostname, port
       
       
    1: from collections import namedtuple
       
    1: _DefragResultBase = namedtuple('DefragResult', 'url fragment')
    1: _SplitResultBase = namedtuple(
    1:     'SplitResult', 'scheme netloc path query fragment')
    1: _ParseResultBase = namedtuple(
    1:     'ParseResult', 'scheme netloc path params query fragment')
       
       _DefragResultBase.__doc__ = """
       DefragResult(url, fragment)
       
       A 2-tuple that contains the url without fragment identifier and the fragment
       identifier as a separate argument.
    1: """
       
    1: _DefragResultBase.url.__doc__ = """The URL with no fragment identifier."""
       
       _DefragResultBase.fragment.__doc__ = """
       Fragment identifier separated from URL, that allows indirect identification of a
       secondary resource by reference to a primary resource and additional identifying
       information.
    1: """
       
       _SplitResultBase.__doc__ = """
       SplitResult(scheme, netloc, path, query, fragment)
       
       A 5-tuple that contains the different components of a URL. Similar to
       ParseResult, but does not split params.
    1: """
       
    1: _SplitResultBase.scheme.__doc__ = """Specifies URL scheme for the request."""
       
       _SplitResultBase.netloc.__doc__ = """
       Network location where the request is made to.
    1: """
       
       _SplitResultBase.path.__doc__ = """
       The hierarchical path, such as the path to a file to download.
    1: """
       
       _SplitResultBase.query.__doc__ = """
       The query component, that contains non-hierarchical data, that along with data
       in path component, identifies a resource in the scope of URI's scheme and
       network location.
    1: """
       
       _SplitResultBase.fragment.__doc__ = """
       Fragment identifier, that allows indirect identification of a secondary resource
       by reference to a primary resource and additional identifying information.
    1: """
       
       _ParseResultBase.__doc__ = """
       ParseResult(scheme, netloc, path, params,  query, fragment)
       
       A 6-tuple that contains components of a parsed URL.
    1: """
       
    1: _ParseResultBase.scheme.__doc__ = _SplitResultBase.scheme.__doc__
    1: _ParseResultBase.netloc.__doc__ = _SplitResultBase.netloc.__doc__
    1: _ParseResultBase.path.__doc__ = _SplitResultBase.path.__doc__
       _ParseResultBase.params.__doc__ = """
       Parameters for last path element used to dereference the URI in order to provide
       access to perform some operation on the resource.
    1: """
       
    1: _ParseResultBase.query.__doc__ = _SplitResultBase.query.__doc__
    1: _ParseResultBase.fragment.__doc__ = _SplitResultBase.fragment.__doc__
       
       
       # For backwards compatibility, alias _NetlocResultMixinStr
       # ResultBase is no longer part of the documented API, but it is
       # retained since deprecating it isn't worth the hassle
    1: ResultBase = _NetlocResultMixinStr
       
       # Structured result objects for string data
    2: class DefragResult(_DefragResultBase, _ResultMixinStr):
    1:     __slots__ = ()
    1:     def geturl(self):
               if self.fragment:
                   return self.url + '#' + self.fragment
               else:
                   return self.url
       
    2: class SplitResult(_SplitResultBase, _NetlocResultMixinStr):
    1:     __slots__ = ()
    1:     def geturl(self):
               return urlunsplit(self)
       
    2: class ParseResult(_ParseResultBase, _NetlocResultMixinStr):
    1:     __slots__ = ()
    1:     def geturl(self):
    1:         return urlunparse(self)
       
       # Structured result objects for bytes data
    2: class DefragResultBytes(_DefragResultBase, _ResultMixinBytes):
    1:     __slots__ = ()
    1:     def geturl(self):
               if self.fragment:
                   return self.url + b'#' + self.fragment
               else:
                   return self.url
       
    2: class SplitResultBytes(_SplitResultBase, _NetlocResultMixinBytes):
    1:     __slots__ = ()
    1:     def geturl(self):
               return urlunsplit(self)
       
    2: class ParseResultBytes(_ParseResultBase, _NetlocResultMixinBytes):
    1:     __slots__ = ()
    1:     def geturl(self):
               return urlunparse(self)
       
       # Set up the encode/decode result pairs
    1: def _fix_result_transcoding():
           _result_pairs = (
    1:         (DefragResult, DefragResultBytes),
    1:         (SplitResult, SplitResultBytes),
    1:         (ParseResult, ParseResultBytes),
           )
    4:     for _decoded, _encoded in _result_pairs:
    3:         _decoded._encoded_counterpart = _encoded
    3:         _encoded._decoded_counterpart = _decoded
       
    1: _fix_result_transcoding()
    1: del _fix_result_transcoding
       
    1: def urlparse(url, scheme='', allow_fragments=True):
           """Parse a URL into 6 components:
           <scheme>://<netloc>/<path>;<params>?<query>#<fragment>
           Return a 6-tuple: (scheme, netloc, path, params, query, fragment).
           Note that we don't break the components up in smaller bits
           (e.g. netloc is a single string) and we don't expand % escapes."""
   10:     url, scheme, _coerce_result = _coerce_args(url, scheme)
   10:     splitresult = urlsplit(url, scheme, allow_fragments)
   10:     scheme, netloc, url, query, fragment = splitresult
   10:     if scheme in uses_params and ';' in url:
               url, params = _splitparams(url)
           else:
   10:         params = ''
   10:     result = ParseResult(scheme, netloc, url, params, query, fragment)
   10:     return _coerce_result(result)
       
    1: def _splitparams(url):
           if '/'  in url:
               i = url.find(';', url.rfind('/'))
               if i < 0:
                   return url, ''
           else:
               i = url.find(';')
           return url[:i], url[i+1:]
       
    1: def _splitnetloc(url, start=0):
    1:     delim = len(url)   # position of end of domain part of url, default is end
    4:     for c in '/?#':    # look for delimiters; the order is NOT important
    3:         wdelim = url.find(c, start)        # find first of this delim
    3:         if wdelim >= 0:                    # if found
    1:             delim = min(delim, wdelim)     # use earliest delim position
    1:     return url[start:delim], url[delim:]   # return (domain, rest)
       
    1: def _checknetloc(netloc):
    1:     if not netloc or netloc.isascii():
    1:         return
           # looking for characters like \u2100 that expand to 'a/c'
           # IDNA uses NFKC equivalence, so normalize for this check
           import unicodedata
           n = netloc.replace('@', '')   # ignore characters already included
           n = n.replace(':', '')        # but not the surrounding text
           n = n.replace('#', '')
           n = n.replace('?', '')
           netloc2 = unicodedata.normalize('NFKC', n)
           if n == netloc2:
               return
           for c in '/?#@:':
               if c in netloc2:
                   raise ValueError("netloc '" + netloc + "' contains invalid " +
                                    "characters under NFKC normalization")
       
    1: def urlsplit(url, scheme='', allow_fragments=True):
           """Parse a URL into 5 components:
           <scheme>://<netloc>/<path>?<query>#<fragment>
           Return a 5-tuple: (scheme, netloc, path, query, fragment).
           Note that we don't break the components up in smaller bits
           (e.g. netloc is a single string) and we don't expand % escapes."""
   11:     url, scheme, _coerce_result = _coerce_args(url, scheme)
   11:     allow_fragments = bool(allow_fragments)
   11:     key = url, scheme, allow_fragments, type(url), type(scheme)
   11:     cached = _parse_cache.get(key, None)
   11:     if cached:
   10:         return _coerce_result(cached)
    1:     if len(_parse_cache) >= MAX_CACHE_SIZE: # avoid runaway growth
               clear_cache()
    1:     netloc = query = fragment = ''
    1:     i = url.find(':')
    1:     if i > 0:
    6:         for c in url[:i]:
    5:             if c not in scheme_chars:
                       break
               else:
    1:             scheme, url = url[:i].lower(), url[i+1:]
       
    1:     if url[:2] == '//':
    1:         netloc, url = _splitnetloc(url, 2)
    1:         if (('[' in netloc and ']' not in netloc) or
    1:                 (']' in netloc and '[' not in netloc)):
                   raise ValueError("Invalid IPv6 URL")
    1:     if allow_fragments and '#' in url:
               url, fragment = url.split('#', 1)
    1:     if '?' in url:
               url, query = url.split('?', 1)
    1:     _checknetloc(netloc)
    1:     v = SplitResult(scheme, netloc, url, query, fragment)
    1:     _parse_cache[key] = v
    1:     return _coerce_result(v)
       
    1: def urlunparse(components):
           """Put a parsed URL back together again.  This may result in a
           slightly different, but equivalent URL, if the URL that was parsed
           originally had redundant delimiters, e.g. a ? with an empty query
           (the draft states that these are equivalent)."""
           scheme, netloc, url, params, query, fragment, _coerce_result = (
    2:                                                   _coerce_args(*components))
    2:     if params:
               url = "%s;%s" % (url, params)
    2:     return _coerce_result(urlunsplit((scheme, netloc, url, query, fragment)))
       
    1: def urlunsplit(components):
           """Combine the elements of a tuple as returned by urlsplit() into a
           complete URL as a string. The data argument can be any five-item iterable.
           This may result in a slightly different, but equivalent URL, if the URL that
           was parsed originally had unnecessary delimiters (for example, a ? with an
           empty query; the RFC states that these are equivalent)."""
           scheme, netloc, url, query, fragment, _coerce_result = (
    2:                                           _coerce_args(*components))
    2:     if netloc or (scheme and scheme in uses_netloc and url[:2] != '//'):
    2:         if url and url[:1] != '/': url = '/' + url
    2:         url = '//' + (netloc or '') + url
    2:     if scheme:
    2:         url = scheme + ':' + url
    2:     if query:
               url = url + '?' + query
    2:     if fragment:
               url = url + '#' + fragment
    2:     return _coerce_result(url)
       
    1: def urljoin(base, url, allow_fragments=True):
           """Join a base URL and a possibly relative URL to form an absolute
           interpretation of the latter."""
           if not base:
               return url
           if not url:
               return base
       
           base, url, _coerce_result = _coerce_args(base, url)
           bscheme, bnetloc, bpath, bparams, bquery, bfragment = \
                   urlparse(base, '', allow_fragments)
           scheme, netloc, path, params, query, fragment = \
                   urlparse(url, bscheme, allow_fragments)
       
           if scheme != bscheme or scheme not in uses_relative:
               return _coerce_result(url)
           if scheme in uses_netloc:
               if netloc:
                   return _coerce_result(urlunparse((scheme, netloc, path,
                                                     params, query, fragment)))
               netloc = bnetloc
       
           if not path and not params:
               path = bpath
               params = bparams
               if not query:
                   query = bquery
               return _coerce_result(urlunparse((scheme, netloc, path,
                                                 params, query, fragment)))
       
           base_parts = bpath.split('/')
           if base_parts[-1] != '':
               # the last item is not a directory, so will not be taken into account
               # in resolving the relative path
               del base_parts[-1]
       
           # for rfc3986, ignore all base path should the first character be root.
           if path[:1] == '/':
               segments = path.split('/')
           else:
               segments = base_parts + path.split('/')
               # filter out elements that would cause redundant slashes on re-joining
               # the resolved_path
               segments[1:-1] = filter(None, segments[1:-1])
       
           resolved_path = []
       
           for seg in segments:
               if seg == '..':
                   try:
                       resolved_path.pop()
                   except IndexError:
                       # ignore any .. segments that would otherwise cause an IndexError
                       # when popped from resolved_path if resolving for rfc3986
                       pass
               elif seg == '.':
                   continue
               else:
                   resolved_path.append(seg)
       
           if segments[-1] in ('.', '..'):
               # do some post-processing here. if the last segment was a relative dir,
               # then we need to append the trailing '/'
               resolved_path.append('')
       
           return _coerce_result(urlunparse((scheme, netloc, '/'.join(
               resolved_path) or '/', params, query, fragment)))
       
       
    1: def urldefrag(url):
           """Removes any existing fragment from URL.
       
           Returns a tuple of the defragmented URL and the fragment.  If
           the URL contained no fragments, the second element is the
           empty string.
           """
           url, _coerce_result = _coerce_args(url)
           if '#' in url:
               s, n, p, a, q, frag = urlparse(url)
               defrag = urlunparse((s, n, p, a, q, ''))
           else:
               frag = ''
               defrag = url
           return _coerce_result(DefragResult(defrag, frag))
       
    1: _hexdig = '0123456789ABCDEFabcdef'
    1: _hextobyte = None
       
    1: def unquote_to_bytes(string):
           """unquote_to_bytes('abc%20def') -> b'abc def'."""
           # Note: strings are encoded as UTF-8. This is only an issue if it contains
           # unescaped non-ASCII characters, which URIs should not.
           if not string:
               # Is it a string-like object?
               string.split
               return b''
           if isinstance(string, str):
               string = string.encode('utf-8')
           bits = string.split(b'%')
           if len(bits) == 1:
               return string
           res = [bits[0]]
           append = res.append
           # Delay the initialization of the table to not waste memory
           # if the function is never called
           global _hextobyte
           if _hextobyte is None:
               _hextobyte = {(a + b).encode(): bytes.fromhex(a + b)
                             for a in _hexdig for b in _hexdig}
           for item in bits[1:]:
               try:
                   append(_hextobyte[item[:2]])
                   append(item[2:])
               except KeyError:
                   append(b'%')
                   append(item)
           return b''.join(res)
       
    1: _asciire = re.compile('([\x00-\x7f]+)')
       
    1: def unquote(string, encoding='utf-8', errors='replace'):
           """Replace %xx escapes by their single-character equivalent. The optional
           encoding and errors parameters specify how to decode percent-encoded
           sequences into Unicode characters, as accepted by the bytes.decode()
           method.
           By default, percent-encoded sequences are decoded with UTF-8, and invalid
           sequences are replaced by a placeholder character.
       
           unquote('abc%20def') -> 'abc def'.
           """
    1:     if '%' not in string:
               string.split
               return string
           if encoding is None:
               encoding = 'utf-8'
           if errors is None:
               errors = 'replace'
           bits = _asciire.split(string)
           res = [bits[0]]
           append = res.append
           for i in range(1, len(bits), 2):
               append(unquote_to_bytes(bits[i]).decode(encoding, errors))
               append(bits[i + 1])
           return ''.join(res)
       
       
       def parse_qs(qs, keep_blank_values=False, strict_parsing=False,
    1:              encoding='utf-8', errors='replace', max_num_fields=None):
           """Parse a query given as a string argument.
       
               Arguments:
       
               qs: percent-encoded query string to be parsed
       
               keep_blank_values: flag indicating whether blank values in
                   percent-encoded queries should be treated as blank strings.
                   A true value indicates that blanks should be retained as
                   blank strings.  The default false value indicates that
                   blank values are to be ignored and treated as if they were
                   not included.
       
               strict_parsing: flag indicating what to do with parsing errors.
                   If false (the default), errors are silently ignored.
                   If true, errors raise a ValueError exception.
       
               encoding and errors: specify how to decode percent-encoded sequences
                   into Unicode characters, as accepted by the bytes.decode() method.
       
               max_num_fields: int. If set, then throws a ValueError if there
                   are more than n fields read by parse_qsl().
       
               Returns a dictionary.
           """
           parsed_result = {}
           pairs = parse_qsl(qs, keep_blank_values, strict_parsing,
                             encoding=encoding, errors=errors,
                             max_num_fields=max_num_fields)
           for name, value in pairs:
               if name in parsed_result:
                   parsed_result[name].append(value)
               else:
                   parsed_result[name] = [value]
           return parsed_result
       
       
       def parse_qsl(qs, keep_blank_values=False, strict_parsing=False,
    1:               encoding='utf-8', errors='replace', max_num_fields=None):
           """Parse a query given as a string argument.
       
               Arguments:
       
               qs: percent-encoded query string to be parsed
       
               keep_blank_values: flag indicating whether blank values in
                   percent-encoded queries should be treated as blank strings.
                   A true value indicates that blanks should be retained as blank
                   strings.  The default false value indicates that blank values
                   are to be ignored and treated as if they were  not included.
       
               strict_parsing: flag indicating what to do with parsing errors. If
                   false (the default), errors are silently ignored. If true,
                   errors raise a ValueError exception.
       
               encoding and errors: specify how to decode percent-encoded sequences
                   into Unicode characters, as accepted by the bytes.decode() method.
       
               max_num_fields: int. If set, then throws a ValueError
                   if there are more than n fields read by parse_qsl().
       
               Returns a list, as G-d intended.
           """
           qs, _coerce_result = _coerce_args(qs)
       
           # If max_num_fields is defined then check that the number of fields
           # is less than max_num_fields. This prevents a memory exhaustion DOS
           # attack via post bodies with many fields.
           if max_num_fields is not None:
               num_fields = 1 + qs.count('&') + qs.count(';')
               if max_num_fields < num_fields:
                   raise ValueError('Max number of fields exceeded')
       
           pairs = [s2 for s1 in qs.split('&') for s2 in s1.split(';')]
           r = []
           for name_value in pairs:
               if not name_value and not strict_parsing:
                   continue
               nv = name_value.split('=', 1)
               if len(nv) != 2:
                   if strict_parsing:
                       raise ValueError("bad query field: %r" % (name_value,))
                   # Handle case of a control-name with no equal sign
                   if keep_blank_values:
                       nv.append('')
                   else:
                       continue
               if len(nv[1]) or keep_blank_values:
                   name = nv[0].replace('+', ' ')
                   name = unquote(name, encoding=encoding, errors=errors)
                   name = _coerce_result(name)
                   value = nv[1].replace('+', ' ')
                   value = unquote(value, encoding=encoding, errors=errors)
                   value = _coerce_result(value)
                   r.append((name, value))
           return r
       
    1: def unquote_plus(string, encoding='utf-8', errors='replace'):
           """Like unquote(), but also replace plus signs by spaces, as required for
           unquoting HTML form values.
       
           unquote_plus('%7e/abc+def') -> '~/abc def'
           """
           string = string.replace('+', ' ')
           return unquote(string, encoding, errors)
       
    1: _ALWAYS_SAFE = frozenset(b'ABCDEFGHIJKLMNOPQRSTUVWXYZ'
                                b'abcdefghijklmnopqrstuvwxyz'
                                b'0123456789'
                                b'_.-~')
    1: _ALWAYS_SAFE_BYTES = bytes(_ALWAYS_SAFE)
    1: _safe_quoters = {}
       
    2: class Quoter(collections.defaultdict):
           """A mapping from bytes (in range(0,256)) to strings.
       
           String values are percent-encoded byte values, unless the key < 128, and
           in the "safe" set (either the specified safe set, or default set).
    1:     """
           # Keeps a cache internally, using defaultdict, for efficiency (lookups
           # of cached keys don't call Python code at all).
    1:     def __init__(self, safe):
               """safe: bytes object."""
    2:         self.safe = _ALWAYS_SAFE.union(safe)
       
    1:     def __repr__(self):
               # Without this, will just display as a defaultdict
               return "<%s %r>" % (self.__class__.__name__, dict(self))
       
    1:     def __missing__(self, b):
               # Handle a cache miss. Store quoted string in cache and return.
   40:         res = chr(b) if b in self.safe else '%{:02X}'.format(b)
   40:         self[b] = res
   40:         return res
       
    1: def quote(string, safe='/', encoding=None, errors=None):
           """quote('abc def') -> 'abc%20def'
       
           Each part of a URL, e.g. the path info, the query, etc., has a
           different set of reserved characters that must be quoted. The
           quote function offers a cautious (not minimal) way to quote a
           string for most of these parts.
       
           RFC 3986 Uniform Resource Identifier (URI): Generic Syntax lists
           the following (un)reserved characters.
       
           unreserved    = ALPHA / DIGIT / "-" / "." / "_" / "~"
           reserved      = gen-delims / sub-delims
           gen-delims    = ":" / "/" / "?" / "#" / "[" / "]" / "@"
           sub-delims    = "!" / "$" / "&" / "'" / "(" / ")"
                         / "*" / "+" / "," / ";" / "="
       
           Each of the reserved characters is reserved in some component of a URL,
           but not necessarily in all of them.
       
           The quote function %-escapes all characters that are neither in the
           unreserved chars ("always safe") nor the additional chars set via the
           safe arg.
       
           The default for the safe arg is '/'. The character is reserved, but in
           typical usage the quote function is being called on a path where the
           existing slash characters are to be preserved.
       
           Python 3.7 updates from using RFC 2396 to RFC 3986 to quote URL strings.
           Now, "~" is included in the set of unreserved characters.
       
           string and safe may be either str or bytes objects. encoding and errors
           must not be specified if string is a bytes object.
       
           The optional encoding and errors parameters specify how to deal with
           non-ASCII characters, as accepted by the str.encode method.
           By default, encoding='utf-8' (characters are encoded with UTF-8), and
           errors='strict' (unsupported characters raise a UnicodeEncodeError).
           """
    9:     if isinstance(string, str):
    8:         if not string:
                   return string
    8:         if encoding is None:
    8:             encoding = 'utf-8'
    8:         if errors is None:
    8:             errors = 'strict'
    8:         string = string.encode(encoding, errors)
           else:
    1:         if encoding is not None:
                   raise TypeError("quote() doesn't support 'encoding' for bytes")
    1:         if errors is not None:
                   raise TypeError("quote() doesn't support 'errors' for bytes")
    9:     return quote_from_bytes(string, safe)
       
    1: def quote_plus(string, safe='', encoding=None, errors=None):
           """Like quote(), but also replace ' ' with '+', as required for quoting
           HTML form values. Plus signs in the original string are escaped unless
           they are included in safe. It also does not have safe default to '/'.
           """
           # Check if ' ' in string, where string may either be a str or bytes.  If
           # there are no spaces, the regular quote will produce the right answer.
    8:     if ((isinstance(string, str) and ' ' not in string) or
    1:         (isinstance(string, bytes) and b' ' not in string)):
    8:         return quote(string, safe, encoding, errors)
           if isinstance(safe, str):
               space = ' '
           else:
               space = b' '
           string = quote(string, safe + space, encoding, errors)
           return string.replace(' ', '+')
       
    1: def quote_from_bytes(bs, safe='/'):
           """Like quote(), but accepts a bytes object rather than a str, and does
           not perform string-to-bytes encoding.  It always returns an ASCII string.
           quote_from_bytes(b'abc def\x3f') -> 'abc%20def%3f'
           """
    9:     if not isinstance(bs, (bytes, bytearray)):
               raise TypeError("quote_from_bytes() expected bytes")
    9:     if not bs:
               return ''
    9:     if isinstance(safe, str):
               # Normalize 'safe' by converting to bytes and removing non-ASCII chars
    9:         safe = safe.encode('ascii', 'ignore')
           else:
               safe = bytes([c for c in safe if c < 128])
    9:     if not bs.rstrip(_ALWAYS_SAFE_BYTES + safe):
    6:         return bs.decode()
    3:     try:
    3:         quoter = _safe_quoters[safe]
    2:     except KeyError:
    2:         _safe_quoters[safe] = quoter = Quoter(safe).__getitem__
  127:     return ''.join([quoter(char) for char in bs])
       
    1: def urlencode(query, doseq=False, safe='', encoding=None, errors=None,
    1:               quote_via=quote_plus):
           """Encode a dict or sequence of two-element tuples into a URL query string.
       
           If any values in the query arg are sequences and doseq is true, each
           sequence element is converted to a separate parameter.
       
           If the query arg is a sequence of two-element tuples, the order of the
           parameters in the output will match the order of parameters in the
           input.
       
           The components of a query arg may each be either a string or a bytes type.
       
           The safe, encoding, and errors parameters are passed down to the function
           specified by quote_via (encoding and errors only if a component is a str).
           """
       
    4:     if hasattr(query, "items"):
    1:         query = query.items()
           else:
               # It's a bother at times that strings and string-like objects are
               # sequences.
    3:         try:
                   # non-sequence items should not work with len()
                   # non-empty strings will fail this
    3:             if len(query) and not isinstance(query[0], tuple):
                       raise TypeError
                   # Zero-length sequences of all types will get here and succeed,
                   # but that's a minor nit.  Since the original implementation
                   # allowed empty dicts that type of behavior probably should be
                   # preserved for consistency
               except TypeError:
                   ty, va, tb = sys.exc_info()
                   raise TypeError("not a valid non-string sequence "
                                   "or mapping object").with_traceback(tb)
       
    4:     l = []
    4:     if not doseq:
    7:         for k, v in query:
    4:             if isinstance(k, bytes):
                       k = quote_via(k, safe)
                   else:
    4:                 k = quote_via(str(k), safe, encoding, errors)
       
    4:             if isinstance(v, bytes):
    1:                 v = quote_via(v, safe)
                   else:
    3:                 v = quote_via(str(v), safe, encoding, errors)
    4:             l.append(k + '=' + v)
           else:
    1:         for k, v in query:
                   if isinstance(k, bytes):
                       k = quote_via(k, safe)
                   else:
                       k = quote_via(str(k), safe, encoding, errors)
       
                   if isinstance(v, bytes):
                       v = quote_via(v, safe)
                       l.append(k + '=' + v)
                   elif isinstance(v, str):
                       v = quote_via(v, safe, encoding, errors)
                       l.append(k + '=' + v)
                   else:
                       try:
                           # Is this a sufficient test for sequence-ness?
                           x = len(v)
                       except TypeError:
                           # not a sequence
                           v = quote_via(str(v), safe, encoding, errors)
                           l.append(k + '=' + v)
                       else:
                           # loop over the sequence
                           for elt in v:
                               if isinstance(elt, bytes):
                                   elt = quote_via(elt, safe)
                               else:
                                   elt = quote_via(str(elt), safe, encoding, errors)
                               l.append(k + '=' + elt)
    4:     return '&'.join(l)
       
    1: def to_bytes(url):
           """to_bytes(u"URL") --> 'URL'."""
           # Most URL schemes require ASCII. If that changes, the conversion
           # can be relaxed.
           # XXX get rid of to_bytes()
           if isinstance(url, str):
               try:
                   url = url.encode("ASCII").decode()
               except UnicodeError:
                   raise UnicodeError("URL " + repr(url) +
                                      " contains non-ASCII characters")
           return url
       
    1: def unwrap(url):
           """unwrap('<URL:type://host/path>') --> 'type://host/path'."""
           url = str(url).strip()
           if url[:1] == '<' and url[-1:] == '>':
               url = url[1:-1].strip()
           if url[:4] == 'URL:': url = url[4:].strip()
           return url
       
    1: _typeprog = None
    1: def splittype(url):
           """splittype('type:opaquestring') --> 'type', 'opaquestring'."""
           global _typeprog
           if _typeprog is None:
               _typeprog = re.compile('([^/:]+):(.*)', re.DOTALL)
       
           match = _typeprog.match(url)
           if match:
               scheme, data = match.groups()
               return scheme.lower(), data
           return None, url
       
    1: _hostprog = None
    1: def splithost(url):
           """splithost('//host[:port]/path') --> 'host[:port]', '/path'."""
           global _hostprog
           if _hostprog is None:
               _hostprog = re.compile('//([^/#?]*)(.*)', re.DOTALL)
       
           match = _hostprog.match(url)
           if match:
               host_port, path = match.groups()
               if path and path[0] != '/':
                   path = '/' + path
               return host_port, path
           return None, url
       
    1: def splituser(host):
           """splituser('user[:passwd]@host[:port]') --> 'user[:passwd]', 'host[:port]'."""
           user, delim, host = host.rpartition('@')
           return (user if delim else None), host
       
    1: def splitpasswd(user):
           """splitpasswd('user:passwd') -> 'user', 'passwd'."""
           user, delim, passwd = user.partition(':')
           return user, (passwd if delim else None)
       
       # splittag('/path#tag') --> '/path', 'tag'
    1: _portprog = None
    1: def splitport(host):
           """splitport('host:port') --> 'host', 'port'."""
           global _portprog
    1:     if _portprog is None:
    1:         _portprog = re.compile('(.*):([0-9]*)$', re.DOTALL)
       
    1:     match = _portprog.match(host)
    1:     if match:
               host, port = match.groups()
               if port:
                   return host, port
    1:     return host, None
       
    1: def splitnport(host, defport=-1):
           """Split host and port, returning numeric port.
           Return given default port if no ':' found; defaults to -1.
           Return numerical port if a valid number are found after ':'.
           Return None if ':' but not a valid number."""
           host, delim, port = host.rpartition(':')
           if not delim:
               host = port
           elif port:
               try:
                   nport = int(port)
               except ValueError:
                   nport = None
               return host, nport
           return host, defport
       
    1: def splitquery(url):
           """splitquery('/path?query') --> '/path', 'query'."""
           path, delim, query = url.rpartition('?')
           if delim:
               return path, query
           return url, None
       
    1: def splittag(url):
           """splittag('/path#tag') --> '/path', 'tag'."""
           path, delim, tag = url.rpartition('#')
           if delim:
               return path, tag
           return url, None
       
    1: def splitattr(url):
           """splitattr('/path;attr1=value1;attr2=value2;...') ->
               '/path', ['attr1=value1', 'attr2=value2', ...]."""
           words = url.split(';')
           return words[0], words[1:]
       
    1: def splitvalue(attr):
           """splitvalue('attr=value') --> 'attr', 'value'."""
           attr, delim, value = attr.partition('=')
           return attr, (value if delim else None)
