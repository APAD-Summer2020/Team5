       # This file is dual licensed under the terms of the Apache License, Version
       # 2.0, and the BSD License. See the LICENSE file in the root of this repository
       # for complete details.
       
    1: from __future__ import absolute_import, division, print_function
       
    1: import abc
    1: import ipaddress
    1: import warnings
    1: from email.utils import parseaddr
       
    1: import six
    1: from six.moves import urllib_parse
       
    1: from cryptography import utils
    1: from cryptography.x509.name import Name
    1: from cryptography.x509.oid import ObjectIdentifier
       
       
       _GENERAL_NAMES = {
    1:     0: "otherName",
    1:     1: "rfc822Name",
    1:     2: "dNSName",
    1:     3: "x400Address",
    1:     4: "directoryName",
    1:     5: "ediPartyName",
    1:     6: "uniformResourceIdentifier",
    1:     7: "iPAddress",
    1:     8: "registeredID",
       }
       
       
    1: def _lazy_import_idna():
           # Import idna lazily becase it allocates a decent amount of memory, and
           # we're only using it in deprecated paths.
           try:
               import idna
               return idna
           except ImportError:
               raise ImportError(
                   "idna is not installed, but a deprecated feature that requires it"
                   " was used. See: https://cryptography.io/en/latest/faq/#importe"
                   "rror-idna-is-not-installed"
               )
       
       
    2: class UnsupportedGeneralNameType(Exception):
    1:     def __init__(self, msg, type):
               super(UnsupportedGeneralNameType, self).__init__(msg)
               self.type = type
       
       
    2: @six.add_metaclass(abc.ABCMeta)
    1: class GeneralName(object):
    1:     @abc.abstractproperty
           def value(self):
               """
               Return the value of the object
               """
       
       
    2: @utils.register_interface(GeneralName)
    1: class RFC822Name(object):
    1:     def __init__(self, value):
               if isinstance(value, six.text_type):
                   try:
                       value.encode("ascii")
                   except UnicodeEncodeError:
                       value = self._idna_encode(value)
                       warnings.warn(
                           "RFC822Name values should be passed as an A-label string. "
                           "This means unicode characters should be encoded via "
                           "idna. Support for passing unicode strings (aka U-label) "
                           "will be removed in a future version.",
                           utils.PersistentlyDeprecated2017,
                           stacklevel=2,
                       )
               else:
                   raise TypeError("value must be string")
       
               name, address = parseaddr(value)
               if name or not address:
                   # parseaddr has found a name (e.g. Name <email>) or the entire
                   # value is an empty string.
                   raise ValueError("Invalid rfc822name value")
       
               self._value = value
       
    1:     value = utils.read_only_property("_value")
       
    1:     @classmethod
           def _init_without_validation(cls, value):
               instance = cls.__new__(cls)
               instance._value = value
               return instance
       
    1:     def _idna_encode(self, value):
               idna = _lazy_import_idna()
               _, address = parseaddr(value)
               parts = address.split(u"@")
               return parts[0] + "@" + idna.encode(parts[1]).decode("ascii")
       
    1:     def __repr__(self):
               return "<RFC822Name(value={0!r})>".format(self.value)
       
    1:     def __eq__(self, other):
               if not isinstance(other, RFC822Name):
                   return NotImplemented
       
               return self.value == other.value
       
    1:     def __ne__(self, other):
               return not self == other
       
    1:     def __hash__(self):
               return hash(self.value)
       
       
    1: def _idna_encode(value):
           idna = _lazy_import_idna()
           # Retain prefixes '*.' for common/alt names and '.' for name constraints
           for prefix in ['*.', '.']:
               if value.startswith(prefix):
                   value = value[len(prefix):]
                   return prefix + idna.encode(value).decode("ascii")
           return idna.encode(value).decode("ascii")
       
       
    2: @utils.register_interface(GeneralName)
    1: class DNSName(object):
    1:     def __init__(self, value):
               if isinstance(value, six.text_type):
                   try:
                       value.encode("ascii")
                   except UnicodeEncodeError:
                       value = _idna_encode(value)
                       warnings.warn(
                           "DNSName values should be passed as an A-label string. "
                           "This means unicode characters should be encoded via "
                           "idna. Support for passing unicode strings (aka U-label) "
                           "will be removed in a future version.",
                           utils.PersistentlyDeprecated2017,
                           stacklevel=2,
                       )
               else:
                   raise TypeError("value must be string")
       
               self._value = value
       
    1:     value = utils.read_only_property("_value")
       
    1:     @classmethod
           def _init_without_validation(cls, value):
               instance = cls.__new__(cls)
               instance._value = value
               return instance
       
    1:     def __repr__(self):
               return "<DNSName(value={0!r})>".format(self.value)
       
    1:     def __eq__(self, other):
               if not isinstance(other, DNSName):
                   return NotImplemented
       
               return self.value == other.value
       
    1:     def __ne__(self, other):
               return not self == other
       
    1:     def __hash__(self):
               return hash(self.value)
       
       
    2: @utils.register_interface(GeneralName)
    1: class UniformResourceIdentifier(object):
    1:     def __init__(self, value):
               if isinstance(value, six.text_type):
                   try:
                       value.encode("ascii")
                   except UnicodeEncodeError:
                       value = self._idna_encode(value)
                       warnings.warn(
                           "URI values should be passed as an A-label string. "
                           "This means unicode characters should be encoded via "
                           "idna. Support for passing unicode strings (aka U-label) "
                           " will be removed in a future version.",
                           utils.PersistentlyDeprecated2017,
                           stacklevel=2,
                       )
               else:
                   raise TypeError("value must be string")
       
               self._value = value
       
    1:     value = utils.read_only_property("_value")
       
    1:     @classmethod
           def _init_without_validation(cls, value):
               instance = cls.__new__(cls)
               instance._value = value
               return instance
       
    1:     def _idna_encode(self, value):
               idna = _lazy_import_idna()
               parsed = urllib_parse.urlparse(value)
               if parsed.port:
                   netloc = (
                       idna.encode(parsed.hostname) +
                       ":{}".format(parsed.port).encode("ascii")
                   ).decode("ascii")
               else:
                   netloc = idna.encode(parsed.hostname).decode("ascii")
       
               # Note that building a URL in this fashion means it should be
               # semantically indistinguishable from the original but is not
               # guaranteed to be exactly the same.
               return urllib_parse.urlunparse((
                   parsed.scheme,
                   netloc,
                   parsed.path,
                   parsed.params,
                   parsed.query,
                   parsed.fragment
               ))
       
    1:     def __repr__(self):
               return "<UniformResourceIdentifier(value={0!r})>".format(self.value)
       
    1:     def __eq__(self, other):
               if not isinstance(other, UniformResourceIdentifier):
                   return NotImplemented
       
               return self.value == other.value
       
    1:     def __ne__(self, other):
               return not self == other
       
    1:     def __hash__(self):
               return hash(self.value)
       
       
    2: @utils.register_interface(GeneralName)
    1: class DirectoryName(object):
    1:     def __init__(self, value):
               if not isinstance(value, Name):
                   raise TypeError("value must be a Name")
       
               self._value = value
       
    1:     value = utils.read_only_property("_value")
       
    1:     def __repr__(self):
               return "<DirectoryName(value={})>".format(self.value)
       
    1:     def __eq__(self, other):
               if not isinstance(other, DirectoryName):
                   return NotImplemented
       
               return self.value == other.value
       
    1:     def __ne__(self, other):
               return not self == other
       
    1:     def __hash__(self):
               return hash(self.value)
       
       
    2: @utils.register_interface(GeneralName)
    1: class RegisteredID(object):
    1:     def __init__(self, value):
               if not isinstance(value, ObjectIdentifier):
                   raise TypeError("value must be an ObjectIdentifier")
       
               self._value = value
       
    1:     value = utils.read_only_property("_value")
       
    1:     def __repr__(self):
               return "<RegisteredID(value={})>".format(self.value)
       
    1:     def __eq__(self, other):
               if not isinstance(other, RegisteredID):
                   return NotImplemented
       
               return self.value == other.value
       
    1:     def __ne__(self, other):
               return not self == other
       
    1:     def __hash__(self):
               return hash(self.value)
       
       
    2: @utils.register_interface(GeneralName)
    1: class IPAddress(object):
    1:     def __init__(self, value):
               if not isinstance(
                   value,
                   (
                       ipaddress.IPv4Address,
                       ipaddress.IPv6Address,
                       ipaddress.IPv4Network,
                       ipaddress.IPv6Network
                   )
               ):
                   raise TypeError(
                       "value must be an instance of ipaddress.IPv4Address, "
                       "ipaddress.IPv6Address, ipaddress.IPv4Network, or "
                       "ipaddress.IPv6Network"
                   )
       
               self._value = value
       
    1:     value = utils.read_only_property("_value")
       
    1:     def __repr__(self):
               return "<IPAddress(value={})>".format(self.value)
       
    1:     def __eq__(self, other):
               if not isinstance(other, IPAddress):
                   return NotImplemented
       
               return self.value == other.value
       
    1:     def __ne__(self, other):
               return not self == other
       
    1:     def __hash__(self):
               return hash(self.value)
       
       
    2: @utils.register_interface(GeneralName)
    1: class OtherName(object):
    1:     def __init__(self, type_id, value):
               if not isinstance(type_id, ObjectIdentifier):
                   raise TypeError("type_id must be an ObjectIdentifier")
               if not isinstance(value, bytes):
                   raise TypeError("value must be a binary string")
       
               self._type_id = type_id
               self._value = value
       
    1:     type_id = utils.read_only_property("_type_id")
    1:     value = utils.read_only_property("_value")
       
    1:     def __repr__(self):
               return "<OtherName(type_id={}, value={!r})>".format(
                   self.type_id, self.value)
       
    1:     def __eq__(self, other):
               if not isinstance(other, OtherName):
                   return NotImplemented
       
               return self.type_id == other.type_id and self.value == other.value
       
    1:     def __ne__(self, other):
               return not self == other
       
    1:     def __hash__(self):
               return hash((self.type_id, self.value))
