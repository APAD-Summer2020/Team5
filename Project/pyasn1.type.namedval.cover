       #
       # This file is part of pyasn1 software.
       #
       # Copyright (c) 2005-2019, Ilya Etingof <etingof@gmail.com>
       # License: http://snmplabs.com/pyasn1/license.html
       #
       # ASN.1 named integers
       #
    1: from pyasn1 import error
       
    1: __all__ = ['NamedValues']
       
       
    2: class NamedValues(object):
           """Create named values object.
       
           The |NamedValues| object represents a collection of string names
           associated with numeric IDs. These objects are used for giving
           names to otherwise numerical values.
       
           |NamedValues| objects are immutable and duck-type Python
           :class:`dict` object mapping ID to name and vice-versa.
       
           Parameters
           ----------
           *args: variable number of two-element :py:class:`tuple`
       
               name: :py:class:`str`
                   Value label
       
               value: :py:class:`int`
                   Numeric value
       
           Keyword Args
           ------------
           name: :py:class:`str`
               Value label
       
           value: :py:class:`int`
               Numeric value
       
           Examples
           --------
       
           .. code-block:: pycon
       
               >>> nv = NamedValues('a', 'b', ('c', 0), d=1)
               >>> nv
               >>> {'c': 0, 'd': 1, 'a': 2, 'b': 3}
               >>> nv[0]
               'c'
               >>> nv['a']
               2
    1:     """
    1:     def __init__(self, *args, **kwargs):
   17:         self.__names = {}
   17:         self.__numbers = {}
       
   17:         anonymousNames = []
       
  221:         for namedValue in args:
  204:             if isinstance(namedValue, (tuple, list)):
  204:                 try:
  204:                     name, number = namedValue
       
                       except ValueError:
                           raise error.PyAsn1Error('Not a proper attribute-value pair %r' % (namedValue,))
       
                   else:
                       anonymousNames.append(namedValue)
                       continue
       
  204:             if name in self.__names:
                       raise error.PyAsn1Error('Duplicate name %s' % (name,))
       
  204:             if number in self.__numbers:
                       raise error.PyAsn1Error('Duplicate number  %s=%s' % (name, number))
       
  204:             self.__names[name] = number
  204:             self.__numbers[number] = name
       
   17:         for name, number in kwargs.items():
                   if name in self.__names:
                       raise error.PyAsn1Error('Duplicate name %s' % (name,))
       
                   if number in self.__numbers:
                       raise error.PyAsn1Error('Duplicate number  %s=%s' % (name, number))
       
                   self.__names[name] = number
                   self.__numbers[number] = name
       
   17:         if anonymousNames:
       
                   number = self.__numbers and max(self.__numbers) + 1 or 0
       
                   for name in anonymousNames:
       
                       if name in self.__names:
                           raise error.PyAsn1Error('Duplicate name %s' % (name,))
       
                       self.__names[name] = number
                       self.__numbers[number] = name
       
                       number += 1
       
    1:     def __repr__(self):
  296:         representation = ', '.join(['%s=%d' % x for x in self.items()])
       
   34:         if len(representation) > 64:
    6:             representation = representation[:32] + '...' + representation[-32:]
       
   34:         return '<%s object, enums %s>' % (
   34:             self.__class__.__name__, representation)
       
    1:     def __eq__(self, other):
               return dict(self) == other
       
    1:     def __ne__(self, other):
               return dict(self) != other
       
    1:     def __lt__(self, other):
               return dict(self) < other
       
    1:     def __le__(self, other):
               return dict(self) <= other
       
    1:     def __gt__(self, other):
               return dict(self) > other
       
    1:     def __ge__(self, other):
               return dict(self) >= other
       
    1:     def __hash__(self):
               return hash(self.items())
       
           # Python dict protocol (read-only)
       
    1:     def __getitem__(self, key):
   96:         try:
   96:             return self.__numbers[key]
       
   74:         except KeyError:
   74:             return self.__names[key]
       
    1:     def __len__(self):
  145:         return len(self.__names)
       
    1:     def __contains__(self, key):
               return key in self.__names or key in self.__numbers
       
    1:     def __iter__(self):
               return iter(self.__names)
       
    1:     def values(self):
               return iter(self.__numbers)
       
    1:     def keys(self):
               return iter(self.__names)
       
    1:     def items(self):
  262:         for name in self.__names:
  228:             yield name, self.__names[name]
       
           # support merging
       
    1:     def __add__(self, namedValues):
               return self.__class__(*tuple(self.items()) + tuple(namedValues.items()))
       
           # XXX clone/subtype?
       
    1:     def clone(self, *args, **kwargs):
               new = self.__class__(*args, **kwargs)
               return self + new
       
           # legacy protocol
       
    1:     def getName(self, value):
               if value in self.__numbers:
                   return self.__numbers[value]
       
    1:     def getValue(self, name):
               if name in self.__names:
                   return self.__names[name]
       
    1:     def getValues(self, *names):
               try:
                   return [self.__names[name] for name in names]
       
               except KeyError:
                   raise error.PyAsn1Error(
                       'Unknown bit identifier(s): %s' % (set(names).difference(self.__names),)
                   )
