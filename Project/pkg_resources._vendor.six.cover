    1: """Utilities for writing code that runs on Python 2 and 3"""
       
       # Copyright (c) 2010-2015 Benjamin Peterson
       #
       # Permission is hereby granted, free of charge, to any person obtaining a copy
       # of this software and associated documentation files (the "Software"), to deal
       # in the Software without restriction, including without limitation the rights
       # to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
       # copies of the Software, and to permit persons to whom the Software is
       # furnished to do so, subject to the following conditions:
       #
       # The above copyright notice and this permission notice shall be included in all
       # copies or substantial portions of the Software.
       #
       # THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
       # IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
       # FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
       # AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
       # LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
       # OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
       # SOFTWARE.
       
    1: from __future__ import absolute_import
       
    1: import functools
    1: import itertools
    1: import operator
    1: import sys
    1: import types
       
    1: __author__ = "Benjamin Peterson <benjamin@python.org>"
    1: __version__ = "1.10.0"
       
       
       # Useful for very coarse version differentiation.
    1: PY2 = sys.version_info[0] == 2
    1: PY3 = sys.version_info[0] == 3
    1: PY34 = sys.version_info[0:2] >= (3, 4)
       
    1: if PY3:
    1:     string_types = str,
    1:     integer_types = int,
    1:     class_types = type,
    1:     text_type = str
    1:     binary_type = bytes
       
    1:     MAXSIZE = sys.maxsize
       else:
           string_types = basestring,
           integer_types = (int, long)
           class_types = (type, types.ClassType)
           text_type = unicode
           binary_type = str
       
           if sys.platform.startswith("java"):
               # Jython always uses 32 bits.
               MAXSIZE = int((1 << 31) - 1)
           else:
               # It's possible to have sizeof(long) != sizeof(Py_ssize_t).
               class X(object):
       
                   def __len__(self):
                       return 1 << 31
               try:
                   len(X())
               except OverflowError:
                   # 32-bit
                   MAXSIZE = int((1 << 31) - 1)
               else:
                   # 64-bit
                   MAXSIZE = int((1 << 63) - 1)
               del X
       
       
    1: def _add_doc(func, doc):
           """Add documentation to a function."""
    8:     func.__doc__ = doc
       
       
    1: def _import_module(name):
           """Import module, returning the module after the last dot."""
    4:     __import__(name)
    4:     return sys.modules[name]
       
       
    2: class _LazyDescr(object):
       
    1:     def __init__(self, name):
  126:         self.name = name
       
    1:     def __get__(self, obj, tp):
    4:         result = self._resolve()
    4:         setattr(obj, self.name, result)  # Invokes __set__.
    4:         try:
                   # This is a bit ugly, but it avoids running this again by
                   # removing this descriptor.
    4:             delattr(obj.__class__, self.name)
               except AttributeError:
                   pass
    4:         return result
       
       
    2: class MovedModule(_LazyDescr):
       
    1:     def __init__(self, name, old, new=None):
   43:         super(MovedModule, self).__init__(name)
   43:         if PY3:
   43:             if new is None:
    7:                 new = name
   43:             self.mod = new
               else:
                   self.mod = old
       
    1:     def _resolve(self):
    2:         return _import_module(self.mod)
       
    1:     def __getattr__(self, attr):
               _module = self._resolve()
               value = getattr(_module, attr)
               setattr(self, attr, value)
               return value
       
       
    2: class _LazyModule(types.ModuleType):
       
    1:     def __init__(self, name):
    6:         super(_LazyModule, self).__init__(name)
    6:         self.__doc__ = self.__class__.__doc__
       
    1:     def __dir__(self):
               attrs = ["__doc__", "__name__"]
               attrs += [attr.name for attr in self._moved_attributes]
               return attrs
       
           # Subclasses should override this
    1:     _moved_attributes = []
       
       
    2: class MovedAttribute(_LazyDescr):
       
    1:     def __init__(self, name, old_mod, new_mod, old_attr=None, new_attr=None):
   83:         super(MovedAttribute, self).__init__(name)
   83:         if PY3:
   83:             if new_mod is None:
                       new_mod = name
   83:             self.mod = new_mod
   83:             if new_attr is None:
   73:                 if old_attr is None:
   70:                     new_attr = name
                       else:
    3:                     new_attr = old_attr
   83:             self.attr = new_attr
               else:
                   self.mod = old_mod
                   if old_attr is None:
                       old_attr = name
                   self.attr = old_attr
       
    1:     def _resolve(self):
    2:         module = _import_module(self.mod)
    2:         return getattr(module, self.attr)
       
       
    2: class _SixMetaPathImporter(object):
       
           """
           A meta path importer to import six.moves and its submodules.
       
           This class implements a PEP302 finder and loader. It should be compatible
           with Python 2.5 and all existing versions of Python3
    1:     """
       
    1:     def __init__(self, six_module_name):
    1:         self.name = six_module_name
    1:         self.known_modules = {}
       
    1:     def _add_module(self, mod, *fullnames):
  105:         for fullname in fullnames:
   55:             self.known_modules[self.name + "." + fullname] = mod
       
    1:     def _get_module(self, fullname):
    5:         return self.known_modules[self.name + "." + fullname]
       
    1:     def find_module(self, fullname, path=None):
   29:         if fullname in self.known_modules:
    2:             return self
   27:         return None
       
    1:     def __get_module(self, fullname):
    4:         try:
    4:             return self.known_modules[fullname]
               except KeyError:
                   raise ImportError("This loader does not know module " + fullname)
       
    1:     def load_module(self, fullname):
    2:         try:
                   # in case of a reload
    2:             return sys.modules[fullname]
    2:         except KeyError:
    2:             pass
    2:         mod = self.__get_module(fullname)
    2:         if isinstance(mod, MovedModule):
                   mod = mod._resolve()
               else:
    2:             mod.__loader__ = self
    2:         sys.modules[fullname] = mod
    2:         return mod
       
    1:     def is_package(self, fullname):
               """
               Return true, if the named module is a package.
       
               We need this method to get correct spec objects with
               Python 3.4 (see PEP451)
               """
    2:         return hasattr(self.__get_module(fullname), "__path__")
       
    1:     def get_code(self, fullname):
               """Return None
       
               Required, if is_package is implemented"""
               self.__get_module(fullname)  # eventually raises ImportError
               return None
    1:     get_source = get_code  # same as get_code
       
    1: _importer = _SixMetaPathImporter(__name__)
       
       
    2: class _MovedItems(_LazyModule):
       
    1:     """Lazy loading of moved objects"""
    1:     __path__ = []  # mark as package
       
       
       _moved_attributes = [
    1:     MovedAttribute("cStringIO", "cStringIO", "io", "StringIO"),
    1:     MovedAttribute("filter", "itertools", "builtins", "ifilter", "filter"),
    1:     MovedAttribute("filterfalse", "itertools", "itertools", "ifilterfalse", "filterfalse"),
    1:     MovedAttribute("input", "__builtin__", "builtins", "raw_input", "input"),
    1:     MovedAttribute("intern", "__builtin__", "sys"),
    1:     MovedAttribute("map", "itertools", "builtins", "imap", "map"),
    1:     MovedAttribute("getcwd", "os", "os", "getcwdu", "getcwd"),
    1:     MovedAttribute("getcwdb", "os", "os", "getcwd", "getcwdb"),
    1:     MovedAttribute("range", "__builtin__", "builtins", "xrange", "range"),
    1:     MovedAttribute("reload_module", "__builtin__", "importlib" if PY34 else "imp", "reload"),
    1:     MovedAttribute("reduce", "__builtin__", "functools"),
    1:     MovedAttribute("shlex_quote", "pipes", "shlex", "quote"),
    1:     MovedAttribute("StringIO", "StringIO", "io"),
    1:     MovedAttribute("UserDict", "UserDict", "collections"),
    1:     MovedAttribute("UserList", "UserList", "collections"),
    1:     MovedAttribute("UserString", "UserString", "collections"),
    1:     MovedAttribute("xrange", "__builtin__", "builtins", "xrange", "range"),
    1:     MovedAttribute("zip", "itertools", "builtins", "izip", "zip"),
    1:     MovedAttribute("zip_longest", "itertools", "itertools", "izip_longest", "zip_longest"),
    1:     MovedModule("builtins", "__builtin__"),
    1:     MovedModule("configparser", "ConfigParser"),
    1:     MovedModule("copyreg", "copy_reg"),
    1:     MovedModule("dbm_gnu", "gdbm", "dbm.gnu"),
    1:     MovedModule("_dummy_thread", "dummy_thread", "_dummy_thread"),
    1:     MovedModule("http_cookiejar", "cookielib", "http.cookiejar"),
    1:     MovedModule("http_cookies", "Cookie", "http.cookies"),
    1:     MovedModule("html_entities", "htmlentitydefs", "html.entities"),
    1:     MovedModule("html_parser", "HTMLParser", "html.parser"),
    1:     MovedModule("http_client", "httplib", "http.client"),
    1:     MovedModule("email_mime_multipart", "email.MIMEMultipart", "email.mime.multipart"),
    1:     MovedModule("email_mime_nonmultipart", "email.MIMENonMultipart", "email.mime.nonmultipart"),
    1:     MovedModule("email_mime_text", "email.MIMEText", "email.mime.text"),
    1:     MovedModule("email_mime_base", "email.MIMEBase", "email.mime.base"),
    1:     MovedModule("BaseHTTPServer", "BaseHTTPServer", "http.server"),
    1:     MovedModule("CGIHTTPServer", "CGIHTTPServer", "http.server"),
    1:     MovedModule("SimpleHTTPServer", "SimpleHTTPServer", "http.server"),
    1:     MovedModule("cPickle", "cPickle", "pickle"),
    1:     MovedModule("queue", "Queue"),
    1:     MovedModule("reprlib", "repr"),
    1:     MovedModule("socketserver", "SocketServer"),
    1:     MovedModule("_thread", "thread", "_thread"),
    1:     MovedModule("tkinter", "Tkinter"),
    1:     MovedModule("tkinter_dialog", "Dialog", "tkinter.dialog"),
    1:     MovedModule("tkinter_filedialog", "FileDialog", "tkinter.filedialog"),
    1:     MovedModule("tkinter_scrolledtext", "ScrolledText", "tkinter.scrolledtext"),
    1:     MovedModule("tkinter_simpledialog", "SimpleDialog", "tkinter.simpledialog"),
    1:     MovedModule("tkinter_tix", "Tix", "tkinter.tix"),
    1:     MovedModule("tkinter_ttk", "ttk", "tkinter.ttk"),
    1:     MovedModule("tkinter_constants", "Tkconstants", "tkinter.constants"),
    1:     MovedModule("tkinter_dnd", "Tkdnd", "tkinter.dnd"),
    1:     MovedModule("tkinter_colorchooser", "tkColorChooser",
    1:                 "tkinter.colorchooser"),
    1:     MovedModule("tkinter_commondialog", "tkCommonDialog",
    1:                 "tkinter.commondialog"),
    1:     MovedModule("tkinter_tkfiledialog", "tkFileDialog", "tkinter.filedialog"),
    1:     MovedModule("tkinter_font", "tkFont", "tkinter.font"),
    1:     MovedModule("tkinter_messagebox", "tkMessageBox", "tkinter.messagebox"),
    1:     MovedModule("tkinter_tksimpledialog", "tkSimpleDialog",
    1:                 "tkinter.simpledialog"),
    1:     MovedModule("urllib_parse", __name__ + ".moves.urllib_parse", "urllib.parse"),
    1:     MovedModule("urllib_error", __name__ + ".moves.urllib_error", "urllib.error"),
    1:     MovedModule("urllib", __name__ + ".moves.urllib", __name__ + ".moves.urllib"),
    1:     MovedModule("urllib_robotparser", "robotparser", "urllib.robotparser"),
    1:     MovedModule("xmlrpc_client", "xmlrpclib", "xmlrpc.client"),
    1:     MovedModule("xmlrpc_server", "SimpleXMLRPCServer", "xmlrpc.server"),
       ]
       # Add windows specific modules.
    1: if sys.platform == "win32":
           _moved_attributes += [
               MovedModule("winreg", "_winreg"),
           ]
       
   63: for attr in _moved_attributes:
   62:     setattr(_MovedItems, attr.name, attr)
   62:     if isinstance(attr, MovedModule):
   43:         _importer._add_module(attr, "moves." + attr.name)
    1: del attr
       
    1: _MovedItems._moved_attributes = _moved_attributes
       
    1: moves = _MovedItems(__name__ + ".moves")
    1: _importer._add_module(moves, "moves")
       
       
    2: class Module_six_moves_urllib_parse(_LazyModule):
       
    1:     """Lazy loading of moved objects in six.moves.urllib_parse"""
       
       
       _urllib_parse_moved_attributes = [
    1:     MovedAttribute("ParseResult", "urlparse", "urllib.parse"),
    1:     MovedAttribute("SplitResult", "urlparse", "urllib.parse"),
    1:     MovedAttribute("parse_qs", "urlparse", "urllib.parse"),
    1:     MovedAttribute("parse_qsl", "urlparse", "urllib.parse"),
    1:     MovedAttribute("urldefrag", "urlparse", "urllib.parse"),
    1:     MovedAttribute("urljoin", "urlparse", "urllib.parse"),
    1:     MovedAttribute("urlparse", "urlparse", "urllib.parse"),
    1:     MovedAttribute("urlsplit", "urlparse", "urllib.parse"),
    1:     MovedAttribute("urlunparse", "urlparse", "urllib.parse"),
    1:     MovedAttribute("urlunsplit", "urlparse", "urllib.parse"),
    1:     MovedAttribute("quote", "urllib", "urllib.parse"),
    1:     MovedAttribute("quote_plus", "urllib", "urllib.parse"),
    1:     MovedAttribute("unquote", "urllib", "urllib.parse"),
    1:     MovedAttribute("unquote_plus", "urllib", "urllib.parse"),
    1:     MovedAttribute("urlencode", "urllib", "urllib.parse"),
    1:     MovedAttribute("splitquery", "urllib", "urllib.parse"),
    1:     MovedAttribute("splittag", "urllib", "urllib.parse"),
    1:     MovedAttribute("splituser", "urllib", "urllib.parse"),
    1:     MovedAttribute("uses_fragment", "urlparse", "urllib.parse"),
    1:     MovedAttribute("uses_netloc", "urlparse", "urllib.parse"),
    1:     MovedAttribute("uses_params", "urlparse", "urllib.parse"),
    1:     MovedAttribute("uses_query", "urlparse", "urllib.parse"),
    1:     MovedAttribute("uses_relative", "urlparse", "urllib.parse"),
       ]
   24: for attr in _urllib_parse_moved_attributes:
   23:     setattr(Module_six_moves_urllib_parse, attr.name, attr)
    1: del attr
       
    1: Module_six_moves_urllib_parse._moved_attributes = _urllib_parse_moved_attributes
       
    1: _importer._add_module(Module_six_moves_urllib_parse(__name__ + ".moves.urllib_parse"),
    1:                       "moves.urllib_parse", "moves.urllib.parse")
       
       
    2: class Module_six_moves_urllib_error(_LazyModule):
       
    1:     """Lazy loading of moved objects in six.moves.urllib_error"""
       
       
       _urllib_error_moved_attributes = [
    1:     MovedAttribute("URLError", "urllib2", "urllib.error"),
    1:     MovedAttribute("HTTPError", "urllib2", "urllib.error"),
    1:     MovedAttribute("ContentTooShortError", "urllib", "urllib.error"),
       ]
    4: for attr in _urllib_error_moved_attributes:
    3:     setattr(Module_six_moves_urllib_error, attr.name, attr)
    1: del attr
       
    1: Module_six_moves_urllib_error._moved_attributes = _urllib_error_moved_attributes
       
    1: _importer._add_module(Module_six_moves_urllib_error(__name__ + ".moves.urllib.error"),
    1:                       "moves.urllib_error", "moves.urllib.error")
       
       
    2: class Module_six_moves_urllib_request(_LazyModule):
       
    1:     """Lazy loading of moved objects in six.moves.urllib_request"""
       
       
       _urllib_request_moved_attributes = [
    1:     MovedAttribute("urlopen", "urllib2", "urllib.request"),
    1:     MovedAttribute("install_opener", "urllib2", "urllib.request"),
    1:     MovedAttribute("build_opener", "urllib2", "urllib.request"),
    1:     MovedAttribute("pathname2url", "urllib", "urllib.request"),
    1:     MovedAttribute("url2pathname", "urllib", "urllib.request"),
    1:     MovedAttribute("getproxies", "urllib", "urllib.request"),
    1:     MovedAttribute("Request", "urllib2", "urllib.request"),
    1:     MovedAttribute("OpenerDirector", "urllib2", "urllib.request"),
    1:     MovedAttribute("HTTPDefaultErrorHandler", "urllib2", "urllib.request"),
    1:     MovedAttribute("HTTPRedirectHandler", "urllib2", "urllib.request"),
    1:     MovedAttribute("HTTPCookieProcessor", "urllib2", "urllib.request"),
    1:     MovedAttribute("ProxyHandler", "urllib2", "urllib.request"),
    1:     MovedAttribute("BaseHandler", "urllib2", "urllib.request"),
    1:     MovedAttribute("HTTPPasswordMgr", "urllib2", "urllib.request"),
    1:     MovedAttribute("HTTPPasswordMgrWithDefaultRealm", "urllib2", "urllib.request"),
    1:     MovedAttribute("AbstractBasicAuthHandler", "urllib2", "urllib.request"),
    1:     MovedAttribute("HTTPBasicAuthHandler", "urllib2", "urllib.request"),
    1:     MovedAttribute("ProxyBasicAuthHandler", "urllib2", "urllib.request"),
    1:     MovedAttribute("AbstractDigestAuthHandler", "urllib2", "urllib.request"),
    1:     MovedAttribute("HTTPDigestAuthHandler", "urllib2", "urllib.request"),
    1:     MovedAttribute("ProxyDigestAuthHandler", "urllib2", "urllib.request"),
    1:     MovedAttribute("HTTPHandler", "urllib2", "urllib.request"),
    1:     MovedAttribute("HTTPSHandler", "urllib2", "urllib.request"),
    1:     MovedAttribute("FileHandler", "urllib2", "urllib.request"),
    1:     MovedAttribute("FTPHandler", "urllib2", "urllib.request"),
    1:     MovedAttribute("CacheFTPHandler", "urllib2", "urllib.request"),
    1:     MovedAttribute("UnknownHandler", "urllib2", "urllib.request"),
    1:     MovedAttribute("HTTPErrorProcessor", "urllib2", "urllib.request"),
    1:     MovedAttribute("urlretrieve", "urllib", "urllib.request"),
    1:     MovedAttribute("urlcleanup", "urllib", "urllib.request"),
    1:     MovedAttribute("URLopener", "urllib", "urllib.request"),
    1:     MovedAttribute("FancyURLopener", "urllib", "urllib.request"),
    1:     MovedAttribute("proxy_bypass", "urllib", "urllib.request"),
       ]
   34: for attr in _urllib_request_moved_attributes:
   33:     setattr(Module_six_moves_urllib_request, attr.name, attr)
    1: del attr
       
    1: Module_six_moves_urllib_request._moved_attributes = _urllib_request_moved_attributes
       
    1: _importer._add_module(Module_six_moves_urllib_request(__name__ + ".moves.urllib.request"),
    1:                       "moves.urllib_request", "moves.urllib.request")
       
       
    2: class Module_six_moves_urllib_response(_LazyModule):
       
    1:     """Lazy loading of moved objects in six.moves.urllib_response"""
       
       
       _urllib_response_moved_attributes = [
    1:     MovedAttribute("addbase", "urllib", "urllib.response"),
    1:     MovedAttribute("addclosehook", "urllib", "urllib.response"),
    1:     MovedAttribute("addinfo", "urllib", "urllib.response"),
    1:     MovedAttribute("addinfourl", "urllib", "urllib.response"),
       ]
    5: for attr in _urllib_response_moved_attributes:
    4:     setattr(Module_six_moves_urllib_response, attr.name, attr)
    1: del attr
       
    1: Module_six_moves_urllib_response._moved_attributes = _urllib_response_moved_attributes
       
    1: _importer._add_module(Module_six_moves_urllib_response(__name__ + ".moves.urllib.response"),
    1:                       "moves.urllib_response", "moves.urllib.response")
       
       
    2: class Module_six_moves_urllib_robotparser(_LazyModule):
       
    1:     """Lazy loading of moved objects in six.moves.urllib_robotparser"""
       
       
       _urllib_robotparser_moved_attributes = [
    1:     MovedAttribute("RobotFileParser", "robotparser", "urllib.robotparser"),
       ]
    2: for attr in _urllib_robotparser_moved_attributes:
    1:     setattr(Module_six_moves_urllib_robotparser, attr.name, attr)
    1: del attr
       
    1: Module_six_moves_urllib_robotparser._moved_attributes = _urllib_robotparser_moved_attributes
       
    1: _importer._add_module(Module_six_moves_urllib_robotparser(__name__ + ".moves.urllib.robotparser"),
    1:                       "moves.urllib_robotparser", "moves.urllib.robotparser")
       
       
    2: class Module_six_moves_urllib(types.ModuleType):
       
    1:     """Create a six.moves.urllib namespace that resembles the Python 3 namespace"""
    1:     __path__ = []  # mark as package
    1:     parse = _importer._get_module("moves.urllib_parse")
    1:     error = _importer._get_module("moves.urllib_error")
    1:     request = _importer._get_module("moves.urllib_request")
    1:     response = _importer._get_module("moves.urllib_response")
    1:     robotparser = _importer._get_module("moves.urllib_robotparser")
       
    1:     def __dir__(self):
               return ['parse', 'error', 'request', 'response', 'robotparser']
       
    1: _importer._add_module(Module_six_moves_urllib(__name__ + ".moves.urllib"),
    1:                       "moves.urllib")
       
       
    1: def add_move(move):
           """Add an item to six.moves."""
           setattr(_MovedItems, move.name, move)
       
       
    1: def remove_move(name):
           """Remove item from six.moves."""
           try:
               delattr(_MovedItems, name)
           except AttributeError:
               try:
                   del moves.__dict__[name]
               except KeyError:
                   raise AttributeError("no such move, %r" % (name,))
       
       
    1: if PY3:
    1:     _meth_func = "__func__"
    1:     _meth_self = "__self__"
       
    1:     _func_closure = "__closure__"
    1:     _func_code = "__code__"
    1:     _func_defaults = "__defaults__"
    1:     _func_globals = "__globals__"
       else:
           _meth_func = "im_func"
           _meth_self = "im_self"
       
           _func_closure = "func_closure"
           _func_code = "func_code"
           _func_defaults = "func_defaults"
           _func_globals = "func_globals"
       
       
    1: try:
    1:     advance_iterator = next
       except NameError:
           def advance_iterator(it):
               return it.next()
    1: next = advance_iterator
       
       
    1: try:
    1:     callable = callable
       except NameError:
           def callable(obj):
               return any("__call__" in klass.__dict__ for klass in type(obj).__mro__)
       
       
    1: if PY3:
    1:     def get_unbound_function(unbound):
               return unbound
       
    1:     create_bound_method = types.MethodType
       
    1:     def create_unbound_method(func, cls):
               return func
       
    1:     Iterator = object
       else:
           def get_unbound_function(unbound):
               return unbound.im_func
       
           def create_bound_method(func, obj):
               return types.MethodType(func, obj, obj.__class__)
       
           def create_unbound_method(func, cls):
               return types.MethodType(func, None, cls)
       
           class Iterator(object):
       
               def next(self):
                   return type(self).__next__(self)
       
           callable = callable
    1: _add_doc(get_unbound_function,
    1:          """Get the function out of a possibly unbound function""")
       
       
    1: get_method_function = operator.attrgetter(_meth_func)
    1: get_method_self = operator.attrgetter(_meth_self)
    1: get_function_closure = operator.attrgetter(_func_closure)
    1: get_function_code = operator.attrgetter(_func_code)
    1: get_function_defaults = operator.attrgetter(_func_defaults)
    1: get_function_globals = operator.attrgetter(_func_globals)
       
       
    1: if PY3:
    1:     def iterkeys(d, **kw):
               return iter(d.keys(**kw))
       
    1:     def itervalues(d, **kw):
               return iter(d.values(**kw))
       
    1:     def iteritems(d, **kw):
               return iter(d.items(**kw))
       
    1:     def iterlists(d, **kw):
               return iter(d.lists(**kw))
       
    1:     viewkeys = operator.methodcaller("keys")
       
    1:     viewvalues = operator.methodcaller("values")
       
    1:     viewitems = operator.methodcaller("items")
       else:
           def iterkeys(d, **kw):
               return d.iterkeys(**kw)
       
           def itervalues(d, **kw):
               return d.itervalues(**kw)
       
           def iteritems(d, **kw):
               return d.iteritems(**kw)
       
           def iterlists(d, **kw):
               return d.iterlists(**kw)
       
           viewkeys = operator.methodcaller("viewkeys")
       
           viewvalues = operator.methodcaller("viewvalues")
       
           viewitems = operator.methodcaller("viewitems")
       
    1: _add_doc(iterkeys, "Return an iterator over the keys of a dictionary.")
    1: _add_doc(itervalues, "Return an iterator over the values of a dictionary.")
    1: _add_doc(iteritems,
    1:          "Return an iterator over the (key, value) pairs of a dictionary.")
    1: _add_doc(iterlists,
    1:          "Return an iterator over the (key, [values]) pairs of a dictionary.")
       
       
    1: if PY3:
    1:     def b(s):
               return s.encode("latin-1")
       
    1:     def u(s):
               return s
    1:     unichr = chr
    1:     import struct
    1:     int2byte = struct.Struct(">B").pack
    1:     del struct
    1:     byte2int = operator.itemgetter(0)
    1:     indexbytes = operator.getitem
    1:     iterbytes = iter
    1:     import io
    1:     StringIO = io.StringIO
    1:     BytesIO = io.BytesIO
    1:     _assertCountEqual = "assertCountEqual"
    1:     if sys.version_info[1] <= 1:
               _assertRaisesRegex = "assertRaisesRegexp"
               _assertRegex = "assertRegexpMatches"
           else:
    1:         _assertRaisesRegex = "assertRaisesRegex"
    1:         _assertRegex = "assertRegex"
       else:
           def b(s):
               return s
           # Workaround for standalone backslash
       
           def u(s):
               return unicode(s.replace(r'\\', r'\\\\'), "unicode_escape")
           unichr = unichr
           int2byte = chr
       
           def byte2int(bs):
               return ord(bs[0])
       
           def indexbytes(buf, i):
               return ord(buf[i])
           iterbytes = functools.partial(itertools.imap, ord)
           import StringIO
           StringIO = BytesIO = StringIO.StringIO
           _assertCountEqual = "assertItemsEqual"
           _assertRaisesRegex = "assertRaisesRegexp"
           _assertRegex = "assertRegexpMatches"
    1: _add_doc(b, """Byte literal""")
    1: _add_doc(u, """Text literal""")
       
       
    1: def assertCountEqual(self, *args, **kwargs):
           return getattr(self, _assertCountEqual)(*args, **kwargs)
       
       
    1: def assertRaisesRegex(self, *args, **kwargs):
           return getattr(self, _assertRaisesRegex)(*args, **kwargs)
       
       
    1: def assertRegex(self, *args, **kwargs):
           return getattr(self, _assertRegex)(*args, **kwargs)
       
       
    1: if PY3:
    1:     exec_ = getattr(moves.builtins, "exec")
       
    1:     def reraise(tp, value, tb=None):
               if value is None:
                   value = tp()
               if value.__traceback__ is not tb:
                   raise value.with_traceback(tb)
               raise value
       
       else:
           def exec_(_code_, _globs_=None, _locs_=None):
               """Execute code in a namespace."""
               if _globs_ is None:
                   frame = sys._getframe(1)
                   _globs_ = frame.f_globals
                   if _locs_ is None:
                       _locs_ = frame.f_locals
                   del frame
               elif _locs_ is None:
                   _locs_ = _globs_
               exec("""exec _code_ in _globs_, _locs_""")
       
           exec_("""def reraise(tp, value, tb=None):
           raise tp, value, tb
       """)
       
       
    1: if sys.version_info[:2] == (3, 2):
           exec_("""def raise_from(value, from_value):
           if from_value is None:
               raise value
           raise value from from_value
       """)
    1: elif sys.version_info[:2] > (3, 2):
    1:     exec_("""def raise_from(value, from_value):
           raise value from from_value
    1: """)
       else:
           def raise_from(value, from_value):
               raise value
       
       
    1: print_ = getattr(moves.builtins, "print", None)
    1: if print_ is None:
           def print_(*args, **kwargs):
               """The new-style print function for Python 2.4 and 2.5."""
               fp = kwargs.pop("file", sys.stdout)
               if fp is None:
                   return
       
               def write(data):
                   if not isinstance(data, basestring):
                       data = str(data)
                   # If the file has an encoding, encode unicode with it.
                   if (isinstance(fp, file) and
                           isinstance(data, unicode) and
                           fp.encoding is not None):
                       errors = getattr(fp, "errors", None)
                       if errors is None:
                           errors = "strict"
                       data = data.encode(fp.encoding, errors)
                   fp.write(data)
               want_unicode = False
               sep = kwargs.pop("sep", None)
               if sep is not None:
                   if isinstance(sep, unicode):
                       want_unicode = True
                   elif not isinstance(sep, str):
                       raise TypeError("sep must be None or a string")
               end = kwargs.pop("end", None)
               if end is not None:
                   if isinstance(end, unicode):
                       want_unicode = True
                   elif not isinstance(end, str):
                       raise TypeError("end must be None or a string")
               if kwargs:
                   raise TypeError("invalid keyword arguments to print()")
               if not want_unicode:
                   for arg in args:
                       if isinstance(arg, unicode):
                           want_unicode = True
                           break
               if want_unicode:
                   newline = unicode("\n")
                   space = unicode(" ")
               else:
                   newline = "\n"
                   space = " "
               if sep is None:
                   sep = space
               if end is None:
                   end = newline
               for i, arg in enumerate(args):
                   if i:
                       write(sep)
                   write(arg)
               write(end)
    1: if sys.version_info[:2] < (3, 3):
           _print = print_
       
           def print_(*args, **kwargs):
               fp = kwargs.get("file", sys.stdout)
               flush = kwargs.pop("flush", False)
               _print(*args, **kwargs)
               if flush and fp is not None:
                   fp.flush()
       
    1: _add_doc(reraise, """Reraise an exception.""")
       
    1: if sys.version_info[0:2] < (3, 4):
           def wraps(wrapped, assigned=functools.WRAPPER_ASSIGNMENTS,
                     updated=functools.WRAPPER_UPDATES):
               def wrapper(f):
                   f = functools.wraps(wrapped, assigned, updated)(f)
                   f.__wrapped__ = wrapped
                   return f
               return wrapper
       else:
    1:     wraps = functools.wraps
       
       
    1: def with_metaclass(meta, *bases):
           """Create a base class with a metaclass."""
           # This requires a bit of explanation: the basic idea is to make a dummy
           # metaclass for one level of class instantiation that replaces itself with
           # the actual metaclass.
           class metaclass(meta):
       
               def __new__(cls, name, this_bases, d):
                   return meta(name, bases, d)
           return type.__new__(metaclass, 'temporary_class', (), {})
       
       
    1: def add_metaclass(metaclass):
           """Class decorator for creating a class with a metaclass."""
           def wrapper(cls):
               orig_vars = cls.__dict__.copy()
               slots = orig_vars.get('__slots__')
               if slots is not None:
                   if isinstance(slots, str):
                       slots = [slots]
                   for slots_var in slots:
                       orig_vars.pop(slots_var)
               orig_vars.pop('__dict__', None)
               orig_vars.pop('__weakref__', None)
               return metaclass(cls.__name__, cls.__bases__, orig_vars)
           return wrapper
       
       
    1: def python_2_unicode_compatible(klass):
           """
           A decorator that defines __unicode__ and __str__ methods under Python 2.
           Under Python 3 it does nothing.
       
           To support Python 2 and 3 with a single code base, define a __str__ method
           returning text and apply this decorator to the class.
           """
           if PY2:
               if '__str__' not in klass.__dict__:
                   raise ValueError("@python_2_unicode_compatible cannot be applied "
                                    "to %s because it doesn't define __str__()." %
                                    klass.__name__)
               klass.__unicode__ = klass.__str__
               klass.__str__ = lambda self: self.__unicode__().encode('utf-8')
           return klass
       
       
       # Complete the moves implementation.
       # This code is at the end of this module to speed up module loading.
       # Turn this module into a package.
    1: __path__ = []  # required for PEP 302 and PEP 451
    1: __package__ = __name__  # see PEP 366 @ReservedAssignment
    1: if globals().get("__spec__") is not None:
    1:     __spec__.submodule_search_locations = []  # PEP 451 @UndefinedVariable
       # Remove other six meta path importers, since they cause problems. This can
       # happen if six is removed from sys.modules and then reloaded. (Setuptools does
       # this for some reason.)
    1: if sys.meta_path:
    7:     for i, importer in enumerate(sys.meta_path):
               # Here's some real nastiness: Another "instance" of the six module might
               # be floating around. Therefore, we can't use isinstance() to check for
               # the six meta path importer, since the other six instance will have
               # inserted an importer with different class.
    6:         if (type(importer).__name__ == "_SixMetaPathImporter" and
    2:                 importer.name == __name__):
                   del sys.meta_path[i]
                   break
    1:     del i, importer
       # Finally, add the importer to the meta path import hook.
    1: sys.meta_path.append(_importer)
