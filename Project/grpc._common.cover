       # Copyright 2016 gRPC authors.
       #
       # Licensed under the Apache License, Version 2.0 (the "License");
       # you may not use this file except in compliance with the License.
       # You may obtain a copy of the License at
       #
       #     http://www.apache.org/licenses/LICENSE-2.0
       #
       # Unless required by applicable law or agreed to in writing, software
       # distributed under the License is distributed on an "AS IS" BASIS,
       # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       # See the License for the specific language governing permissions and
       # limitations under the License.
    1: """Shared implementation."""
       
    1: import logging
    1: import time
    1: import six
       
    1: import grpc
    1: from grpc._cython import cygrpc
       
    1: _LOGGER = logging.getLogger(__name__)
       
       CYGRPC_CONNECTIVITY_STATE_TO_CHANNEL_CONNECTIVITY = {
    1:     cygrpc.ConnectivityState.idle:
    1:         grpc.ChannelConnectivity.IDLE,
    1:     cygrpc.ConnectivityState.connecting:
    1:         grpc.ChannelConnectivity.CONNECTING,
    1:     cygrpc.ConnectivityState.ready:
    1:         grpc.ChannelConnectivity.READY,
    1:     cygrpc.ConnectivityState.transient_failure:
    1:         grpc.ChannelConnectivity.TRANSIENT_FAILURE,
    1:     cygrpc.ConnectivityState.shutdown:
    1:         grpc.ChannelConnectivity.SHUTDOWN,
       }
       
       CYGRPC_STATUS_CODE_TO_STATUS_CODE = {
    1:     cygrpc.StatusCode.ok: grpc.StatusCode.OK,
    1:     cygrpc.StatusCode.cancelled: grpc.StatusCode.CANCELLED,
    1:     cygrpc.StatusCode.unknown: grpc.StatusCode.UNKNOWN,
    1:     cygrpc.StatusCode.invalid_argument: grpc.StatusCode.INVALID_ARGUMENT,
    1:     cygrpc.StatusCode.deadline_exceeded: grpc.StatusCode.DEADLINE_EXCEEDED,
    1:     cygrpc.StatusCode.not_found: grpc.StatusCode.NOT_FOUND,
    1:     cygrpc.StatusCode.already_exists: grpc.StatusCode.ALREADY_EXISTS,
    1:     cygrpc.StatusCode.permission_denied: grpc.StatusCode.PERMISSION_DENIED,
    1:     cygrpc.StatusCode.unauthenticated: grpc.StatusCode.UNAUTHENTICATED,
    1:     cygrpc.StatusCode.resource_exhausted: grpc.StatusCode.RESOURCE_EXHAUSTED,
    1:     cygrpc.StatusCode.failed_precondition: grpc.StatusCode.FAILED_PRECONDITION,
    1:     cygrpc.StatusCode.aborted: grpc.StatusCode.ABORTED,
    1:     cygrpc.StatusCode.out_of_range: grpc.StatusCode.OUT_OF_RANGE,
    1:     cygrpc.StatusCode.unimplemented: grpc.StatusCode.UNIMPLEMENTED,
    1:     cygrpc.StatusCode.internal: grpc.StatusCode.INTERNAL,
    1:     cygrpc.StatusCode.unavailable: grpc.StatusCode.UNAVAILABLE,
    1:     cygrpc.StatusCode.data_loss: grpc.StatusCode.DATA_LOSS,
       }
   19: STATUS_CODE_TO_CYGRPC_STATUS_CODE = {
   18:     grpc_code: cygrpc_code for cygrpc_code, grpc_code in six.iteritems(
    1:         CYGRPC_STATUS_CODE_TO_STATUS_CODE)
       }
       
    1: MAXIMUM_WAIT_TIMEOUT = 0.1
       
       
    1: def encode(s):
   17:     if isinstance(s, bytes):
               return s
           else:
   17:         return s.encode('utf8')
       
       
    1: def decode(b):
    4:     if isinstance(b, bytes):
    4:         return b.decode('utf-8', 'replace')
           return b
       
       
    1: def _transform(message, transformer, exception_message):
    4:     if transformer is None:
               return message
           else:
    4:         try:
    4:             return transformer(message)
               except Exception:  # pylint: disable=broad-except
                   _LOGGER.exception(exception_message)
                   return None
       
       
    1: def serialize(message, serializer):
    2:     return _transform(message, serializer, 'Exception serializing message!')
       
       
    1: def deserialize(serialized_message, deserializer):
    2:     return _transform(serialized_message, deserializer,
    2:                       'Exception deserializing message!')
       
       
    1: def fully_qualified_method(group, method):
           return '/{}/{}'.format(group, method)
       
       
    1: def _wait_once(wait_fn, timeout, spin_cb):
           wait_fn(timeout=timeout)
           if spin_cb is not None:
               spin_cb()
       
       
    1: def wait(wait_fn, wait_complete_fn, timeout=None, spin_cb=None):
           """Blocks waiting for an event without blocking the thread indefinitely.
       
           See https://github.com/grpc/grpc/issues/19464 for full context. CPython's
           `threading.Event.wait` and `threading.Condition.wait` methods, if invoked
           without a timeout kwarg, may block the calling thread indefinitely. If the
           call is made from the main thread, this means that signal handlers may not
           run for an arbitrarily long period of time.
       
           This wrapper calls the supplied wait function with an arbitrary short
           timeout to ensure that no signal handler has to wait longer than
           MAXIMUM_WAIT_TIMEOUT before executing.
       
           Args:
             wait_fn: A callable acceptable a single float-valued kwarg named
               `timeout`. This function is expected to be one of `threading.Event.wait`
               or `threading.Condition.wait`.
             wait_complete_fn: A callable taking no arguments and returning a bool.
               When this function returns true, it indicates that waiting should cease.
             timeout: An optional float-valued number of seconds after which the wait
               should cease.
             spin_cb: An optional Callable taking no arguments and returning nothing.
               This callback will be called on each iteration of the spin. This may be
               used for, e.g. work related to forking.
       
           Returns:
             True if a timeout was supplied and it was reached. False otherwise.
           """
           if timeout is None:
               while not wait_complete_fn():
                   _wait_once(wait_fn, MAXIMUM_WAIT_TIMEOUT, spin_cb)
           else:
               end = time.time() + timeout
               while not wait_complete_fn():
                   remaining = min(end - time.time(), MAXIMUM_WAIT_TIMEOUT)
                   if remaining < 0:
                       return True
                   _wait_once(wait_fn, remaining, spin_cb)
           return False
