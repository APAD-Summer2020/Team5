    1: from __future__ import absolute_import
    1: from contextlib import contextmanager
    1: import zlib
    1: import io
    1: from socket import timeout as SocketTimeout
    1: from socket import error as SocketError
       
    1: from ._collections import HTTPHeaderDict
    1: from .exceptions import (
           ProtocolError, DecodeError, ReadTimeoutError, ResponseNotChunked
       )
    1: from .packages.six import string_types as basestring, binary_type, PY3
    1: from .packages.six.moves import http_client as httplib
    1: from .connection import HTTPException, BaseSSLError
    1: from .util.response import is_fp_closed, is_response_to_head
       
       
    2: class DeflateDecoder(object):
       
    1:     def __init__(self):
               self._first_try = True
               self._data = binary_type()
               self._obj = zlib.decompressobj()
       
    1:     def __getattr__(self, name):
               return getattr(self._obj, name)
       
    1:     def decompress(self, data):
               if not data:
                   return data
       
               if not self._first_try:
                   return self._obj.decompress(data)
       
               self._data += data
               try:
                   return self._obj.decompress(data)
               except zlib.error:
                   self._first_try = False
                   self._obj = zlib.decompressobj(-zlib.MAX_WBITS)
                   try:
                       return self.decompress(self._data)
                   finally:
                       self._data = None
       
       
    2: class GzipDecoder(object):
       
    1:     def __init__(self):
    1:         self._obj = zlib.decompressobj(16 + zlib.MAX_WBITS)
       
    1:     def __getattr__(self, name):
    1:         return getattr(self._obj, name)
       
    1:     def decompress(self, data):
   23:         if not data:
    1:             return data
   22:         return self._obj.decompress(data)
       
       
    1: def _get_decoder(mode):
    1:     if mode == 'gzip':
    1:         return GzipDecoder()
       
           return DeflateDecoder()
       
       
    2: class HTTPResponse(io.IOBase):
           """
           HTTP Response container.
       
           Backwards-compatible to httplib's HTTPResponse but the response ``body`` is
           loaded and decoded on-demand when the ``data`` property is accessed.  This
           class is also compatible with the Python standard library's :mod:`io`
           module, and can hence be treated as a readable object in the context of that
           framework.
       
           Extra parameters for behaviour not present in httplib.HTTPResponse:
       
           :param preload_content:
               If True, the response's body will be preloaded during construction.
       
           :param decode_content:
               If True, attempts to decode specific content-encoding's based on headers
               (like 'gzip' and 'deflate') will be skipped and raw data will be used
               instead.
       
           :param original_response:
               When this HTTPResponse wrapper is generated from an httplib.HTTPResponse
               object, it's convenient to include the original for debug purposes. It's
               otherwise unused.
    1:     """
       
    1:     CONTENT_DECODERS = ['gzip', 'deflate']
    1:     REDIRECT_STATUSES = [301, 302, 303, 307, 308]
       
           def __init__(self, body='', headers=None, status=0, version=0, reason=None,
                        strict=0, preload_content=True, decode_content=True,
    1:                  original_response=None, pool=None, connection=None):
       
    1:         if isinstance(headers, HTTPHeaderDict):
    1:             self.headers = headers
               else:
                   self.headers = HTTPHeaderDict(headers)
    1:         self.status = status
    1:         self.version = version
    1:         self.reason = reason
    1:         self.strict = strict
    1:         self.decode_content = decode_content
       
    1:         self._decoder = None
    1:         self._body = None
    1:         self._fp = None
    1:         self._original_response = original_response
    1:         self._fp_bytes_read = 0
       
    1:         if body and isinstance(body, (basestring, binary_type)):
                   self._body = body
       
    1:         self._pool = pool
    1:         self._connection = connection
       
    1:         if hasattr(body, 'read'):
    1:             self._fp = body
       
               # Are we using the chunked-style of transfer encoding?
    1:         self.chunked = False
    1:         self.chunk_left = None
    1:         tr_enc = self.headers.get('transfer-encoding', '').lower()
               # Don't incur the penalty of creating a list and then discarding it
    2:         encodings = (enc.strip() for enc in tr_enc.split(","))
    1:         if "chunked" in encodings:
    1:             self.chunked = True
       
               # If requested, preload the body.
    1:         if preload_content and not self._body:
                   self._body = self.read(decode_content=decode_content)
       
    1:     def get_redirect_location(self):
               """
               Should we redirect and where to?
       
               :returns: Truthy redirect location string if we got a redirect status
                   code and valid location. ``None`` if redirect status and no
                   location. ``False`` if not a redirect status code.
               """
               if self.status in self.REDIRECT_STATUSES:
                   return self.headers.get('location')
       
               return False
       
    1:     def release_conn(self):
    1:         if not self._pool or not self._connection:
                   return
       
    1:         self._pool._put_conn(self._connection)
    1:         self._connection = None
       
    1:     @property
           def data(self):
               # For backwords-compat with earlier urllib3 0.4 and earlier.
               if self._body:
                   return self._body
       
               if self._fp:
                   return self.read(cache_content=True)
       
    1:     @property
           def connection(self):
               return self._connection
       
    1:     def tell(self):
               """
               Obtain the number of bytes pulled over the wire so far. May differ from
               the amount of content returned by :meth:``HTTPResponse.read`` if bytes
               are encoded on the wire (e.g, compressed).
               """
               return self._fp_bytes_read
       
    1:     def _init_decoder(self):
               """
               Set-up the _decoder attribute if necessar.
               """
               # Note: content-encoding value should be case-insensitive, per RFC 7230
               # Section 3.2
    1:         content_encoding = self.headers.get('content-encoding', '').lower()
    1:         if self._decoder is None and content_encoding in self.CONTENT_DECODERS:
    1:             self._decoder = _get_decoder(content_encoding)
       
    1:     def _decode(self, data, decode_content, flush_decoder):
               """
               Decode the data passed in and potentially flush the decoder.
               """
   22:         try:
   22:             if decode_content and self._decoder:
   22:                 data = self._decoder.decompress(data)
               except (IOError, zlib.error) as e:
                   content_encoding = self.headers.get('content-encoding', '').lower()
                   raise DecodeError(
                       "Received response with content-encoding: %s, but "
                       "failed to decode it." % content_encoding, e)
       
   22:         if flush_decoder and decode_content:
                   data += self._flush_decoder()
       
   22:         return data
       
    1:     def _flush_decoder(self):
               """
               Flushes the decoder. Should only be called if the decoder is actually
               being used.
               """
    1:         if self._decoder:
    1:             buf = self._decoder.decompress(b'')
    1:             return buf + self._decoder.flush()
       
               return b''
       
    1:     @contextmanager
           def _error_catcher(self):
               """
               Catch low-level python exceptions, instead re-raising urllib3
               variants, so that low-level exceptions are not leaked in the
               high-level api.
       
               On exit, release the connection back to the pool.
               """
    1:         clean_exit = False
       
    1:         try:
    1:             try:
    1:                 yield
       
                   except SocketTimeout:
                       # FIXME: Ideally we'd like to include the url in the ReadTimeoutError but
                       # there is yet no clean way to get at it from this context.
                       raise ReadTimeoutError(self._pool, None, 'Read timed out.')
       
                   except BaseSSLError as e:
                       # FIXME: Is there a better way to differentiate between SSLErrors?
                       if 'read operation timed out' not in str(e):  # Defensive:
                           # This shouldn't happen but just in case we're missing an edge
                           # case, let's avoid swallowing SSL errors.
                           raise
       
                       raise ReadTimeoutError(self._pool, None, 'Read timed out.')
       
                   except (HTTPException, SocketError) as e:
                       # This includes IncompleteRead.
                       raise ProtocolError('Connection broken: %r' % e, e)
       
                   # If no exception is thrown, we should avoid cleaning up
                   # unnecessarily.
    1:             clean_exit = True
               finally:
                   # If we didn't terminate cleanly, we need to throw away our
                   # connection.
    1:             if not clean_exit:
                       # The response may not be closed but we're not going to use it
                       # anymore so close it now to ensure that the connection is
                       # released back to the pool.
                       if self._original_response:
                           self._original_response.close()
       
                       # Closing the response may not actually be sufficient to close
                       # everything, so if we have a hold of the connection close that
                       # too.
                       if self._connection:
                           self._connection.close()
       
                   # If we hold the original response but it's closed now, we should
                   # return the connection back to the pool.
    1:             if self._original_response and self._original_response.isclosed():
    1:                 self.release_conn()
       
    1:     def read(self, amt=None, decode_content=None, cache_content=False):
               """
               Similar to :meth:`httplib.HTTPResponse.read`, but with two additional
               parameters: ``decode_content`` and ``cache_content``.
       
               :param amt:
                   How much of the content to read. If specified, caching is skipped
                   because it doesn't make sense to cache partial content as the full
                   response.
       
               :param decode_content:
                   If True, will attempt to decode the body based on the
                   'content-encoding' header.
       
               :param cache_content:
                   If True, will save the returned data such that the same result is
                   returned despite of the state of the underlying file object. This
                   is useful if you want the ``.data`` property to continue working
                   after having ``.read()`` the file object. (Overridden if ``amt`` is
                   set.)
               """
               self._init_decoder()
               if decode_content is None:
                   decode_content = self.decode_content
       
               if self._fp is None:
                   return
       
               flush_decoder = False
               data = None
       
               with self._error_catcher():
                   if amt is None:
                       # cStringIO doesn't like amt=None
                       data = self._fp.read()
                       flush_decoder = True
                   else:
                       cache_content = False
                       data = self._fp.read(amt)
                       if amt != 0 and not data:  # Platform-specific: Buggy versions of Python.
                           # Close the connection when no data is returned
                           #
                           # This is redundant to what httplib/http.client _should_
                           # already do.  However, versions of python released before
                           # December 15, 2012 (http://bugs.python.org/issue16298) do
                           # not properly close the connection in all cases. There is
                           # no harm in redundantly calling close.
                           self._fp.close()
                           flush_decoder = True
       
               if data:
                   self._fp_bytes_read += len(data)
       
                   data = self._decode(data, decode_content, flush_decoder)
       
                   if cache_content:
                       self._body = data
       
               return data
       
    1:     def stream(self, amt=2**16, decode_content=None):
               """
               A generator wrapper for the read() method. A call will block until
               ``amt`` bytes have been read from the connection or until the
               connection is closed.
       
               :param amt:
                   How much of the content to read. The generator will return up to
                   much data per iteration, but may return less. This is particularly
                   likely when using compressed data. However, the empty string will
                   never be returned.
       
               :param decode_content:
                   If True, will attempt to decode the body based on the
                   'content-encoding' header.
               """
    1:         if self.chunked:
    2:             for line in self.read_chunked(amt, decode_content=decode_content):
    1:                 yield line
               else:
                   while not is_fp_closed(self._fp):
                       data = self.read(amt=amt, decode_content=decode_content)
       
                       if data:
                           yield data
       
    1:     @classmethod
           def from_httplib(ResponseCls, r, **response_kw):
               """
               Given an :class:`httplib.HTTPResponse` instance ``r``, return a
               corresponding :class:`urllib3.response.HTTPResponse` object.
       
               Remaining parameters are passed to the HTTPResponse constructor, along
               with ``original_response=r``.
               """
    1:         headers = r.msg
       
    1:         if not isinstance(headers, HTTPHeaderDict):
    1:             if PY3:  # Python 3
    1:                 headers = HTTPHeaderDict(headers.items())
                   else:  # Python 2
                       headers = HTTPHeaderDict.from_httplib(headers)
       
               # HTTPResponse objects in Python 3 don't have a .strict attribute
    1:         strict = getattr(r, 'strict', 0)
    1:         resp = ResponseCls(body=r,
    1:                            headers=headers,
    1:                            status=r.status,
    1:                            version=r.version,
    1:                            reason=r.reason,
    1:                            strict=strict,
    1:                            original_response=r,
    1:                            **response_kw)
    1:         return resp
       
           # Backwards-compatibility methods for httplib.HTTPResponse
    1:     def getheaders(self):
               return self.headers
       
    1:     def getheader(self, name, default=None):
               return self.headers.get(name, default)
       
           # Overrides from io.IOBase
    1:     def close(self):
               if not self.closed:
                   self._fp.close()
       
               if self._connection:
                   self._connection.close()
       
    1:     @property
           def closed(self):
    1:         if self._fp is None:
                   return True
    1:         elif hasattr(self._fp, 'closed'):
    1:             return self._fp.closed
               elif hasattr(self._fp, 'isclosed'):  # Python 2
                   return self._fp.isclosed()
               else:
                   return True
       
    1:     def fileno(self):
               if self._fp is None:
                   raise IOError("HTTPResponse has no file to get a fileno from")
               elif hasattr(self._fp, "fileno"):
                   return self._fp.fileno()
               else:
                   raise IOError("The file-like object this HTTPResponse is wrapped "
                                 "around has no file descriptor")
       
    1:     def flush(self):
               if self._fp is not None and hasattr(self._fp, 'flush'):
                   return self._fp.flush()
       
    1:     def readable(self):
               # This method is required for `io` module compatibility.
               return True
       
    1:     def readinto(self, b):
               # This method is required for `io` module compatibility.
               temp = self.read(len(b))
               if len(temp) == 0:
                   return 0
               else:
                   b[:len(temp)] = temp
                   return len(temp)
       
    1:     def _update_chunk_length(self):
               # First, we'll figure out length of a chunk and then
               # we'll try to read it from socket.
   23:         if self.chunk_left is not None:
                   return
   23:         line = self._fp.fp.readline()
   23:         line = line.split(b';', 1)[0]
   23:         try:
   23:             self.chunk_left = int(line, 16)
               except ValueError:
                   # Invalid chunked protocol response, abort.
                   self.close()
                   raise httplib.IncompleteRead(line)
       
    1:     def _handle_chunk(self, amt):
   22:         returned_chunk = None
   22:         if amt is None:
                   chunk = self._fp._safe_read(self.chunk_left)
                   returned_chunk = chunk
                   self._fp._safe_read(2)  # Toss the CRLF at the end of the chunk.
                   self.chunk_left = None
   22:         elif amt < self.chunk_left:
                   value = self._fp._safe_read(amt)
                   self.chunk_left = self.chunk_left - amt
                   returned_chunk = value
   22:         elif amt == self.chunk_left:
                   value = self._fp._safe_read(amt)
                   self._fp._safe_read(2)  # Toss the CRLF at the end of the chunk.
                   self.chunk_left = None
                   returned_chunk = value
               else:  # amt > self.chunk_left
   22:             returned_chunk = self._fp._safe_read(self.chunk_left)
   22:             self._fp._safe_read(2)  # Toss the CRLF at the end of the chunk.
   22:             self.chunk_left = None
   22:         return returned_chunk
       
    1:     def read_chunked(self, amt=None, decode_content=None):
               """
               Similar to :meth:`HTTPResponse.read`, but with an additional
               parameter: ``decode_content``.
       
               :param decode_content:
                   If True, will attempt to decode the body based on the
                   'content-encoding' header.
               """
    1:         self._init_decoder()
               # FIXME: Rewrite this method and make it a class with a better structured logic.
    1:         if not self.chunked:
                   raise ResponseNotChunked(
                       "Response is not chunked. "
                       "Header 'transfer-encoding: chunked' is missing.")
       
               # Don't bother reading the body of a HEAD request.
    1:         if self._original_response and is_response_to_head(self._original_response):
                   self._original_response.close()
                   return
       
    1:         with self._error_catcher():
    1:             while True:
   23:                 self._update_chunk_length()
   23:                 if self.chunk_left == 0:
    1:                     break
   22:                 chunk = self._handle_chunk(amt)
   22:                 decoded = self._decode(chunk, decode_content=decode_content,
   22:                                        flush_decoder=False)
   22:                 if decoded:
    1:                     yield decoded
       
    1:             if decode_content:
                       # On CPython and PyPy, we should never need to flush the
                       # decoder. However, on Jython we *might* need to, so
                       # lets defensively do it anyway.
    1:                 decoded = self._flush_decoder()
    1:                 if decoded:  # Platform-specific: Jython.
                           yield decoded
       
                   # Chunk content ends with \r\n: discard it.
    1:             while True:
    1:                 line = self._fp.fp.readline()
    1:                 if not line:
                           # Some sites may not end with '\r\n'.
                           break
    1:                 if line == b'\r\n':
    1:                     break
       
                   # We read everything; close the "file".
    1:             if self._original_response:
    1:                 self._original_response.close()
