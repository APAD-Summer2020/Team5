       # This file is dual licensed under the terms of the Apache License, Version
       # 2.0, and the BSD License. See the LICENSE file in the root of this repository
       # for complete details.
       
    1: from __future__ import absolute_import, division, print_function
       
       
    1: from cryptography import utils
    1: from cryptography.exceptions import UnsupportedAlgorithm, _Reasons
    1: from cryptography.hazmat.primitives import hashes
       
       
    2: @utils.register_interface(hashes.HashContext)
    1: class _HashContext(object):
    1:     def __init__(self, backend, algorithm, ctx=None):
    1:         self._algorithm = algorithm
       
    1:         self._backend = backend
       
    1:         if ctx is None:
    1:             ctx = self._backend._lib.Cryptography_EVP_MD_CTX_new()
    1:             ctx = self._backend._ffi.gc(
    1:                 ctx, self._backend._lib.Cryptography_EVP_MD_CTX_free
                   )
    1:             evp_md = self._backend._evp_md_from_algorithm(algorithm)
    1:             if evp_md == self._backend._ffi.NULL:
                       raise UnsupportedAlgorithm(
                           "{} is not a supported hash on this backend.".format(
                               algorithm.name),
                           _Reasons.UNSUPPORTED_HASH
                       )
    1:             res = self._backend._lib.EVP_DigestInit_ex(ctx, evp_md,
    1:                                                        self._backend._ffi.NULL)
    1:             self._backend.openssl_assert(res != 0)
       
    1:         self._ctx = ctx
       
    1:     algorithm = utils.read_only_property("_algorithm")
       
    1:     def copy(self):
               copied_ctx = self._backend._lib.Cryptography_EVP_MD_CTX_new()
               copied_ctx = self._backend._ffi.gc(
                   copied_ctx, self._backend._lib.Cryptography_EVP_MD_CTX_free
               )
               res = self._backend._lib.EVP_MD_CTX_copy_ex(copied_ctx, self._ctx)
               self._backend.openssl_assert(res != 0)
               return _HashContext(self._backend, self.algorithm, ctx=copied_ctx)
       
    1:     def update(self, data):
    1:         data_ptr = self._backend._ffi.from_buffer(data)
    1:         res = self._backend._lib.EVP_DigestUpdate(
    1:             self._ctx, data_ptr, len(data)
               )
    1:         self._backend.openssl_assert(res != 0)
       
    1:     def finalize(self):
    1:         if isinstance(self.algorithm, hashes.ExtendableOutputFunction):
                   # extendable output functions use a different finalize
                   return self._finalize_xof()
               else:
    1:             buf = self._backend._ffi.new("unsigned char[]",
    1:                                          self._backend._lib.EVP_MAX_MD_SIZE)
    1:             outlen = self._backend._ffi.new("unsigned int *")
    1:             res = self._backend._lib.EVP_DigestFinal_ex(self._ctx, buf, outlen)
    1:             self._backend.openssl_assert(res != 0)
    1:             self._backend.openssl_assert(
    1:                 outlen[0] == self.algorithm.digest_size
                   )
    1:             return self._backend._ffi.buffer(buf)[:outlen[0]]
       
    1:     def _finalize_xof(self):
               buf = self._backend._ffi.new("unsigned char[]",
                                            self.algorithm.digest_size)
               res = self._backend._lib.EVP_DigestFinalXOF(
                   self._ctx, buf, self.algorithm.digest_size
               )
               self._backend.openssl_assert(res != 0)
               return self._backend._ffi.buffer(buf)[:self.algorithm.digest_size]
