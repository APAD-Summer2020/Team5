    1: from __future__ import absolute_import
       # Base Exceptions
       
       
    2: class HTTPError(Exception):
    1:     "Base exception used by this module."
    1:     pass
       
       
    2: class HTTPWarning(Warning):
    1:     "Base warning used by this module."
    1:     pass
       
       
    2: class PoolError(HTTPError):
    1:     "Base exception for errors caused within a pool."
    1:     def __init__(self, pool, message):
               self.pool = pool
               HTTPError.__init__(self, "%s: %s" % (pool, message))
       
    1:     def __reduce__(self):
               # For pickling purposes.
               return self.__class__, (None, None)
       
       
    2: class RequestError(PoolError):
    1:     "Base exception for PoolErrors that have associated URLs."
    1:     def __init__(self, pool, url, message):
               self.url = url
               PoolError.__init__(self, pool, message)
       
    1:     def __reduce__(self):
               # For pickling purposes.
               return self.__class__, (None, self.url, None)
       
       
    2: class SSLError(HTTPError):
    1:     "Raised when SSL certificate fails in an HTTPS connection."
    1:     pass
       
       
    2: class ProxyError(HTTPError):
    1:     "Raised when the connection to a proxy fails."
    1:     pass
       
       
    2: class DecodeError(HTTPError):
    1:     "Raised when automatic decoding based on Content-Type fails."
    1:     pass
       
       
    2: class ProtocolError(HTTPError):
    1:     "Raised when something unexpected happens mid-request/response."
    1:     pass
       
       
       #: Renamed to ProtocolError but aliased for backwards compatibility.
    1: ConnectionError = ProtocolError
       
       
       # Leaf Exceptions
       
    2: class MaxRetryError(RequestError):
           """Raised when the maximum number of retries is exceeded.
       
           :param pool: The connection pool
           :type pool: :class:`~urllib3.connectionpool.HTTPConnectionPool`
           :param string url: The requested Url
           :param exceptions.Exception reason: The underlying error
       
    1:     """
       
    1:     def __init__(self, pool, url, reason=None):
               self.reason = reason
       
               message = "Max retries exceeded with url: %s (Caused by %r)" % (
                   url, reason)
       
               RequestError.__init__(self, pool, url, message)
       
       
    2: class HostChangedError(RequestError):
    1:     "Raised when an existing pool gets a request for a foreign host."
       
    1:     def __init__(self, pool, url, retries=3):
               message = "Tried to open a foreign host with url: %s" % url
               RequestError.__init__(self, pool, url, message)
               self.retries = retries
       
       
    2: class TimeoutStateError(HTTPError):
    1:     """ Raised when passing an invalid state to a timeout """
    1:     pass
       
       
    2: class TimeoutError(HTTPError):
           """ Raised when a socket timeout error occurs.
       
           Catching this error will catch both :exc:`ReadTimeoutErrors
           <ReadTimeoutError>` and :exc:`ConnectTimeoutErrors <ConnectTimeoutError>`.
    1:     """
    1:     pass
       
       
    2: class ReadTimeoutError(TimeoutError, RequestError):
    1:     "Raised when a socket timeout occurs while receiving data from a server"
    1:     pass
       
       
       # This timeout error does not have a URL attached and needs to inherit from the
       # base HTTPError
    2: class ConnectTimeoutError(TimeoutError):
    1:     "Raised when a socket timeout occurs while connecting to a server"
    1:     pass
       
       
    2: class NewConnectionError(ConnectTimeoutError, PoolError):
    1:     "Raised when we fail to establish a new connection. Usually ECONNREFUSED."
    1:     pass
       
       
    2: class EmptyPoolError(PoolError):
    1:     "Raised when a pool runs out of connections and no more are allowed."
    1:     pass
       
       
    2: class ClosedPoolError(PoolError):
    1:     "Raised when a request enters a pool after the pool has been closed."
    1:     pass
       
       
    2: class LocationValueError(ValueError, HTTPError):
    1:     "Raised when there is something wrong with a given URL input."
    1:     pass
       
       
    2: class LocationParseError(LocationValueError):
    1:     "Raised when get_host or similar fails to parse the URL input."
       
    1:     def __init__(self, location):
               message = "Failed to parse: %s" % location
               HTTPError.__init__(self, message)
       
               self.location = location
       
       
    2: class ResponseError(HTTPError):
    1:     "Used as a container for an error reason supplied in a MaxRetryError."
    1:     GENERIC_ERROR = 'too many error responses'
    1:     SPECIFIC_ERROR = 'too many {status_code} error responses'
       
       
    2: class SecurityWarning(HTTPWarning):
    1:     "Warned when perfoming security reducing actions"
    1:     pass
       
       
    2: class SubjectAltNameWarning(SecurityWarning):
    1:     "Warned when connecting to a host with a certificate missing a SAN."
    1:     pass
       
       
    2: class InsecureRequestWarning(SecurityWarning):
    1:     "Warned when making an unverified HTTPS request."
    1:     pass
       
       
    2: class SystemTimeWarning(SecurityWarning):
    1:     "Warned when system time is suspected to be wrong"
    1:     pass
       
       
    2: class InsecurePlatformWarning(SecurityWarning):
    1:     "Warned when certain SSL configuration is not available on a platform."
    1:     pass
       
       
    2: class SNIMissingWarning(HTTPWarning):
    1:     "Warned when making a HTTPS request without SNI available."
    1:     pass
       
       
    2: class DependencyWarning(HTTPWarning):
           """
           Warned when an attempt is made to import a module with missing optional
           dependencies.
    1:     """
    1:     pass
       
       
    2: class ResponseNotChunked(ProtocolError, ValueError):
    1:     "Response needs to be chunked in order to read it as chunks."
    1:     pass
       
       
    2: class ProxySchemeUnknown(AssertionError, ValueError):
    1:     "ProxyManager does not support the supplied scheme"
           # TODO(t-8ch): Stop inheriting from AssertionError in v2.0.
       
    1:     def __init__(self, scheme):
               message = "Not supported proxy scheme %s" % scheme
               super(ProxySchemeUnknown, self).__init__(message)
       
       
    2: class HeaderParsingError(HTTPError):
    1:     "Raised by assert_header_parsing, but we convert it to a log.warning statement."
    1:     def __init__(self, defects, unparsed_data):
               message = '%s, unparsed data: %r' % (defects or 'Unknown', unparsed_data)
               super(HeaderParsingError, self).__init__(message)
