       # -*- coding: utf-8 -*-
       """
           flask.wrappers
           ~~~~~~~~~~~~~~
       
           Implements the WSGI wrappers (request and response).
       
           :copyright: 2010 Pallets
           :license: BSD-3-Clause
    1: """
    1: from werkzeug.exceptions import BadRequest
    1: from werkzeug.wrappers import Request as RequestBase
    1: from werkzeug.wrappers import Response as ResponseBase
    1: from werkzeug.wrappers.json import JSONMixin as _JSONMixin
       
    1: from . import json
    1: from .globals import current_app
       
       
    2: class JSONMixin(_JSONMixin):
    1:     json_module = json
       
    1:     def on_json_loading_failed(self, e):
               if current_app and current_app.debug:
                   raise BadRequest("Failed to decode JSON object: {0}".format(e))
       
               raise BadRequest()
       
       
    2: class Request(RequestBase, JSONMixin):
           """The request object used by default in Flask.  Remembers the
           matched endpoint and view arguments.
       
           It is what ends up as :class:`~flask.request`.  If you want to replace
           the request object used you can subclass this and set
           :attr:`~flask.Flask.request_class` to your subclass.
       
           The request object is a :class:`~werkzeug.wrappers.Request` subclass and
           provides all of the attributes Werkzeug defines plus a few Flask
           specific ones.
    1:     """
       
           #: The internal URL rule that matched the request.  This can be
           #: useful to inspect which methods are allowed for the URL from
           #: a before/after handler (``request.url_rule.methods``) etc.
           #: Though if the request's method was invalid for the URL rule,
           #: the valid list is available in ``routing_exception.valid_methods``
           #: instead (an attribute of the Werkzeug exception
           #: :exc:`~werkzeug.exceptions.MethodNotAllowed`)
           #: because the request was never internally bound.
           #:
           #: .. versionadded:: 0.6
    1:     url_rule = None
       
           #: A dict of view arguments that matched the request.  If an exception
           #: happened when matching, this will be ``None``.
    1:     view_args = None
       
           #: If matching the URL failed, this is the exception that will be
           #: raised / was raised as part of the request handling.  This is
           #: usually a :exc:`~werkzeug.exceptions.NotFound` exception or
           #: something similar.
    1:     routing_exception = None
       
    1:     @property
           def max_content_length(self):
               """Read-only view of the ``MAX_CONTENT_LENGTH`` config key."""
               if current_app:
                   return current_app.config["MAX_CONTENT_LENGTH"]
       
    1:     @property
           def endpoint(self):
               """The endpoint that matched the request.  This in combination with
               :attr:`view_args` can be used to reconstruct the same or a
               modified URL.  If an exception happened when matching, this will
               be ``None``.
               """
               if self.url_rule is not None:
                   return self.url_rule.endpoint
       
    1:     @property
           def blueprint(self):
               """The name of the current blueprint"""
               if self.url_rule and "." in self.url_rule.endpoint:
                   return self.url_rule.endpoint.rsplit(".", 1)[0]
       
    1:     def _load_form_data(self):
               RequestBase._load_form_data(self)
       
               # In debug mode we're replacing the files multidict with an ad-hoc
               # subclass that raises a different error for key errors.
               if (
                   current_app
                   and current_app.debug
                   and self.mimetype != "multipart/form-data"
                   and not self.files
               ):
                   from .debughelpers import attach_enctype_error_multidict
       
                   attach_enctype_error_multidict(self)
       
       
    2: class Response(ResponseBase, JSONMixin):
           """The response object that is used by default in Flask.  Works like the
           response object from Werkzeug but is set to have an HTML mimetype by
           default.  Quite often you don't have to create this object yourself because
           :meth:`~flask.Flask.make_response` will take care of that for you.
       
           If you want to replace the response object used you can subclass this and
           set :attr:`~flask.Flask.response_class` to your subclass.
       
           .. versionchanged:: 1.0
               JSON support is added to the response, like the request. This is useful
               when testing to get the test client response data as JSON.
       
           .. versionchanged:: 1.0
       
               Added :attr:`max_cookie_size`.
    1:     """
       
    1:     default_mimetype = "text/html"
       
    1:     def _get_data_for_json(self, cache):
               return self.get_data()
       
    1:     @property
           def max_cookie_size(self):
               """Read-only view of the :data:`MAX_COOKIE_SIZE` config key.
       
               See :attr:`~werkzeug.wrappers.BaseResponse.max_cookie_size` in
               Werkzeug's docs.
               """
               if current_app:
                   return current_app.config["MAX_COOKIE_SIZE"]
       
               # return Werkzeug's default when not in an app context
               return super(Response, self).max_cookie_size
