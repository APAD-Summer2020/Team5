       # Copyright 2017 Google LLC
       #
       # Licensed under the Apache License, Version 2.0 (the "License");
       # you may not use this file except in compliance with the License.
       # You may obtain a copy of the License at
       #
       #     http://www.apache.org/licenses/LICENSE-2.0
       #
       # Unless required by applicable law or agreed to in writing, software
       # distributed under the License is distributed on an "AS IS" BASIS,
       # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       # See the License for the specific language governing permissions and
       # limitations under the License.
       
       """Decorators for applying timeout arguments to functions.
       
       These decorators are used to wrap API methods to apply either a constant
       or exponential timeout argument.
       
       For example, imagine an API method that can take a while to return results,
       such as one that might block until a resource is ready:
       
       .. code-block:: python
       
           def is_thing_ready(timeout=None):
               response = requests.get('https://example.com/is_thing_ready')
               response.raise_for_status()
               return response.json()
       
       This module allows a function like this to be wrapped so that timeouts are
       automatically determined, for example:
       
       .. code-block:: python
       
           timeout_ = timeout.ExponentialTimeout()
           is_thing_ready_with_timeout = timeout_(is_thing_ready)
       
           for n in range(10):
               try:
                   is_thing_ready_with_timeout({'example': 'data'})
               except:
                   pass
       
       In this example the first call to ``is_thing_ready`` will have a relatively
       small timeout (like 1 second). If the resource is available and the request
       completes quickly, the loop exits. But, if the resource isn't yet available
       and the request times out, it'll be retried - this time with a larger timeout.
       
       In the broader context these decorators are typically combined with
       :mod:`google.api_core.retry` to implement API methods with a signature that
       matches ``api_method(request, timeout=None, retry=None)``.
    1: """
       
    1: from __future__ import unicode_literals
       
    1: import datetime
       
    1: import six
       
    1: from google.api_core import datetime_helpers
    1: from google.api_core import general_helpers
       
    1: _DEFAULT_INITIAL_TIMEOUT = 5.0  # seconds
    1: _DEFAULT_MAXIMUM_TIMEOUT = 30.0  # seconds
    1: _DEFAULT_TIMEOUT_MULTIPLIER = 2.0
       # If specified, must be in seconds. If none, deadline is not used in the
       # timeout calculation.
    1: _DEFAULT_DEADLINE = None
       
       
    2: @six.python_2_unicode_compatible
    1: class ConstantTimeout(object):
           """A decorator that adds a constant timeout argument.
       
           This is effectively equivalent to
           ``functools.partial(func, timeout=timeout)``.
       
           Args:
               timeout (Optional[float]): the timeout (in seconds) to applied to the
                   wrapped function. If `None`, the target function is expected to
                   never timeout.
    1:     """
       
    1:     def __init__(self, timeout=None):
               self._timeout = timeout
       
    1:     def __call__(self, func):
               """Apply the timeout decorator.
       
               Args:
                   func (Callable): The function to apply the timeout argument to.
                       This function must accept a timeout keyword argument.
       
               Returns:
                   Callable: The wrapped function.
               """
       
               @general_helpers.wraps(func)
               def func_with_timeout(*args, **kwargs):
                   """Wrapped function that adds timeout."""
                   kwargs["timeout"] = self._timeout
                   return func(*args, **kwargs)
       
               return func_with_timeout
       
    1:     def __str__(self):
               return "<ConstantTimeout timeout={:.1f}>".format(self._timeout)
       
       
    1: def _exponential_timeout_generator(initial, maximum, multiplier, deadline):
           """A generator that yields exponential timeout values.
       
           Args:
               initial (float): The initial timeout.
               maximum (float): The maximum timeout.
               multiplier (float): The multiplier applied to the timeout.
               deadline (float): The overall deadline across all invocations.
       
           Yields:
               float: A timeout value.
           """
    2:     if deadline is not None:
    2:         deadline_datetime = datetime_helpers.utcnow() + datetime.timedelta(
    2:             seconds=deadline
               )
           else:
               deadline_datetime = datetime.datetime.max
       
    2:     timeout = initial
    2:     while True:
    2:         now = datetime_helpers.utcnow()
    2:         yield min(
                   # The calculated timeout based on invocations.
    2:             timeout,
                   # The set maximum timeout.
    2:             maximum,
                   # The remaining time before the deadline is reached.
    2:             float((deadline_datetime - now).seconds),
               )
               timeout = timeout * multiplier
       
       
    2: @six.python_2_unicode_compatible
    1: class ExponentialTimeout(object):
           """A decorator that adds an exponentially increasing timeout argument.
       
           This is useful if a function is called multiple times. Each time the
           function is called this decorator will calculate a new timeout parameter
           based on the the number of times the function has been called.
       
           For example
       
           .. code-block:: python
       
           Args:
               initial (float): The initial timeout to pass.
               maximum (float): The maximum timeout for any one call.
               multiplier (float): The multiplier applied to the timeout for each
                   invocation.
               deadline (Optional[float]): The overall deadline across all
                   invocations. This is used to prevent a very large calculated
                   timeout from pushing the overall execution time over the deadline.
                   This is especially useful in conjuction with
                   :mod:`google.api_core.retry`. If ``None``, the timeouts will not
                   be adjusted to accomodate an overall deadline.
    1:     """
       
           def __init__(
               self,
    1:         initial=_DEFAULT_INITIAL_TIMEOUT,
    1:         maximum=_DEFAULT_MAXIMUM_TIMEOUT,
    1:         multiplier=_DEFAULT_TIMEOUT_MULTIPLIER,
    1:         deadline=_DEFAULT_DEADLINE,
           ):
   15:         self._initial = initial
   15:         self._maximum = maximum
   15:         self._multiplier = multiplier
   15:         self._deadline = deadline
       
    1:     def with_deadline(self, deadline):
               """Return a copy of this teimout with the given deadline.
       
               Args:
                   deadline (float): The overall deadline across all invocations.
       
               Returns:
                   ExponentialTimeout: A new instance with the given deadline.
               """
               return ExponentialTimeout(
                   initial=self._initial,
                   maximum=self._maximum,
                   multiplier=self._multiplier,
                   deadline=deadline,
               )
       
    1:     def __call__(self, func):
               """Apply the timeout decorator.
       
               Args:
                   func (Callable): The function to apply the timeout argument to.
                       This function must accept a timeout keyword argument.
       
               Returns:
                   Callable: The wrapped function.
               """
    2:         timeouts = _exponential_timeout_generator(
    2:             self._initial, self._maximum, self._multiplier, self._deadline
               )
       
    2:         @general_helpers.wraps(func)
               def func_with_timeout(*args, **kwargs):
                   """Wrapped function that adds timeout."""
    2:             kwargs["timeout"] = next(timeouts)
    2:             return func(*args, **kwargs)
       
    2:         return func_with_timeout
       
    1:     def __str__(self):
               return (
                   "<ExponentialTimeout initial={:.1f}, maximum={:.1f}, "
                   "multiplier={:.1f}, deadline={:.1f}>".format(
                       self._initial, self._maximum, self._multiplier, self._deadline
                   )
               )
